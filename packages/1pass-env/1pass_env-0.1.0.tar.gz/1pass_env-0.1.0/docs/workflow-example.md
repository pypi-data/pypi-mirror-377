# Complete 1pass-env Workflow Example

This document demonstrates a complete workflow using 1pass-env with the new import functionality.

## Prerequisites

1. **Install 1pass-env**:
   ```bash
   pip install 1pass-env
   ```

2. **Set up 1Password service account**:
   ```bash
   export OP_SERVICE_ACCOUNT_TOKEN="your-service-account-token"
   ```

3. **Verify setup**:
   ```bash
   1pass-env check
   ```

## Scenario: Setting up a new project

Let's say you have a web application project and want to manage its environment variables using 1Password.

### Step 1: Organize your 1Password vault

Create items in your 1Password vault named "tokens" (or any vault you prefer):

**Item: "my-web-app"**
- API_KEY: `sk-1234567890abcdef`
- DATABASE_URL: `postgresql://user:pass@localhost:5432/myapp`
- JWT_SECRET: `super-secret-jwt-key`
- REDIS_URL: `redis://localhost:6379`
- SMTP_PASSWORD: `email-service-password`

### Step 2: Import all variables

```bash
cd my-web-app  # Your project directory
1pass-env import --name my-web-app
```

This creates a `1pass.env` file with all variables:
```bash
# Environment variables imported from 1Password
# Vault: tokens
# Item: my-web-app
# Generated by 1pass-env

API_KEY="sk-1234567890abcdef"
DATABASE_URL="postgresql://user:pass@localhost:5432/myapp"
JWT_SECRET="super-secret-jwt-key"
REDIS_URL="redis://localhost:6379"
SMTP_PASSWORD="email-service-password"
```

### Step 3: Import environment-specific variables

For different environments, create separate items in 1Password:

**Development environment:**
```bash
1pass-env import --vault dev-secrets --name my-web-app --file .env.development
```

**Staging environment:**
```bash
1pass-env import --vault staging-secrets --name my-web-app --file .env.staging
```

**Production environment:**
```bash
1pass-env import --vault prod-secrets --name my-web-app --file .env.production
```

### Step 4: Import only specific variables

For a CI/CD pipeline that only needs API credentials:
```bash
1pass-env import --name my-web-app --fields API_KEY,JWT_SECRET --file .env.ci
```

### Step 5: Run your application

**Development:**
```bash
1pass-env run --file .env.development npm run dev
```

**Production:**
```bash
1pass-env run --file .env.production npm start
```

**Docker deployment:**
```bash
1pass-env run --file .env.production docker-compose up -d
```

## Advanced Workflows

### Team Collaboration

Each team member can import the same secrets:
```bash
# Everyone runs this to get the shared secrets
1pass-env import --name team-project

# Each person can add their own local overrides
echo "DEBUG=true" >> 1pass.env
echo "PORT=3001" >> 1pass.env
```

### Multi-service Architecture

For a project with multiple services:
```bash
# Import shared secrets
1pass-env import --name shared-services --file .env.shared

# Import service-specific secrets
1pass-env import --name api-service --file .env.api
1pass-env import --name worker-service --file .env.worker
1pass-env import --name frontend-service --file .env.frontend

# Combine environments when running services
cat .env.shared .env.api > .env.api-combined
1pass-env run --file .env.api-combined npm run start:api
```

### Automated Deployments

In your CI/CD pipeline:
```yaml
# GitHub Actions example
- name: Import production secrets
  env:
    OP_SERVICE_ACCOUNT_TOKEN: ${{ secrets.OP_SERVICE_ACCOUNT_TOKEN }}
  run: |
    pip install 1pass-env
    1pass-env import --vault prod-secrets --name ${{ github.event.repository.name }} --file .env.production

- name: Deploy application
  run: |
    1pass-env run --file .env.production docker deploy --stack myapp
```

### Local Development vs Production

```bash
# Import production secrets as base
1pass-env import --vault prod-secrets --name my-app --file .env.base

# Override with development-specific values
cat > .env.dev << EOF
# Development overrides
DEBUG=true
LOG_LEVEL=debug
DATABASE_URL=postgresql://localhost:5432/myapp_dev
REDIS_URL=redis://localhost:6379/0
EOF

# Merge them (dev values take precedence)
cat .env.base .env.dev > .env.development

# Run with merged environment
1pass-env run --file .env.development npm run dev
```

## Security Best Practices

### 1. File Permissions
```bash
# Restrict access to environment files
chmod 600 .env*
chmod 600 1pass.env*
```

### 2. Git Ignore
Add to `.gitignore`:
```
# Environment files
.env*
1pass.env*
*.env

# But allow templates
!.env.template
!.env.example
```

### 3. Rotate Secrets Regularly
```bash
# After updating secrets in 1Password, re-import
1pass-env import --name my-app --file .env.production

# Restart services with new secrets
1pass-env run --file .env.production docker-compose restart
```

### 4. Audit Trail
```bash
# Use debug mode to see exactly what was imported (in secure environments only)
1pass-env import --name my-app --debug

# Check what's currently in your environment
1pass-env run --file 1pass.env printenv | grep -E '^(API_|DB_|JWT_)'
```

## Troubleshooting

### Common Issues

**Item not found:**
```bash
# List available items
1pass-env check --vault tokens

# Check exact item name
op item list --vault tokens --format json | jq -r '.[].title'
```

**Wrong vault:**
```bash
# List all vaults
1pass-env check

# Use specific vault
1pass-env import --vault correct-vault-name --name my-app
```

**Field not found:**
```bash
# See all available fields
1pass-env import --name my-app --debug

# Import only existing fields
1pass-env import --name my-app --fields EXISTING_FIELD_1,EXISTING_FIELD_2
```

**Permission denied:**
```bash
# Check service account permissions
1pass-env check --vault your-vault-name

# Ensure service account has read access to the vault
```

This workflow demonstrates the power and flexibility of the 1pass-env import command for managing environment variables across different scenarios and environments.

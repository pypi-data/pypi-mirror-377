meta_ann = {
    # 插件信息
    "plugin.type": "使用的 OpenAPI 插件类型（slurmctld 或 slurmdbd）",
    "plugin.name": "插件的友好名称",
    "plugin.data_parser": "用于解析/生成消息的版本信息",
    "plugin.accounting_storage": "用于会计存储的模块名（一般为 slurmdbd 或其他）",
    # 客户端信息
    "client.source": "客户端的来源标识（Host:port）",
    "client.user": "发起请求的用户名",
    "client.group": "发起请求的用户组",
    # 执行命令（内部工具路径，非所有响应都有）
    "command[]": "Slurm 内部命令路径序列，如 ['scontrol','show','job']（如果存在）",
    # Slurm 集群与版本信息
    "slurm.cluster": "Slurm 集群的名称",
    "slurm.release": "Slurm 发布版本字符串",
    "slurm.version": "Slurm 版本号",
    # 通用错误与警告
    "warnings*": "警告列表，每项包含 description 和 source 字段（可选）",
    "errors*": "错误列表，每项包含 description, source, error, error_number 等字段（可选）",
}
stats_ann = {
    # 顶层统计与时间戳
    "*.parts_packed": "打包的消息分段数量（内部字段）；只有RPC调用时为0",
    "*.req_time.number": "生成本次统计的时间戳（Unix秒）",
    "*.req_time_start.number": "本统计周期起始时间（Unix秒，默认每日UTC午夜重置）",
    "*.job_states_ts.number": "作业状态快照时间戳（Unix秒）",
    # slurmctld 线程与队列（来自 sdiag 第一块）
    "*.server_thread_count": "当前 slurmctld 活动线程数；接近上限表示控制器压力较高",
    "*.agent_queue_size": "控制器到各节点的代理队列长度（待发送的RPC数）",
    "*.agent_count": "代理线程数量（负责批量发送到 slurmd 的RPC）",
    "*.agent_thread_count": "由所有代理线程派生的活动线程总数",
    "*.dbd_agent_queue_size": "发往 slurmdbd 的待处理消息数；持续增大需检查 slurmdbd/数据库",
    "*.gettimeofday_latency": "控制器启动时测得的 gettimeofday() 1000 次调用总延迟（微秒）",
    # 作业计数（自上次重置以来）
    "*.jobs_submitted": "提交的作业数量",
    "*.jobs_started": "已启动的作业数量（包含回填启动的作业）",
    "*.jobs_completed": "完成的作业数量",
    "*.jobs_canceled": "被取消的作业数量",
    "*.jobs_failed": "因内部问题失败的作业数量（slurmd等原因）",
    "*.jobs_pending": "快照时处于PENDING的作业数",
    "*.jobs_running": "快照时处于RUNNING的作业数",
    # 主调度器指标（sdiag“Scheduling cycles”块）
    "*.schedule_cycle_last": "上一次主调度周期耗时（微秒）",
    "*.schedule_cycle_max": "主调度周期耗时最大值（微秒）",
    "*.schedule_cycle_sum": "主调度周期总耗时累计（微秒）",
    "*.schedule_cycle_total": "主调度执行的周期次数",
    "*.schedule_cycle_mean": "主调度周期平均耗时（微秒）",
    "*.schedule_cycle_mean_depth": "调度周期平均深度（每周期尝试处理的作业数）",
    "*.schedule_cycle_per_minute": "每分钟调度执行次数",
    "*.schedule_cycle_depth": "最近一次调度周期的作业处理深度（尝试数）",
    "*.schedule_queue_length": "主调度器看到的待调度队列长度（PENDING作业行数）",
    # 主调度循环的退出原因（达到阈值的停止条件）
    "*.schedule_exit.end_job_queue": "到达作业队列末尾（本轮不再有可处理的作业）",
    "*.schedule_exit.default_queue_depth": "达到默认的调度深度上限",
    "*.schedule_exit.max_job_start": "达到本轮允许启动的作业数量上限",
    "*.schedule_exit.max_rpc_cnt": "达到本轮允许的RPC调用次数上限",
    "*.schedule_exit.max_sched_time": "达到本轮调度允许的时间上限（微秒）",
    "*.schedule_exit.licenses": "受许可证可用性限制而退出",
    # 回填（Backfill）调度统计（sdiag“Backfilling”块）
    "*.bf_backfilled_jobs": "自slurm启动以来通过回填启动的作业总数",
    "*.bf_last_backfilled_jobs": "自上次统计重置以来通过回填启动的作业数",
    "*.bf_backfilled_het_jobs": "自slurm启动以来回填启动的异构作业组件数",
    "*.bf_cycle_counter": "自重置以来回填调度循环次数",
    "*.bf_cycle_last": "上一次回填调度循环耗时（微秒，不含内部sleep）",
    "*.bf_cycle_max": "回填调度循环最大耗时（微秒）",
    "*.bf_cycle_mean": "回填调度循环平均耗时（微秒）",
    "*.bf_depth_mean": "回填循环平均处理的作业数（排除明显不可运行者）",
    "*.bf_depth_mean_try": "回填循环平均真正尝试调度的作业数（有机会运行的子集）",
    "*.bf_last_depth": "上一次回填循环处理的作业数（含不可运行）",
    "*.bf_last_depth_try": "上一次回填循环中被实际尝试调度的作业数",
    "*.bf_depth_sum": "回填循环处理的作业数累计（含不可运行）",
    "*.bf_depth_try_sum": "回填循环实际尝试调度的作业数累计",
    "*.bf_queue_len": "当前回填视角下待处理作业队列长度（按分区计数）",
    "*.bf_queue_len_mean": "回填队列长度的平均值",
    "*.bf_queue_len_sum": "回填队列长度的累计和（便于推均值）",
    "*.bf_table_size": "上一次回填循环测试的时间槽数量（影响回填耗时）",
    "*.bf_table_size_sum": "回填循环测试时间槽数量的累计和",
    "*.bf_table_size_mean": "回填循环测试时间槽数量的平均值",
    "*.bf_when_last_cycle.number": "上一次回填循环发生时间（Unix秒；某些特殊大值表示尚未发生/无数据）",
    "*.bf_active": "回填调度是否处于活动状态",
    "*.bf_exit.end_job_queue": "回填：到达作业队列末尾",
    "*.bf_exit.bf_max_job_start": "回填：达到本轮允许启动的作业上限",
    "*.bf_exit.bf_max_job_test": "回填：达到本轮允许测试的作业数上限",
    "*.bf_exit.bf_max_time": "回填：达到本轮回填允许的时间上限（微秒）",
    "*.bf_exit.bf_node_space_size": "回填：达到内部表大小（时间槽）上限",
    "*.bf_exit.state_changed": "回填：期间发生状态变化而提前结束本轮",
    # RPC 统计（sdiag“RPCs by message type / by user / pending”块）
    "*.rpcs_by_message_type*.type_id": "RPC消息类型的数值ID",
    "*.rpcs_by_message_type*.message_type": "RPC消息类型名称",
    "*.rpcs_by_message_type*.count": "该RPC类型的累计调用次数",
    "*.rpcs_by_message_type*.queued": "该RPC类型当前在代理队列中的待发数",
    "*.rpcs_by_message_type*.dropped": "该RPC类型被丢弃的次数",
    "*.rpcs_by_message_type*.cycle_last": "最近一次统计周期内该RPC耗时（微秒，若提供）",
    "*.rpcs_by_message_type*.cycle_max": "统计期内该RPC最大单次耗时（微秒，若提供）",
    "*.rpcs_by_message_type*.total_time": "该RPC累计总耗时（微秒）",
    "*.rpcs_by_message_type*.average_time.number": "该RPC平均单次耗时（微秒）",
    "*.rpcs_by_user*.user_id": "发起RPC的用户ID",
    "*.rpcs_by_user*.user": "发起RPC的用户名",
    "*.rpcs_by_user*.count": "该用户累计发起的RPC次数",
    "*.rpcs_by_user*.total_time": "该用户RPC累计总耗时（微秒）",
    "*.rpcs_by_user*.average_time.number": "该用户RPC平均单次耗时（微秒）",
    "*.pending_rpcs": "当前代理队列里按类型汇总的待发RPC信息（每30秒刷新）",
    "*.pending_rpcs_by_hostlist": "代理队列中前若干个具体待发RPC条目（含目标主机列表）",
}
job_info_ann = {
    # # job 基本标识与状态
    # "jobs.account": "作业所属的账户／项目",
    # "jobs.array_job_id": "数组作业的 ID 或标识",
    # "jobs.array_task_id": "数组作业的 ID 或标识",
    # "jobs.accrue_time": "额外增加的时间",
    # "jobs.admin_comment": "管理员注释",
    # "jobs.allocating_node": "分配节点",
    # "jobs.array_max_tasks": "数组作业最大任务数量",
    # "jobs.array_task_string": "任务 ID",
    # "jobs.association_id": "关联 ID",
    # "jobs.batch_features": "批处理脚本节点所需的功能",
    # "jobs.batch_flag": "是否为批处理作业",
    # "jobs.billable_tres": "",
    # "jobs.burst_buffer": "突发缓冲区规格",
    # "jobs.burst_buffer_state": "突发缓冲区规格状态",
    # job 基本标识与状态
    "jobs.job_id": "作业的 ID，用来唯一标识该作业",
    "jobs.name": "提交作业时指定的作业名称",
    "jobs.user": "提交作业的用户名",
    "jobs.account": "作业所属的账户／项目",
    "jobs.partition": "作业提交或分配所在的分区（partition）",
    "jobs.qos": "作业使用的 QoS（Quality of Service）",
    # 时间／状态
    "jobs.submission_time": "作业被提交的时间戳",
    "jobs.start_time": "作业开始运行的时间；如果未开始则可能为空或缺省",
    "jobs.end_time": "作业结束（完成或失败）的时间；如果未结束则为空",
    "jobs.time_limit": "作业的最大允许运行时间／时限（timelimit）",
    "jobs.state": "当前作业状态（如 PENDING, RUNNING, COMPLETED, FAILED, CANCELLED, etc.）",
    # 资源和规模
    "jobs.nodes": "作业被分配／请求的节点数或节点列表",
    "jobs.ntasks": "任务数（tasks 或进程数）",
    "jobs.cpus_per_task": "每任务所需 CPU 核数",
    "jobs.total_cpus": "作业实际／请求的总 CPU 数（可能等于 ntasks * cpus_per_task）",
    "jobs.memory_per_node": "每个节点分配的内存量（或请求的内存数／限制）",
    "jobs.mem_per_cpu": "每个 CPU 核的内存配额（如果配置了此项）",
    # 输入／输出脚本与环境
    "jobs.script": "提交作业时脚本内容（通常是 sbatch 脚本）",
    "jobs.environment": "作业执行环境变量的列表／映射",
    "jobs.stdout_path": "标准输出文件路径（如果通过选项指定）",
    "jobs.stderr_path": "标准错误文件路径",
    # 依赖与队列行为
    "jobs.dependency": "作业依赖条件（如果有）",
    "jobs.array_job_id": "如果是作业数组 (array job)，这是数组作业的 ID 或标识",
    "jobs.tasks": "更详细的任务子结构，例如任务数，任务在各节点上的分布等",
    # 会计与资源使用等（如果 accounting 开启或 job 已运行完部分）
    "jobs.used_cpus": "已使用的 CPU 总数或已消耗 CPU 时间",
    "jobs.used_memory": "已使用的内存（可能是最大内存／平均内存等）",
    "jobs.used_time": "已运行时间（从开始运行到当前或结束）",
    "jobs.exit_code": "作业完成后的退出状态／代码",
    "jobs.requeue": "是否被重新排队（如果作业失败或被终止后被重试）",
    # 调度与优先级
    "jobs.priority": "作业在调度系统中的优先级值",
    "jobs.nice": "nice 值（如果调度系统使用）",
    "jobs.partition_priority": "所在分区的优先级或排序权重",
    # 节点详情（如果展开）
    "jobs.node_list": "实际分配的节点列表或节点名称范围",
    "jobs.node_features": "节点特性约束（features / constraints）",
    "jobs.constraints": "提交作业时对节点所要求的约束（例如在带特定资源或标签的节点上运行）",
    # 额外／可选字段
    "jobs.comment": "提交或管理员添加的注释字段（如果配置允许）",
    "jobs.submit_host": "从哪个主机提交的作业（login node 或 submission host）",
    "jobs.deadline": "如果作业有 deadline（截止时间）的话",
    # indexing /版本控制
    "jobs.job_array_index": "如果是数组作业，该任务在数组内的索引",
    "jobs.heterogeneous": "是否为异构作业（heterogeneous job）",
    # 可能的信号与取消
    "jobs.cancelled": "作业是否被取消",
    "jobs.cancel_time": "取消时间（如果有）",
    "jobs.fail_reason": "失败原因／错误信息（如果作业状态为失败或取消）",
}
ping_ann = {
    "*.hostname": "主机名",
    "*.latency": "响应时长",
    "*.mode": "当前运行模式",
    "*.pinged": "当前状态",
    "*.primary": "是否为主控制器",
    "*.responding": "收到回应",
}
submit_ann = {
    "*.job_id": "任务 ID",
    "*.step_id": "已提交步骤 ID",
    "*.job_submit_user_msg": "作业提交用户消息",
}

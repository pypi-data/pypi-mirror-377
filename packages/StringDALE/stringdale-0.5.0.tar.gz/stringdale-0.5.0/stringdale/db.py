# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/025_dbs.ipynb.

# %% auto 0
__all__ = ['logger', 'check_openai_key', 'openai_client', 'async_openai_client', 'openai_embed', 'OpenAIEmbed',
           'CachedEmbeddingFunction', 'ChromaClient', 'temp_sql_db']

# %% ../nbs/025_dbs.ipynb 5
import os
from pathlib import Path
from copy import deepcopy
from fastcore.foundation import L
import json

from collections import defaultdict
from singleton_decorator import singleton

import logging

logger = logging.getLogger(__name__)

from openai import OpenAI
import base64
from typing import Optional

from joblib import Memory
from pathlib import Path

from .core import disk_cache



# %% ../nbs/025_dbs.ipynb 7
import chromadb
from chromadb.config import Settings
from typing import List, Dict, Any, Optional,Literal
import uuid


# %% ../nbs/025_dbs.ipynb 8
import chromadb
from chromadb.config import Settings
from typing import List, Dict, Any, Optional
from openai import OpenAI,AsyncOpenAI
from copy import copy,deepcopy

# %% ../nbs/025_dbs.ipynb 9
import nest_asyncio
import numpy as np


# %% ../nbs/025_dbs.ipynb 11
def check_openai_key():
    api_key = os.getenv('OPENAI_API_KEY',None)
    if not api_key:
        raise ValueError('OPENAI_API_KEY is not set')

@singleton
def openai_client():
    check_openai_key()
    return OpenAI()

@singleton
def async_openai_client():
    check_openai_key()
    return AsyncOpenAI()
        

# %% ../nbs/025_dbs.ipynb 12
@disk_cache.cache
async def openai_embed(text, model='text-embedding-3-small'):
    response = await async_openai_client().embeddings.create(
        input=text,
        model=model
    )
    return np.array(response.data[0].embedding)


class OpenAIEmbed():
    def __init__(self,model='text-embedding-3-small'):
        self.model = model

    async def __call__(self,text):
        response = await openai_embed(text,model=self.model)
        return response

    def __str__(self):
        return f'OpenAIEmbed(model={self.model})'
    def __repr__(self):
        return self.__str__()

class CachedEmbeddingFunction(chromadb.utils.embedding_functions.EmbeddingFunction):
    def __init__(self,model='text-embedding-3-small'):
        self.model = model
        
    async def _async_call(self, texts):
        import asyncio
        return await asyncio.gather(*[openai_embed(text, model=self.model) for text in texts])
        
    def __call__(self, texts):
        import asyncio
        return asyncio.run(self._async_call(texts))

# %% ../nbs/025_dbs.ipynb 14
class ChromaClient:
    def __init__(self,persist_path=None,embed_model='text-embedding-3-small'):
        """Initialize ChromaDB client with a collection name.
        
        Args:
            persist_path: Path to the directory to persist the database to
            embed_model: Model to use for embedding
        """

        self.embed_func = CachedEmbeddingFunction(model=embed_model)
        
        if persist_path:
            self.client = chromadb.PersistentClient(path=persist_path,settings=chromadb.Settings(allow_reset=True))
        else:
            self.client = chromadb.EphemeralClient(settings=chromadb.Settings(allow_reset=True))
        # Initialize Chroma with OpenAI embeddings
       
        current_collection_names = self.list_collections()
        self.collections={name:self.client.get_or_create_collection(name=name,embedding_function=self.embed_func) for name in current_collection_names}


    def reset(self):
        """Reset the database"""
        self.client.reset()
        self.collections={}
        
    def add_collection(self,name,distance:Literal['l2','ip','cosine']='l2',metadata=None,exists_ok=False):
        """Add a collection to the database

        Args:
            name: Name of the collection to add
            distance: Distance metric to use, one of 'l2','ip','cosine'. Default is 'l2'
            metadata: Metadata to add to the collection
            exists_ok: If True, do not raise an error if the collection already exists
        """
        if name in self.collections:
            if exists_ok:
                return
            raise ValueError(f'Collection {name} already exists')
        if metadata is None:
            metadata = {}
        metadata = {**metadata,**{'"hnsw:space"':distance}}
        self.collections[name] = self.client.get_or_create_collection(
            name=name,
            embedding_function=self.embed_func,
            metadata=metadata
        )

    def delete_collection(self,name):
        """Delete a collection from the database

        Args:
            name: Name of the collection to delete
        """
        self.client.delete_collection(name)
        del self.collections[name]

    def list_collections(self):
        """List all collections in the database

        Returns:
            List of collection names
        """
        return [col.name for col in self.client.list_collections()]

    def embed_texts(self,texts:List[str]):
        """Embed a list of texts

        Args:
            texts: List of texts to embed

        Returns:
            List of embeddings
        """

    def upsert(self,collection_name:str,docs):
        """Upsert a list of documents into a collection

        Args:
            collection_name: Name of the collection to upsert into
            docs: List of documents to upsert
                docs should be a list of dictionaries with a 'text' key, with optional 'id' and 'metadata' keys
        """
        ids = [doc.get('id',str(uuid.uuid4())) for doc in docs]
        texts = [doc['text'] for doc in docs]
        metadatas = [doc.get('metadata',None) for doc in docs]
        embeddings = self.embed_texts(texts)
        self.collections[collection_name].add(
            ids=ids,
            embeddings=embeddings,
            documents=texts,
            metadatas=metadatas
        )
        return docs

    def query(self,collection_name:str,query:str,k:int=10,threshold:float=None,where:Dict[str,Any]=None,where_document:Dict[str,Any]=None):
        """Query a collection for documents similar to a query

        Args:
            collection_name: Name of the collection to query
            query: Query to search for
            k: Number of results to return
            threshold: Threshold for filtering results
            where: Filter results by metadata
            where_document: Filter results by document text

        Returns:
            List of results
        """

        raw_results = self.collections[collection_name].query(
            query_texts=[query],
            n_results=k,
            where=where,
            where_document=where_document
        )
        results = [
            {'id':id,'text':text,'metadata':metadata,'distance':distance}
            for id,text,metadata,distance in zip(raw_results['ids'][0],raw_results['documents'][0],raw_results['metadatas'][0],raw_results['distances'][0])
        ]
        if threshold is not None:
            results = [result for result in results if result['distance'] <= threshold]
        return results
        # TODO add thresholding


    def get(self,collection_name:str,ids:List[str]):
        """Get a list of documents from a collection

        Args:
            collection_name: Name of the collection to get from
            ids: List of ids to get
        """
        raw_results = self.collections[collection_name].get(ids=ids)
        return [
            {'id':id,'text':text,'metadata':metadata}
            for id,text,metadata in zip(raw_results['ids'],raw_results['documents'],raw_results['metadatas'])
        ]
    
    def delete(self,collection_name:str,ids:List[str]):
        """Delete a list of documents from a collection

        Args:
            collection_name: Name of the collection to delete from
            ids: List of ids to delete
        """
        self.collections[collection_name].delete(ids=ids)
    
    def list(self,collection_name:str,k:int=None):
        """Get a list of documents from a collection

        Args:
            collection_name: Name of the collection to list
            k: Number of results to return
        """
        raw_results = self.collections[collection_name].peek(limit=k)
        return [{
            'id':id,
            'text':text,
            'metadata':metadata,
            'embedding':embedding
        } for id,text,metadata,embedding in
        zip(raw_results['ids'],raw_results['documents'],raw_results['metadatas'],raw_results['embeddings'])]

    def __deepcopy__(self,memo):
        return copy(self)
        

# %% ../nbs/025_dbs.ipynb 28
import sqlalchemy 
from sqlalchemy import create_engine
from sqlmodel import SQLModel, Session, select, Field
from typing import Optional
import sqlite3


# %% ../nbs/025_dbs.ipynb 29
def temp_sql_db(**kwargs):
    """
    creates and sqlalchemy engine to a shared memory sqlite DB.
    Kwargs are passed to to sqlalchemy's create_engine function.
    """
    creator = lambda: sqlite3.connect('file::memory:?cache=shared', uri=True)
    engine = create_engine('sqlite:///:memory:', creator=creator,**kwargs)
    return engine

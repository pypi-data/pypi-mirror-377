# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/003_object_mappings.ipynb.

# %% auto 0
__all__ = ['logger', 'lark_edge_parser', 'access_raw', 'set_access', 'parse_edge_descriptor', 'parse_accessor', 'access',
           'assert_keys_contiguous', 'object_to_args_kwargs', 'map_object', 'append_dicts', 'multi_map']

# %% ../nbs/003_object_mappings.ipynb 6
import os
import enum
from pathlib import Path
from copy import deepcopy
import itertools
import functools
from enum import Enum
from parse import parse
from typing import Any
from copy import deepcopy,copy


from collections import defaultdict,OrderedDict
from contextlib import ExitStack
from singleton_decorator import singleton

from pprint import pprint
from pydantic import BaseModel
from pydantic_core import SchemaValidator

from typing import Optional,Union,List,Dict,Any,Literal

import networkx as nx
from networkx.readwrite import json_graph
from fastcore.basics import patch
from tqdm.auto import tqdm
import logging


# %% ../nbs/003_object_mappings.ipynb 7
logger = logging.getLogger(__name__)

# %% ../nbs/003_object_mappings.ipynb 9
from .core import jinja_render,checkLogs,maybe_await,_duplicates

from textwrap import dedent
from parse import parse
import re
import itertools as it
import types
import uuid
import time
import json

# %% ../nbs/003_object_mappings.ipynb 11
def access_raw(obj,path,missing_ok=False):

    def _access_attr_or_key(sub_obj,key):
        try:
            return getattr(sub_obj,key)
        except (AttributeError,TypeError):
            try:
                return sub_obj[key]
            except (KeyError,IndexError,TypeError):
                if missing_ok:
                    return None
                else:
                    raise ValueError(f"When navigating path\n{path} on object\n{obj}:\n"
                                f"attribute '{key}' is not a valid attribute or item of subobject:\n{sub_obj}")

    def _access(sub_obj,sub_path):
        if len(sub_path) == 0:
            return sub_obj

        part = sub_path[0]
        if part == '**':
            if isinstance(sub_obj,dict):
                inner_obj = sub_obj
            else:
                inner_obj = vars(sub_obj)
            return _access(inner_obj,sub_path[1:])

        elif part == '.':
            inner_obj = sub_obj
            return _access(inner_obj,sub_path[1:])
        elif part == '[]':
            inner_obj = sub_obj
            if not hasattr(sub_obj, '__iter__'):
                raise ValueError(f"When navigating path\n{path} on object\n{obj}:\n"
                            f"subobject {sub_obj} is not iterable")
            return [_access(o,sub_path[1:]) for o in inner_obj]
        else:
            inner_obj = _access_attr_or_key(sub_obj,part)
            return _access(inner_obj,sub_path[1:])

    return _access(obj,path)


# %% ../nbs/003_object_mappings.ipynb 18
def set_access(obj, attr_path, value):
    """set an attribute or item of an object, using a path of attribute/item names.
    
    Args:
        obj: The object to set
        attr_path: A string or tuple/list of strings representing the path to the attribute/item
        value: The value to set
    """
    sub_obj = obj
    for attr in attr_path[:-1]:
        if attr not in sub_obj:
            sub_obj[attr] = {}
        sub_obj = sub_obj[attr]
    sub_obj[attr_path[-1]] = value

# %% ../nbs/003_object_mappings.ipynb 22
from lark import Lark, Transformer


_EDGE_GRAMMAR = """
    %import common.WS
    %ignore WS
    NAME: /[a-zA-Z0-9_<>]+/  
    
    accessor_key : NAME 
        | "**" -> kwargs_accessor
        | "." -> self_accessor
        | "_" -> underscore
        
    accessor_step : accessor_key
        | accessor_key "[]" -> list_accessor

    accessor: accessor_step ("." accessor_step)*

    accessor_assignment: accessor "=" accessor

    state: ("state"|"State") "/" NAME

    map_key: NAME
        | "**" -> kwargs_map_key

    single_map: map_key -> implicit_map
        | map_key "=" accessor -> keyword_map

    mapping_expr: single_map 
        | "(" single_map ("," single_map)* ")"

    edge: NAME "->" NAME ( mapping_expr )?
        | NAME "->" state ( mapping_expr )? -> write_edge
        | state "->" NAME ( mapping_expr )? -> read_edge
    

    implicit_edge: NAME ( mapping_expr )?
        | state ( mapping_expr )? -> implicit_state_edge

"""


# %% ../nbs/003_object_mappings.ipynb 23
class _EdgeTransformer(Transformer):
    def NAME(self, item):
        try:
            return int(item)
        except:
            return str(item)

    def accessor_key(self, items):
        return items[0]

    def accessor_step(self, items):
        return items[0]

    def map_key(self, items):
        return items[0]

    def kwargs_map_key(self, items):
        return '**'

    def self_accessor(self, items):
        return '.'

    def kwargs_accessor(self, items):
        return '**'

    def underscore(self, items):
        return '_'

    def list_accessor(self, items):
        return (items[0],'[]')

    def accessor(self, items):
        flat_items = []
        for item in items:
            if isinstance(item,tuple):
                flat_items.extend(item)
            else:
                flat_items.append(item)
        return tuple(flat_items)

    def accessor_assignment(self, items):
        return items[0],items[1]

    def implicit_map(self, items):
        name = items[0]
        return {name:('.',)}

    def keyword_map(self, items):
        name, accessor = items
        return {name:accessor}


    def mapping_expr(self, items):
        mapping_dict = {}
        for item in items:
            mapping_dict.update(item)
        return mapping_dict

    def state(self,items):
        return items[0] # return the key

    def _default_mapping(self,):
        return {0:('.',)}


    def edge(self,items):
        return {
                'edge_type':'edge',
                'source_node':items[0],
                'target_node':items[1],
                'mapping':items[2] if len(items) == 3 else self._default_mapping()
            }

    def read_edge(self,items):
        return {
            'edge_type':'read_edge',
            'source_node':items[0],
            'target_node':items[1],
            'mapping':items[2] if len(items) == 3 else self._default_mapping()
        }

    def write_edge(self,items):
        return {
            'edge_type':'write_edge',
            'source_node':items[0],
            'target_node':items[1],
            'mapping':items[2] if len(items) == 3 else self._default_mapping()
        }

    def implicit_edge(self,items):
        return {
            'edge_type':'implicit_edge',
            'node':items[0],
            'mapping':items[1] if len(items) == 2 else self._default_mapping()
        }
    
    def implicit_state_edge(self,items):
        return {
            'edge_type':'implicit_state_edge',
            'node':items[0],
            'mapping':items[1] if len(items) == 2 else self._default_mapping()
        }
    

# %% ../nbs/003_object_mappings.ipynb 24
from lark.visitors import VisitError

# %% ../nbs/003_object_mappings.ipynb 25
lark_edge_parser = Lark(_EDGE_GRAMMAR, parser='lalr',start=['edge','implicit_edge','mapping_expr','accessor_assignment','accessor'])

def parse_edge_descriptor(edge_str:str,start='edge', pprint=False):
 
    try:
        tree = lark_edge_parser.parse(edge_str, start=start)
        if pprint:
            print(tree.pretty())
    except Exception as e:
        raise SyntaxError(f"Edge string '{edge_str}' in not formatted correctly\n"
            f"{e}"
        ) 

    try:
        transformed = _EdgeTransformer().transform(tree)
    except Exception as e:
        raise ValueError(f"Transformation error when parsing edge '{edge_str}'. Parse tree:\n{tree.pretty()}\n"
            f"{e}"
        ) 

    return transformed    



# %% ../nbs/003_object_mappings.ipynb 32
from functools import lru_cache

# %% ../nbs/003_object_mappings.ipynb 33
@lru_cache
def parse_accessor(accessor_str:str):
    try:
        return parse_edge_descriptor(accessor_str,start='accessor')
    except Exception as e:
        raise ValueError(f"Invalid accessor string: {accessor_str}") from e


def access(obj:Any,accessor_str:str,missing_ok=False,raw=False):
    if raw:
        if not isinstance(accessor_str,tuple):
            accessor = (accessor_str,)
        else:
            accessor = accessor_str
    else:
        accessor = parse_accessor(accessor_str)
    
    return access_raw(obj,accessor,missing_ok=missing_ok)




# %% ../nbs/003_object_mappings.ipynb 37
def assert_keys_contiguous(list_of_keys):
    numbers = sorted(key for key in list_of_keys if isinstance(key,int))
    if len(numbers) > 0 and numbers[0] != 0:
        return False
    return all(numbers[i+1] - numbers[i] == 1 
                for i in range(len(numbers)-1))



# %% ../nbs/003_object_mappings.ipynb 39
def object_to_args_kwargs(input):
    arg_keys = sorted([i for i in input.keys() if isinstance(i,int)])
    args = [input[i] for i in arg_keys]
    kwargs = {k:v for k,v in input.items() if not isinstance(k,int)}
    return args,kwargs


# %% ../nbs/003_object_mappings.ipynb 42
def map_object(obj,mapping):
    """Map an object according to a mapping.
    
    Args:
        obj: The object to map
        mapping: A mapping of the form {key: accessor}
    Returns:
        A dict with the mapped values
    """
    mapped_dict = {}
    for key,access_path in mapping.items():
        if key == '_':
            continue
        elif access_path == '_' or '_' in access_path:
            raise ValueError(f"Invalid access path {access_path}, must not contain '_'")
        elif key == "**":
            mapped_dict.update(access(obj,access_path,raw=True))
        else:
            mapped_dict[key] = access(obj,access_path,raw=True)
    return mapped_dict

# %% ../nbs/003_object_mappings.ipynb 44
def append_dicts(dict_list: list[dict]) -> dict:
    """Combine multiple dictionaries with the same keys into a single dictionary where each value is a list.
    
    Args:
        dict_list: List of dictionaries with the same keys
        
    Returns:
        A dictionary where each key maps to a list of values from the input dictionaries
        
    Example:
        >>> dicts = [{'a': 1, 'b': 2}, {'a': 3, 'b': 4}]
        >>> append_dicts(dicts)
        {'a': [1, 3], 'b': [2, 4]}
    """
    if not dict_list:
        return {}
    
    result = defaultdict(list)
    for d in dict_list:
        for key, value in d.items():
            result[key].append(value)
    
    return dict(result)

# %% ../nbs/003_object_mappings.ipynb 45
def multi_map(obj_dict,mappings_dict,as_list_keys=None):
    """Map a dictionary of objects according to a dictionary of mappings.
    
    Args:
        obj_dict: A dictionary of objects to map {obj_name:obj}
        mappings_dict: A dictionary of mappings of the form {mapping_name:mapping}
    Returns:
        A dictionary that is the union of the mapped objects {obj_name:mapped_obj}
        If a key is present in multiple mappings, the value from the last mapping will be used.
        If an obj referenced in the mapping dict is not found in the obj_dict, it will be skipped.
    """
    if as_list_keys is None:
        as_list_keys = set()
    mapped_dict = {}
    for mapping_name,mapping in mappings_dict.items():
        if not mapping_name in obj_dict:
            continue
        if mapping_name in as_list_keys:
            sub_objects_list = [map_object(obj,mapping) for obj in obj_dict[mapping_name]]
            sub_obj = append_dicts(sub_objects_list)
        else:
            sub_obj = map_object(obj_dict[mapping_name],mapping)

        mapped_dict.update(sub_obj)
    return mapped_dict

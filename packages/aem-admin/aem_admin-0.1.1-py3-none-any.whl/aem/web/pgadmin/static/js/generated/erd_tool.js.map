{"version":3,"file":"erd_tool.js","mappings":";;;AAsHA","sources":["webpack:///./pgadmin/tools/erd/static/js/erd_tool/links/OneToManyLink.jsx"],"sourcesContent":["/////////////////////////////////////////////////////////////\r\n//\r\n// pgAdmin 4 - PostgreSQL Tools\r\n//\r\n// Copyright (C) 2013 - 2025, The pgAdmin Development Team\r\n// This software is released under the PostgreSQL Licence\r\n//\r\n//////////////////////////////////////////////////////////////\r\n\r\nimport React, { forwardRef, useContext } from 'react';\r\nimport {\r\n  RightAngleLinkModel,\r\n  RightAngleLinkWidget,\r\n  DefaultLinkFactory,\r\n  PortModelAlignment,\r\n  LinkWidget,\r\n  PointModel,\r\n} from '@projectstorm/react-diagrams';\r\nimport {Point} from '@projectstorm/geometry';\r\nimport _ from 'lodash';\r\nimport PropTypes from 'prop-types';\r\nimport { styled } from '@mui/material/styles';\r\nimport { ERDCanvasSettings } from '../components/ERDTool';\r\nimport { keyframes } from '@emotion/react';\r\n\r\nexport const POINTER_SIZE = 30;\r\n\r\nexport const OneToManyModel = {\r\n  local_table_uid: undefined,\r\n  local_column_attnum: undefined,\r\n  referenced_table_uid: undefined,\r\n  referenced_column_attnum: undefined,\r\n};\r\n\r\nexport class OneToManyLinkModel extends RightAngleLinkModel {\r\n  constructor({data, ...options}) {\r\n    super({\r\n      type: 'onetomany',\r\n      width: 1,\r\n      class: 'link-onetomany',\r\n      locked: true,\r\n      ...options,\r\n    });\r\n\r\n    this._data = {\r\n      ...data,\r\n    };\r\n    this._linkPointType = {\r\n      sourceType: 'one',\r\n      targetType: 'many'\r\n    };\r\n  }\r\n\r\n  getData() {\r\n    return this._data;\r\n  }\r\n\r\n  setData(data) {\r\n    this._data = data;\r\n  }\r\n\r\n  serializeData(nodesDict) {\r\n    let data = this.getData();\r\n    let target = nodesDict[data['local_table_uid']].getData();\r\n    let source = nodesDict[data['referenced_table_uid']].getData();\r\n    return {\r\n      'schema': target.schema,\r\n      'table': target.name,\r\n      'remote_schema': source.schema,\r\n      'remote_table': source.name,\r\n      'columns': [{\r\n        'local_column': _.find(target.columns, (col)=>data.local_column_attnum == col.attnum).name,\r\n        'referenced': _.find(source.columns, (col)=>data.referenced_column_attnum == col.attnum).name,\r\n      }],\r\n    };\r\n  }\r\n\r\n  serialize() {\r\n    return {\r\n      ...super.serialize(),\r\n      data: this.getData(),\r\n    };\r\n  }\r\n\r\n  setPointType(nodesDict) {\r\n    let data = this.getData();\r\n    let target = nodesDict[data['local_table_uid']].getData();\r\n    let colName = _.find(target.columns, (col)=>data.local_column_attnum == col.attnum).name;\r\n    let {pkCols=[], ukCols=[]} = nodesDict[data['local_table_uid']].getConstraintCols();\r\n    let targetType = pkCols.includes(colName) || ukCols.includes(colName) ? 'one' : 'many';\r\n    this._linkPointType = {\r\n      ...this._linkPointType,\r\n      targetType,\r\n    };\r\n  }\r\n\r\n  getPointType() {\r\n    return this._linkPointType;\r\n  }\r\n\r\n  setFirstAndLastPathsDirection() {\r\n    let points = this.getPoints();\r\n    if (points.length > 2){\r\n      super.setFirstAndLastPathsDirection();\r\n    } else {\r\n      let dx = Math.abs(points[1].getX() - points[0].getX());\r\n      let dy = Math.abs(points[1].getY() - points[0].getY());\r\n      this._firstPathXdirection = dx > dy;\r\n      this._lastPathXdirection = dx > dy;\r\n    }\r\n  }\r\n}\r\n\r\nconst svgLinkSelected =   keyframes`\r\n  from { stroke-dashoffset: 24;}\r\n  to { stroke-dashoffset: 0; }\r\n`;\r\n\r\nconst StyledG = styled('g')((\r\n  {\r\n    theme\r\n  }\r\n) => ({\r\n\r\n  '& .OneToMany-svgLink': {\r\n    stroke: theme.palette.text.primary,\r\n    fontSize: '0.8em',\r\n  },\r\n  '& .OneToMany-svgLinkCircle': {\r\n    fill: theme.palette.text.primary,\r\n  },\r\n\r\n  '& .OneToMany-svgLinkSelected': {\r\n    strokeDasharray: '10, 2',\r\n    animation: `${svgLinkSelected} 1s linear infinite`\r\n  },\r\n  '& .OneToMany-svgLinkPath': {\r\n    pointerEvents: 'all',\r\n    cursor: 'move',\r\n  }\r\n}));\r\n\r\n\r\nfunction ChenNotation({rotation, type}) {\r\n\r\n  const textX = Math.sign(rotation) > 0 ? -14 : 8;\r\n  const textY = -5;\r\n  return (\r\n    <>\r\n      <text className='OneToMany-svgLink' x={textX} y={textY} transform={'rotate(' + -rotation + ')' }>\r\n        {type == 'one' ? '1' : 'N'}\r\n      </text>\r\n      <line className='OneToMany-svgLink' x1=\"0\" y1=\"0\" x2=\"0\" y2=\"30\"></line>\r\n    </>\r\n  );\r\n}\r\nChenNotation.propTypes = {\r\n  rotation: PropTypes.number,\r\n  type: PropTypes.string,\r\n};\r\n\r\nfunction NotationForType({itype, width, rotation}) {\r\n  const settings = useContext(ERDCanvasSettings);\r\n\r\n  if(settings.cardinality_notation == 'chen') {\r\n    return <ChenNotation rotation={rotation} type={itype} />;\r\n  }\r\n  if(itype == 'many') {\r\n    return (\r\n      <>\r\n        <circle className={['OneToMany-svgLink','OneToMany-svgLinkCircle'].join(' ')} cx=\"0\" cy=\"16\" r={width*2.5} strokeWidth={width} />\r\n        <polyline className='OneToMany-svgLink' points=\"-8,0 0,15 0,0 0,30 0,15 8,0\" fill=\"none\" strokeWidth={width} />\r\n      </>\r\n    );\r\n  } else if (itype == 'one') {\r\n    return (\r\n      <polyline className='OneToMany-svgLink' points=\"-8,15 0,15 0,0 0,30 0,15 8,15\" fill=\"none\" strokeWidth={width} />\r\n    );\r\n  }\r\n}\r\n\r\nNotationForType.propTypes = {\r\n  itype: PropTypes.oneOf(['many', 'one']).isRequired,\r\n  rotation: PropTypes.number.isRequired,\r\n  width: PropTypes.number,\r\n};\r\n\r\n\r\nexport class OneToManyLinkWidget extends RightAngleLinkWidget {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {};\r\n    this.setPointType();\r\n    this.updateLinkListener = this.props.link.registerListener({\r\n      updateLink: ()=>{\r\n        this.setPointType();\r\n        this.setState({});\r\n      }\r\n    });\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    this.props.link.deregisterListener(this.updateLinkListener);\r\n  }\r\n\r\n  setPointType() {\r\n    this.props.link.setPointType(this.props.diagramEngine.getModel().getNodesDict());\r\n  }\r\n\r\n  endPointTranslation(alignment) {\r\n    let degree = 0;\r\n    let tx = 0, ty = 0;\r\n    switch(alignment) {\r\n    case PortModelAlignment.BOTTOM:\r\n      ty = -POINTER_SIZE;\r\n      break;\r\n    case PortModelAlignment.LEFT:\r\n      degree = 90;\r\n      tx = POINTER_SIZE;\r\n      break;\r\n    case PortModelAlignment.TOP:\r\n      degree = 180;\r\n      ty = POINTER_SIZE;\r\n      break;\r\n    case PortModelAlignment.RIGHT:\r\n      degree = -90;\r\n      tx = -POINTER_SIZE;\r\n      break;\r\n    }\r\n    return [degree, tx, ty];\r\n  }\r\n\r\n  addCustomWidgetPoint(type, endpoint, point) {\r\n    const [rotation, tx, ty] = this.endPointTranslation(endpoint.options.alignment);\r\n    if(!point) {\r\n      point = this.props.link.point(\r\n        endpoint.getX()-tx, endpoint.getY()-ty, {'one': 1, 'many': 2}[type]\r\n      );\r\n    } else {\r\n      point.setPosition(endpoint.getX()-tx, endpoint.getY()-ty);\r\n    }\r\n\r\n    return {\r\n      type: type,\r\n      point: point,\r\n      rotation: rotation,\r\n      tx: tx,\r\n      ty: ty,\r\n    };\r\n  }\r\n\r\n  generateCustomEndWidget({type, point, rotation, tx, ty}) {\r\n    return (\r\n      <g key={point.getID()} transform={'translate(' + point.getPosition().x + ', ' + point.getPosition().y + ')'}>\r\n        <g transform={'translate('+tx+','+ty+')'}>\r\n          <g transform={'rotate(' + rotation + ')' }>\r\n            <NotationForType itype={type} width={this.props.width} rotation={rotation} />\r\n          </g>\r\n        </g>\r\n      </g>\r\n    );\r\n  }\r\n\r\n  draggingEvent(event, index) {\r\n    let points = this.props.link.getPoints();\r\n    // get moving difference. Index + 1 will work because links indexes has\r\n    // length = points.lenght - 1\r\n    let dx = Math.abs(points[index].getX() - points[index + 1].getX());\r\n    let dy = Math.abs(points[index].getY() - points[index + 1].getY());\r\n\r\n    // moving with y direction\r\n    if (dx === 0) {\r\n      this.calculatePositions(points, event, index, 'x');\r\n    } else if (dy === 0) {\r\n      this.calculatePositions(points, event, index, 'y');\r\n    }\r\n    this.props.link.setFirstAndLastPathsDirection();\r\n  }\r\n\r\n  handleMove = function(event) {\r\n    this.props.link.getTargetPort();\r\n    this.draggingEvent(event, this.dragging_index);\r\n    this.props.link.fireEvent({}, 'positionChanged');\r\n  }.bind(this);\r\n\r\n  render() {\r\n    //ensure id is present for all points on the path\r\n    let points = this.props.link.getPoints();\r\n    let paths = [];\r\n    let {sourceType, targetType} = this.props.link.getPointType();\r\n\r\n    let onePoint = this.addCustomWidgetPoint(sourceType, this.props.link.getSourcePort(), points[0]);\r\n    let manyPoint = this.addCustomWidgetPoint(targetType, this.props.link.getTargetPort(), points[points.length-1]);\r\n\r\n    if (!this.state.canDrag && points.length > 2) {\r\n      // Those points and its position only will be moved\r\n      for (let i = 1; i < points.length; i += points.length - 2) {\r\n        if (i - 1 === 0) {\r\n          if (this.props.link.getFirstPathXdirection()) {\r\n            points[i].setPosition(points[i].getX(), points[i - 1].getY());\r\n          } else {\r\n            points[i].setPosition(points[i - 1].getX(), points[i].getY());\r\n          }\r\n        } else if (this.props.link.getLastPathXdirection()) {\r\n          points[i - 1].setPosition(points[i - 1].getX(), points[i].getY());\r\n        } else {\r\n          points[i - 1].setPosition(points[i].getX(), points[i - 1].getY());\r\n        }\r\n      }\r\n    }\r\n\r\n    // If there is existing link which has two points add one\r\n    // and the link is horizontal\r\n    if (points.length === 2 && !this.state.canDrag && onePoint.point.getX() != manyPoint.point.getX()) {\r\n      this.props.link.addPoint(\r\n        new PointModel({\r\n          link: this.props.link,\r\n          position: new Point(onePoint.point.getX(), manyPoint.point.getY()),\r\n        })\r\n      );\r\n    }\r\n\r\n    paths.push(this.generateCustomEndWidget(onePoint));\r\n\r\n    for (let j = 0; j < points.length - 1; j++) {\r\n      paths.push(\r\n        this.generateLink(\r\n          LinkWidget.generateLinePath(points[j], points[j + 1]),\r\n          {\r\n            'data-linkid': this.props.link.getID(),\r\n            'data-point': j,\r\n            onMouseDown: (event) => {\r\n              if (event.button === 0) {\r\n                this.setState({ canDrag: true });\r\n                this.dragging_index = j;\r\n                // Register mouse move event to track mouse position\r\n                // On mouse up these events are unregistered check \"this.handleUp\"\r\n                window.addEventListener('mousemove', this.handleMove);\r\n                window.addEventListener('mouseup', this.handleUp);\r\n              }\r\n            },\r\n            onMouseEnter: () => {\r\n              this.setState({ selected: true });\r\n              this.props.link.lastHoverIndexOfPath = j;\r\n            },\r\n          },\r\n          j\r\n        )\r\n      );\r\n    }\r\n    paths.push(this.generateCustomEndWidget(manyPoint));\r\n\r\n    return <StyledG data-default-link-test={this.props.link.getOptions().testName}>{paths}</StyledG>;\r\n  }\r\n}\r\n\r\nconst LinkSegment = forwardRef(({model, selected, path, ...props}, ref)=>{\r\n\r\n  return (\r\n    <path\r\n      ref={ref}\r\n      className={['OneToMany-svgLink','OneToMany-svgLinkPath', (selected ? 'OneToMany-svgLinkSelected' : '')].join(' ')}\r\n      stroke={model.getOptions().color}\r\n      strokeWidth={model.getOptions().width}\r\n      selected={selected}\r\n      d={path}\r\n      {...props}\r\n    >\r\n    </path>\r\n  );\r\n});\r\nLinkSegment.displayName = 'LinkSegment';\r\nLinkSegment.propTypes = {\r\n  model: PropTypes.object,\r\n  selected: PropTypes.bool,\r\n  path: PropTypes.any,\r\n};\r\n\r\n\r\nexport class OneToManyLinkFactory extends DefaultLinkFactory {\r\n  constructor() {\r\n    super('onetomany');\r\n  }\r\n\r\n  generateModel(event) {\r\n    return new OneToManyLinkModel(event.initialConfig);\r\n  }\r\n\r\n  generateReactWidget(event) {\r\n    return <OneToManyLinkWidget width={1} smooth={true} link={event.model} diagramEngine={this.engine} factory={this} />;\r\n  }\r\n\r\n  generateLinkSegment(model, selected, path) {\r\n    return <LinkSegment model={model} selected={selected} path={path} />;\r\n  }\r\n}\r\n"],"names":[],"sourceRoot":""}
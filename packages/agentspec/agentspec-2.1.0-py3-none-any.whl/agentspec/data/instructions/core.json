{
  "instructions": [
    {
      "id": "plan_and_reflect",
      "version": "1.0.0",
      "tags": ["core", "workflow", "planning", "reflection", "methodology"],
      "content": "Plan thoroughly before every tool call and reflect on the outcome after. Always think through what you're trying to accomplish, what tools you need, and what the expected result should be. After each action, evaluate whether it achieved the intended goal and adjust your approach if needed.",
      "metadata": {
        "category": "core",
        "priority": 10,
        "author": "AgentSpec",
        "created_at": "2024-12-15T00:00:00Z",
        "updated_at": "2024-12-15T00:00:00Z"
      }
    },
    {
      "id": "use_tools_dont_guess",
      "version": "1.0.0",
      "tags": ["core", "workflow", "verification", "accuracy", "tools"],
      "content": "Use your tools, don't guess. If you're unsure about code or files, open them - do not hallucinate. Always verify information by reading files, checking directory structures, or running commands rather than making assumptions about what exists or how things work.",
      "metadata": {
        "category": "core",
        "priority": 10,
        "author": "AgentSpec",
        "created_at": "2024-12-15T00:00:00Z",
        "updated_at": "2024-12-15T00:00:00Z"
      }
    },
    {
      "id": "persist_until_complete",
      "version": "1.0.0",
      "tags": ["core", "workflow", "persistence", "completion", "thoroughness"],
      "content": "Persist in your work. Keep going until the job is completely solved before ending your turn. Don't stop at partial solutions or leave tasks half-finished. Ensure all requirements are met, all tests pass, and the implementation is fully functional before considering the work done.",
      "metadata": {
        "category": "core",
        "priority": 10,
        "author": "AgentSpec",
        "created_at": "2024-12-15T00:00:00Z",
        "updated_at": "2024-12-15T00:00:00Z"
      }
    },
    {
      "id": "ai_code_generation_rules",
      "version": "1.0.0",
      "tags": [
        "core",
        "ai-coding",
        "code-generation",
        "technical-rules",
        "error-prevention",
        "quality"
      ],
      "content": "Follow critical code generation rules to prevent common AI coding errors: 1) Never use problematic decorators or parameters that break systems (e.g., avoid @mcp.prompt() decorators, prompt parameters in FastMCP()). 2) Avoid complex type hints from typing module (no Optional, Union, List[str], etc.) - use simple types. 3) Use proper default values: prefer empty strings (param: str = '') over None values. 4) Always return strings from functions/tools for consistency. 5) Use single-line docstrings only - multi-line docstrings can cause gateway panic errors. 6) Check for empty strings with .strip() method, not truthiness. 7) Always include proper error handling in every function. 8) Use structured output formatting with clear success/error indicators (✅/❌ emojis).",
      "metadata": {
        "category": "core",
        "priority": 10,
        "author": "AgentSpec Enhanced",
        "created_at": "2024-12-15T00:00:00Z",
        "updated_at": "2024-12-15T00:00:00Z"
      }
    },
    {
      "id": "ai_error_handling_patterns",
      "version": "1.0.0",
      "tags": [
        "core",
        "ai-coding",
        "error-handling",
        "logging",
        "recovery",
        "reliability"
      ],
      "content": "Implement systematic error handling patterns: 1) Always log to stderr using proper logging configuration with structured format. 2) Use try-catch blocks for all external operations (API calls, file operations, system commands). 3) Provide user-friendly error messages with specific error types (❌ API Error, ❌ File Error, ❌ Validation Error). 4) Implement timeout handling for long-running operations. 5) Use graceful degradation - return meaningful error messages instead of crashing. 6) Log errors with sufficient context for debugging. 7) Implement retry logic for transient failures. 8) Validate inputs before processing and return clear validation errors. 9) Never expose internal system details in error messages to users.",
      "metadata": {
        "category": "core",
        "priority": 10,
        "author": "AgentSpec Enhanced",
        "created_at": "2024-12-15T00:00:00Z",
        "updated_at": "2024-12-15T00:00:00Z"
      }
    },
    {
      "id": "human_in_the_loop_architect",
      "version": "1.0.0",
      "tags": [
        "core",
        "ai-collaboration",
        "collaboration",
        "architecture",
        "decision-making",
        "human-ai"
      ],
      "content": "Maintain the developer as architect, not just operator. Use AI as a sophisticated tool for comparison and refinement, but retain control of decision-making process. Apply creative problem-solving skills to unique project requirements. Treat AI as a 'peer programmer' whose work must always be subject to review and verification.",
      "metadata": {
        "category": "core",
        "priority": 10,
        "author": "Research Integration",
        "created_at": "2024-01-01T00:00:00Z",
        "updated_at": "2024-01-01T00:00:00Z"
      }
    },
    {
      "id": "ai_code_understanding_requirement",
      "version": "1.0.0",
      "tags": [
        "core",
        "ai-collaboration",
        "responsibility",
        "code-review",
        "understanding",
        "quality"
      ],
      "content": "Never commit AI-generated code you don't fully understand. Ultimate responsibility remains with the developer. Always review, test, and validate AI-generated code before integration. Maintain zero-tolerance for unvalidated code. If you don't understand what the code does, how it works, or why it's structured that way, take time to analyze and understand it before proceeding. This is especially critical with AI assistance where code generation can be rapid but understanding may lag behind.",
      "metadata": {
        "category": "core",
        "priority": 10,
        "author": "AgentSpec Enhanced",
        "created_at": "2024-12-15T00:00:00Z",
        "updated_at": "2024-12-15T00:00:00Z"
      }
    },
    {
      "id": "prompt_engineering_discipline",
      "version": "1.0.0",
      "tags": [
        "core",
        "prompt-engineering",
        "clarity",
        "context",
        "constraints"
      ],
      "content": "Use disciplined prompt engineering with the 3C Framework: Clarity (specific, unambiguous instructions), Context (relevant background and requirements), and Constraints (limitations, standards, and boundaries). Request step-by-step thinking before implementation. Use chain-of-thought prompting with 'Think through this step by step' and 'Explain your reasoning before coding'. Assign specific expert personas when needed (senior architect, security specialist, performance engineer). Break complex tasks into manageable, well-defined subtasks.",
      "metadata": {
        "category": "core",
        "priority": 9,
        "author": "AgentSpec Enhanced",
        "created_at": "2024-12-15T00:00:00Z",
        "updated_at": "2024-12-15T00:00:00Z"
      }
    },
    {
      "id": "context_management",
      "version": "1.2.0",
      "tags": [
        "core",
        "workflow",
        "persistence",
        "resume",
        "tracking",
        "documentation",
        "session-management",
        "context-preservation"
      ],
      "content": "Maintain comprehensive project context through multiple mechanisms: 1) Maintain `project_context.md` that records failed commands and alternatives, temporary files and purposes, lessons learned to avoid repeating mistakes. 2) Use a dedicated 'rich scratchpad' document parallel to development for crafting complex prompts, recording follow-up questions, logging issues and solutions, and storing essential project context (goals, architecture, environment details). Use this to quickly re-prime AI sessions and prevent context drift. 3) Implement systematic context preservation across AI sessions by documenting project goals, architectural decisions, coding standards, and current state. Use structured templates to quickly restore context when starting new AI interactions. Load these files at development start and resume from where work left off to prevent context drift and maintain continuity across development sessions.",
      "metadata": {
        "category": "core",
        "priority": 9,
        "author": "AgentSpec Consolidated",
        "created_at": "2024-01-01T00:00:00Z",
        "updated_at": "2024-12-15T00:00:00Z"
      }
    },
    {
      "id": "incremental_development",
      "version": "1.2.0",
      "tags": [
        "core",
        "workflow",
        "development",
        "incremental",
        "validation",
        "complexity",
        "decomposition",
        "end-to-end",
        "vertical-slice",
        "proof-of-concept"
      ],
      "content": "Break complex tasks into smaller, isolated chunks and implement features incrementally with frequent validation. Build features end-to-end slice by slice in a proof-of-concept manner rather than implementing components horizontally and wiring them together at the end. Each slice should deliver complete functionality from frontend to backend, ensuring a working end-to-end application is always available for users to explore and see development progress. Setup each component of the application with minimal functionality as the first thin slice at the beginning. Establish a basic working skeleton across all layers (frontend, backend, database, etc.) before adding features. Then add features one by one across all components end-to-end, ensuring that at any stage, a basic working application is available for users to interact with and validate progress. Make small, focused changes that can be easily reviewed and rolled back. Avoid overly complex implementations that lead to confused or buggy output. If struggling with complexity, stop and reframe into simpler, more focused requests. Always validate each step before proceeding to the next.",
      "metadata": {
        "category": "core",
        "priority": 10,
        "author": "AgentSpec Consolidated",
        "created_at": "2024-01-01T00:00:00Z",
        "updated_at": "2024-12-15T00:00:00Z"
      }
    },
    {
      "id": "continuous_validation_loop",
      "version": "1.0.0",
      "tags": ["core", "workflow", "validation", "testing", "quality"],
      "content": "Implement continuous validation as core workflow: Prompt → Generate → Validate → Refine. Use multi-faceted validation: automated testing, manual state inspection, direct application interaction. Leverage AI to generate tailored validation plans and test checklists. Never skip validation to maintain quality at speed.",
      "metadata": {
        "category": "core",
        "priority": 10,
        "author": "Research Integration",
        "created_at": "2024-01-01T00:00:00Z",
        "updated_at": "2024-12-15T00:00:00Z"
      }
    },
    {
      "id": "avoid_vibe_coding",
      "version": "1.0.0",
      "tags": ["core", "workflow", "discipline", "quality", "validation"],
      "content": "Avoid 'vibe coding' (high-level descriptions with minimal scrutiny) for enterprise systems. Use disciplined AI-assisted coding: iterative process with well-defined steps, continuous validation, and refinement. Never commit code you don't fully understand. Focus on higher-order tasks: business context, architectural trade-offs, correctness verification.",
      "metadata": {
        "category": "core",
        "priority": 10,
        "author": "Research Integration",
        "created_at": "2024-01-01T00:00:00Z",
        "updated_at": "2024-12-15T00:00:00Z"
      }
    },
    {
      "id": "quality_standards",
      "version": "1.1.0",
      "tags": [
        "core",
        "code-quality",
        "standards",
        "linting",
        "compilation",
        "validation",
        "testing",
        "deployment"
      ],
      "content": "Maintain zero tolerance for linting errors, compilation failures, build errors, and deployment issues across the entire repository. Treat all warnings as errors and implement automated quality checks in development workflow. All code must pass quality gates before integration. After every task, ensure zero errors remain and never skip tests or bypass quality guardrails. Resolve all lint warnings and basic quality issues before marking any task complete.",
      "metadata": {
        "category": "core",
        "priority": 10,
        "author": "AgentSpec Consolidated",
        "created_at": "2024-01-01T00:00:00Z",
        "updated_at": "2024-12-15T00:00:00Z"
      }
    },
    {
      "id": "secure_coding_practices",
      "version": "1.0.0",
      "tags": ["core", "security", "coding", "vulnerabilities", "owasp"],
      "content": "Follow OWASP secure coding practices. Validate all inputs, sanitize outputs, use parameterized queries, implement proper authentication and authorization. Never trust user input or external data sources.",
      "metadata": {
        "category": "core",
        "priority": 10,
        "author": "AgentSpec",
        "created_at": "2024-01-01T00:00:00Z",
        "updated_at": "2024-01-01T00:00:00Z"
      }
    },
    {
      "id": "secrets_management",
      "version": "1.1.0",
      "tags": ["core", "security", "secrets", "credentials", "encryption"],
      "content": "Use dedicated secret management systems (HashiCorp Vault, AWS Secrets Manager, Azure Key Vault). Rotate secrets regularly and automate secret rotation, distribution, and management in CI/CD pipelines. Never hardcode credentials or API keys. Use environment variables or secure vaults for sensitive data. Use secure secret injection and avoid storing secrets in configuration files or environment variables.",
      "metadata": {
        "category": "core",
        "priority": 10,
        "author": "AgentSpec",
        "created_at": "2024-01-01T00:00:00Z",
        "updated_at": "2024-01-01T00:00:00Z"
      }
    },
    {
      "id": "autonomous_decision_making",
      "version": "1.0.0",
      "tags": [
        "core",
        "development-workflow",
        "autonomy",
        "decision-making",
        "reasoning",
        "process"
      ],
      "content": "Make informed decisions based on available context and best practices. Document reasoning for significant decisions. When uncertain, prefer safer, more conservative approaches and seek clarification when needed.",
      "metadata": {
        "category": "core",
        "priority": 9,
        "author": "AgentSpec",
        "created_at": "2024-01-01T00:00:00Z",
        "updated_at": "2024-01-01T00:00:00Z"
      }
    },
    {
      "id": "learning_adaptation",
      "version": "1.0.0",
      "tags": [
        "core",
        "development-workflow",
        "learning",
        "adaptation",
        "improvement",
        "process"
      ],
      "content": "Learn from project patterns, user feedback, and encountered issues. Adapt approaches based on project-specific requirements and constraints. Continuously improve development practices.",
      "metadata": {
        "category": "core",
        "priority": 6,
        "author": "AgentSpec",
        "created_at": "2024-01-01T00:00:00Z",
        "updated_at": "2024-01-01T00:00:00Z"
      }
    },
    {
      "id": "documentation_tracking",
      "version": "1.0.0",
      "tags": ["core", "documentation", "design", "tracking", "maintenance"],
      "content": "Log every change that deviates from design, update design docs, record temporary files in context. Keep documentation synchronized with implementation.",
      "metadata": {
        "category": "core",
        "priority": 6,
        "author": "AgentSpec",
        "created_at": "2024-01-01T00:00:00Z",
        "updated_at": "2024-01-01T00:00:00Z"
      }
    },
    {
      "id": "project_initialization",
      "version": "1.0.0",
      "tags": [
        "core",
        "project-setup",
        "initialization",
        "scaffolding",
        "structure"
      ],
      "content": "Initialize project with proper directory structure, package.json/pyproject.toml, README.md, and .gitignore. Set up development environment with consistent tooling and configuration.",
      "metadata": {
        "category": "core",
        "priority": 10,
        "author": "AgentSpec",
        "created_at": "2024-01-01T00:00:00Z",
        "updated_at": "2024-01-01T00:00:00Z"
      }
    },
    {
      "id": "dependency_management",
      "version": "1.0.0",
      "tags": [
        "core",
        "project-setup",
        "dependencies",
        "package-management",
        "security"
      ],
      "content": "Use lock files (package-lock.json, poetry.lock, Pipfile.lock) for reproducible builds. Regularly audit dependencies for security vulnerabilities. Pin major versions and use semantic versioning ranges appropriately.",
      "metadata": {
        "category": "core",
        "priority": 9,
        "author": "AgentSpec",
        "created_at": "2024-01-01T00:00:00Z",
        "updated_at": "2024-01-01T00:00:00Z"
      }
    },
    {
      "id": "environment_configuration",
      "version": "1.0.0",
      "tags": [
        "core",
        "project-setup",
        "environment",
        "configuration",
        "deployment"
      ],
      "content": "Use environment variables for configuration. Create .env.example with all required variables. Implement configuration validation and provide clear error messages for missing or invalid config.",
      "metadata": {
        "category": "core",
        "priority": 8,
        "author": "AgentSpec",
        "created_at": "2024-01-01T00:00:00Z",
        "updated_at": "2024-01-01T00:00:00Z"
      }
    },
    {
      "id": "code_formatting",
      "version": "1.0.0",
      "tags": [
        "core",
        "project-setup",
        "formatting",
        "standards",
        "automation"
      ],
      "content": "Set up automated code formatting with Prettier, Black, or similar tools. Configure pre-commit hooks to enforce formatting. Use consistent indentation, line endings, and file encoding across the project.",
      "metadata": {
        "category": "core",
        "priority": 7,
        "author": "AgentSpec",
        "created_at": "2024-01-01T00:00:00Z",
        "updated_at": "2024-01-01T00:00:00Z"
      }
    },
    {
      "id": "editor_configuration",
      "version": "1.0.0",
      "tags": ["core", "project-setup", "editor", "ide", "consistency"],
      "content": "Create .editorconfig file for consistent editor settings. Provide VS Code/IDE configuration files with recommended extensions and settings. Document development environment setup in README.",
      "metadata": {
        "category": "core",
        "priority": 6,
        "author": "AgentSpec",
        "created_at": "2024-01-01T00:00:00Z",
        "updated_at": "2024-01-01T00:00:00Z"
      }
    },
    {
      "id": "interactive_debugging_sessions",
      "version": "1.0.0",
      "tags": [
        "core",
        "debugging",
        "interactive",
        "troubleshooting",
        "collaboration"
      ],
      "content": "Conduct effective debugging sessions by providing comprehensive context: relevant code, error messages, observed behavior, and steps to reproduce. Use structured problem description to accelerate diagnosis and resolution.",
      "metadata": {
        "category": "core",
        "priority": 6,
        "author": "Research Integration",
        "created_at": "2024-01-01T00:00:00Z",
        "updated_at": "2024-01-01T00:00:00Z"
      }
    }
  ]
}

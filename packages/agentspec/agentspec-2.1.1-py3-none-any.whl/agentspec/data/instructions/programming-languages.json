{
  "instructions": [
    {
      "id": "typescript_safety",
      "version": "1.0.0",
      "tags": ["typescript", "javascript", "type-safety", "quality"],
      "content": "Never use 'any' types. Use proper type definitions, interfaces, and generics. Enable strict mode and resolve all type errors.",
      "metadata": {
        "category": "programming-languages",
        "priority": 9,
        "author": "AgentSpec",
        "created_at": "2024-01-01T00:00:00Z",
        "updated_at": "2024-01-01T00:00:00Z"
      }
    },
    {
      "id": "python_type_hints",
      "version": "1.0.0",
      "tags": ["python", "type-safety", "quality", "documentation"],
      "content": "Use comprehensive type hints for all functions, parameters, return values, and class attributes. Import typing modules for complex types.",
      "metadata": {
        "category": "programming-languages",
        "priority": 8,
        "author": "AgentSpec",
        "created_at": "2024-01-01T00:00:00Z",
        "updated_at": "2024-01-01T00:00:00Z"
      }
    },
    {
      "id": "code_documentation",
      "version": "1.0.0",
      "tags": ["documentation", "comments", "maintainability", "clarity"],
      "content": "Write clear, concise code documentation with docstrings, inline comments for complex logic, and README files. Keep documentation up-to-date with code changes.",
      "metadata": {
        "category": "programming-languages",
        "priority": 7,
        "author": "AgentSpec",
        "created_at": "2024-01-01T00:00:00Z",
        "updated_at": "2024-01-01T00:00:00Z"
      }
    },
    {
      "id": "functional_programming",
      "version": "1.0.0",
      "tags": ["functional", "immutability", "pure-functions", "composition"],
      "content": "Apply functional programming principles with pure functions, immutability, and function composition. Avoid side effects and use functional patterns where appropriate.",
      "metadata": {
        "category": "programming-languages",
        "priority": 6,
        "author": "AgentSpec",
        "created_at": "2024-01-01T00:00:00Z",
        "updated_at": "2024-01-01T00:00:00Z"
      }
    },
    {
      "id": "memory_management",
      "version": "1.0.0",
      "tags": ["memory", "performance", "optimization", "garbage-collection"],
      "content": "Implement efficient memory management with proper object lifecycle, garbage collection optimization, and memory leak prevention. Profile memory usage and optimize allocation patterns.",
      "metadata": {
        "category": "programming-languages",
        "priority": 7,
        "author": "AgentSpec",
        "created_at": "2024-01-01T00:00:00Z",
        "updated_at": "2024-01-01T00:00:00Z"
      }
    },
    {
      "id": "concurrency_patterns",
      "version": "1.0.0",
      "tags": ["concurrency", "threading", "async", "parallelism"],
      "content": "Implement safe concurrency patterns with proper synchronization, thread safety, and async/await patterns. Avoid race conditions and deadlocks through careful design.",
      "metadata": {
        "category": "programming-languages",
        "priority": 8,
        "author": "AgentSpec",
        "created_at": "2024-01-01T00:00:00Z",
        "updated_at": "2024-01-01T00:00:00Z"
      }
    },
    {
      "id": "design_patterns",
      "version": "1.0.0",
      "tags": ["design-patterns", "architecture", "maintainability", "reusability"],
      "content": "Apply appropriate design patterns (Singleton, Factory, Observer, Strategy) to solve common problems. Use patterns judiciously and avoid over-engineering solutions.",
      "metadata": {
        "category": "programming-languages",
        "priority": 6,
        "author": "AgentSpec",
        "created_at": "2024-01-01T00:00:00Z",
        "updated_at": "2024-01-01T00:00:00Z"
      }
    },
    {
      "id": "code_refactoring",
      "version": "1.2.0",
      "tags": ["refactoring", "maintainability", "clean-code", "technical-debt", "performance", "code-smells"],
      "content": "Regularly refactor code to improve readability, maintainability, and performance. Remove code smells, eliminate duplication, and improve naming and structure. Analyze codebases for performance-impacting code smells: duplicated logic, overly complex functions, inefficient algorithms. Implement systematic refactoring to improve code structure, readability, and performance without changing external behavior. Focus on both structural improvements and performance optimization through better algorithms and data structures.",
      "metadata": {
        "category": "programming-languages",
        "priority": 7,
        "author": "AgentSpec",
        "created_at": "2024-01-01T00:00:00Z",
        "updated_at": "2024-01-01T00:00:00Z"
      }
    },
    {
      "id": "dependency_injection",
      "version": "1.0.0",
      "tags": ["dependency-injection", "testing", "modularity", "coupling"],
      "content": "Implement dependency injection for loose coupling and testability. Use IoC containers where appropriate and follow SOLID principles for better architecture.",
      "metadata": {
        "category": "programming-languages",
        "priority": 7,
        "author": "AgentSpec",
        "created_at": "2024-01-01T00:00:00Z",
        "updated_at": "2024-01-01T00:00:00Z"
      }
    }
  ]
}

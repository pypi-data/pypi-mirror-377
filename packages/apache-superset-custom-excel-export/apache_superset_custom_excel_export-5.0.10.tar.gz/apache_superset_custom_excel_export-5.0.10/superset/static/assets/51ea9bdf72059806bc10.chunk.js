"use strict";(globalThis.webpackChunksuperset=globalThis.webpackChunksuperset||[]).push([[1743],{11743:(t,e,o)=>{o.r(e),o.d(e,{default:()=>w,getLayer:()=>S,getPoints:()=>P});var n=o(2445),a=o(75077),i=o(82101),r=o(23197),s=o(16704),l=o(66341);const c="uniform arcUniforms {\n  bool greatCircle;\n  bool useShortestPath;\n  float numSegments;\n  float widthScale;\n  float widthMinPixels;\n  float widthMaxPixels;\n  highp int widthUnits;\n} arc;\n",u={name:"arc",vs:c,fs:c,uniformTypes:{greatCircle:"f32",useShortestPath:"f32",numSegments:"f32",widthScale:"f32",widthMinPixels:"f32",widthMaxPixels:"f32",widthUnits:"i32"}},d=[0,0,0,255],g={getSourcePosition:{type:"accessor",value:t=>t.sourcePosition},getTargetPosition:{type:"accessor",value:t=>t.targetPosition},getSourceColor:{type:"accessor",value:d},getTargetColor:{type:"accessor",value:d},getWidth:{type:"accessor",value:1},getHeight:{type:"accessor",value:1},getTilt:{type:"accessor",value:0},greatCircle:!1,numSegments:{type:"number",value:50,min:1},widthUnits:"pixels",widthScale:{type:"number",value:1,min:0},widthMinPixels:{type:"number",value:0,min:0},widthMaxPixels:{type:"number",value:Number.MAX_SAFE_INTEGER,min:0}};class p extends a.A{getBounds(){return this.getAttributeManager()?.getBounds(["instanceSourcePositions","instanceTargetPositions"])}getShaders(){return super.getShaders({vs:"#version 300 es\n#define SHADER_NAME arc-layer-vertex-shader\nin vec4 instanceSourceColors;\nin vec4 instanceTargetColors;\nin vec3 instanceSourcePositions;\nin vec3 instanceSourcePositions64Low;\nin vec3 instanceTargetPositions;\nin vec3 instanceTargetPositions64Low;\nin vec3 instancePickingColors;\nin float instanceWidths;\nin float instanceHeights;\nin float instanceTilts;\nout vec4 vColor;\nout vec2 uv;\nout float isValid;\nfloat paraboloid(float distance, float sourceZ, float targetZ, float ratio) {\nfloat deltaZ = targetZ - sourceZ;\nfloat dh = distance * instanceHeights;\nif (dh == 0.0) {\nreturn sourceZ + deltaZ * ratio;\n}\nfloat unitZ = deltaZ / dh;\nfloat p2 = unitZ * unitZ + 1.0;\nfloat dir = step(deltaZ, 0.0);\nfloat z0 = mix(sourceZ, targetZ, dir);\nfloat r = mix(ratio, 1.0 - ratio, dir);\nreturn sqrt(r * (p2 - r)) * dh + z0;\n}\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {\nvec2 dir_screenspace = normalize(line_clipspace * project.viewportSize);\ndir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\nreturn dir_screenspace * offset_direction * width / 2.0;\n}\nfloat getSegmentRatio(float index) {\nreturn smoothstep(0.0, 1.0, index / (arc.numSegments - 1.0));\n}\nvec3 interpolateFlat(vec3 source, vec3 target, float segmentRatio) {\nfloat distance = length(source.xy - target.xy);\nfloat z = paraboloid(distance, source.z, target.z, segmentRatio);\nfloat tiltAngle = radians(instanceTilts);\nvec2 tiltDirection = normalize(target.xy - source.xy);\nvec2 tilt = vec2(-tiltDirection.y, tiltDirection.x) * z * sin(tiltAngle);\nreturn vec3(\nmix(source.xy, target.xy, segmentRatio) + tilt,\nz * cos(tiltAngle)\n);\n}\nfloat getAngularDist (vec2 source, vec2 target) {\nvec2 sourceRadians = radians(source);\nvec2 targetRadians = radians(target);\nvec2 sin_half_delta = sin((sourceRadians - targetRadians) / 2.0);\nvec2 shd_sq = sin_half_delta * sin_half_delta;\nfloat a = shd_sq.y + cos(sourceRadians.y) * cos(targetRadians.y) * shd_sq.x;\nreturn 2.0 * asin(sqrt(a));\n}\nvec3 interpolateGreatCircle(vec3 source, vec3 target, vec3 source3D, vec3 target3D, float angularDist, float t) {\nvec2 lngLat;\nif(abs(angularDist - PI) < 0.001) {\nlngLat = (1.0 - t) * source.xy + t * target.xy;\n} else {\nfloat a = sin((1.0 - t) * angularDist);\nfloat b = sin(t * angularDist);\nvec3 p = source3D.yxz * a + target3D.yxz * b;\nlngLat = degrees(vec2(atan(p.y, -p.x), atan(p.z, length(p.xy))));\n}\nfloat z = paraboloid(angularDist * EARTH_RADIUS, source.z, target.z, t);\nreturn vec3(lngLat, z);\n}\nvoid main(void) {\ngeometry.worldPosition = instanceSourcePositions;\ngeometry.worldPositionAlt = instanceTargetPositions;\nfloat segmentIndex = float(gl_VertexID / 2);\nfloat segmentSide = mod(float(gl_VertexID), 2.) == 0. ? -1. : 1.;\nfloat segmentRatio = getSegmentRatio(segmentIndex);\nfloat prevSegmentRatio = getSegmentRatio(max(0.0, segmentIndex - 1.0));\nfloat nextSegmentRatio = getSegmentRatio(min(arc.numSegments - 1.0, segmentIndex + 1.0));\nfloat indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\nisValid = 1.0;\nuv = vec2(segmentRatio, segmentSide);\ngeometry.uv = uv;\ngeometry.pickingColor = instancePickingColors;\nvec4 curr;\nvec4 next;\nvec3 source;\nvec3 target;\nif ((arc.greatCircle || project.projectionMode == PROJECTION_MODE_GLOBE) && project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\nsource = project_globe_(vec3(instanceSourcePositions.xy, 0.0));\ntarget = project_globe_(vec3(instanceTargetPositions.xy, 0.0));\nfloat angularDist = getAngularDist(instanceSourcePositions.xy, instanceTargetPositions.xy);\nvec3 prevPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, prevSegmentRatio);\nvec3 currPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, segmentRatio);\nvec3 nextPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, nextSegmentRatio);\nif (abs(currPos.x - prevPos.x) > 180.0) {\nindexDir = -1.0;\nisValid = 0.0;\n} else if (abs(currPos.x - nextPos.x) > 180.0) {\nindexDir = 1.0;\nisValid = 0.0;\n}\nnextPos = indexDir < 0.0 ? prevPos : nextPos;\nnextSegmentRatio = indexDir < 0.0 ? prevSegmentRatio : nextSegmentRatio;\nif (isValid == 0.0) {\nnextPos.x += nextPos.x > 0.0 ? -360.0 : 360.0;\nfloat t = ((currPos.x > 0.0 ? 180.0 : -180.0) - currPos.x) / (nextPos.x - currPos.x);\ncurrPos = mix(currPos, nextPos, t);\nsegmentRatio = mix(segmentRatio, nextSegmentRatio, t);\n}\nvec3 currPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, segmentRatio);\nvec3 nextPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, nextSegmentRatio);\ncurr = project_position_to_clipspace(currPos, currPos64Low, vec3(0.0), geometry.position);\nnext = project_position_to_clipspace(nextPos, nextPos64Low, vec3(0.0));\n} else {\nvec3 source_world = instanceSourcePositions;\nvec3 target_world = instanceTargetPositions;\nif (arc.useShortestPath) {\nsource_world.x = mod(source_world.x + 180., 360.0) - 180.;\ntarget_world.x = mod(target_world.x + 180., 360.0) - 180.;\nfloat deltaLng = target_world.x - source_world.x;\nif (deltaLng > 180.) target_world.x -= 360.;\nif (deltaLng < -180.) source_world.x -= 360.;\n}\nsource = project_position(source_world, instanceSourcePositions64Low);\ntarget = project_position(target_world, instanceTargetPositions64Low);\nfloat antiMeridianX = 0.0;\nif (arc.useShortestPath) {\nif (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {\nantiMeridianX = -(project.coordinateOrigin.x + 180.) / 360. * TILE_SIZE;\n}\nfloat thresholdRatio = (antiMeridianX - source.x) / (target.x - source.x);\nif (prevSegmentRatio <= thresholdRatio && nextSegmentRatio > thresholdRatio) {\nisValid = 0.0;\nindexDir = sign(segmentRatio - thresholdRatio);\nsegmentRatio = thresholdRatio;\n}\n}\nnextSegmentRatio = indexDir < 0.0 ? prevSegmentRatio : nextSegmentRatio;\nvec3 currPos = interpolateFlat(source, target, segmentRatio);\nvec3 nextPos = interpolateFlat(source, target, nextSegmentRatio);\nif (arc.useShortestPath) {\nif (nextPos.x < antiMeridianX) {\ncurrPos.x += TILE_SIZE;\nnextPos.x += TILE_SIZE;\n}\n}\ncurr = project_common_position_to_clipspace(vec4(currPos, 1.0));\nnext = project_common_position_to_clipspace(vec4(nextPos, 1.0));\ngeometry.position = vec4(currPos, 1.0);\n}\nfloat widthPixels = clamp(\nproject_size_to_pixel(instanceWidths * arc.widthScale, arc.widthUnits),\narc.widthMinPixels, arc.widthMaxPixels\n);\nvec3 offset = vec3(\ngetExtrusionOffset((next.xy - curr.xy) * indexDir, segmentSide, widthPixels),\n0.0);\nDECKGL_FILTER_SIZE(offset, geometry);\nDECKGL_FILTER_GL_POSITION(curr, geometry);\ngl_Position = curr + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);\nvec4 color = mix(instanceSourceColors, instanceTargetColors, segmentRatio);\nvColor = vec4(color.rgb, color.a * layer.opacity);\nDECKGL_FILTER_COLOR(vColor, geometry);\n}\n",fs:"#version 300 es\n#define SHADER_NAME arc-layer-fragment-shader\nprecision highp float;\nin vec4 vColor;\nin vec2 uv;\nin float isValid;\nout vec4 fragColor;\nvoid main(void) {\nif (isValid == 0.0) {\ndiscard;\n}\nfragColor = vColor;\ngeometry.uv = uv;\nDECKGL_FILTER_COLOR(fragColor, geometry);\n}\n",modules:[i.A,r.A,u]})}get wrapLongitude(){return!1}initializeState(){this.getAttributeManager().addInstanced({instanceSourcePositions:{size:3,type:"float64",fp64:this.use64bitPositions(),transition:!0,accessor:"getSourcePosition"},instanceTargetPositions:{size:3,type:"float64",fp64:this.use64bitPositions(),transition:!0,accessor:"getTargetPosition"},instanceSourceColors:{size:this.props.colorFormat.length,type:"unorm8",transition:!0,accessor:"getSourceColor",defaultValue:d},instanceTargetColors:{size:this.props.colorFormat.length,type:"unorm8",transition:!0,accessor:"getTargetColor",defaultValue:d},instanceWidths:{size:1,transition:!0,accessor:"getWidth",defaultValue:1},instanceHeights:{size:1,transition:!0,accessor:"getHeight",defaultValue:1},instanceTilts:{size:1,transition:!0,accessor:"getTilt",defaultValue:0}})}updateState(t){super.updateState(t),t.changeFlags.extensionsChanged&&(this.state.model?.destroy(),this.state.model=this._getModel(),this.getAttributeManager().invalidateAll())}draw({uniforms:t}){const{widthUnits:e,widthScale:o,widthMinPixels:n,widthMaxPixels:a,greatCircle:i,wrapLongitude:r,numSegments:l}=this.props,c={numSegments:l,widthUnits:s.p5[e],widthScale:o,widthMinPixels:n,widthMaxPixels:a,greatCircle:i,useShortestPath:r},u=this.state.model;u.shaderInputs.setProps({arc:c}),u.setVertexCount(2*l),u.draw(this.context.renderPass)}_getModel(){return new l.K(this.context.device,{...this.getShaders(),id:this.props.id,bufferLayout:this.getAttributeManager().getBufferLayouts(),topology:"triangle-strip",isInstanced:!0})}}p.layerName="ArcLayer",p.defaultProps=g;const f=p;var m=o(95579),h=o(19375),x=o(68291),v=o(47823),_=o(32548);function P(t){const e=[];return t.forEach((t=>{e.push(t.sourcePosition),e.push(t.targetPosition)})),e}function y(t){return e=>{var o,a,i,r,s;return(0,n.FD)("div",{className:"deckgl-tooltip",children:[(0,n.Y)(_.A,{label:(0,m.t)("Start (Longitude, Latitude): "),value:`${null==(o=e.object)||null==(o=o.sourcePosition)?void 0:o[0]}, ${null==(a=e.object)||null==(a=a.sourcePosition)?void 0:a[1]}`}),(0,n.Y)(_.A,{label:(0,m.t)("End (Longitude, Latitude): "),value:`${null==(i=e.object)||null==(i=i.targetPosition)?void 0:i[0]}, ${null==(r=e.object)||null==(r=r.targetPosition)?void 0:r[1]}`}),t.dimension&&(0,n.Y)(_.A,{label:`${null==t?void 0:t.dimension}: `,value:`${null==(s=e.object)?void 0:s.cat_color}`})]})}}const S=function({formData:t,payload:e,setTooltip:o,filterState:n,setDataMask:a,onContextMenu:i,emitCrossFilters:r}){const s=t,l=e.data.features,c=s.color_picker,u=s.target_color_picker,d=s.color_scheme_type;return new f({data:l,getSourceColor:t=>d===h.wP.fixed_color?[c.r,c.g,c.b,255*c.a]:t.targetColor||t.color,getTargetColor:t=>d===h.wP.fixed_color?[u.r,u.g,u.b,255*u.a]:t.targetColor||t.color,id:`path-layer-${s.slice_id}`,getWidth:s.stroke_width?s.stroke_width:3,...(0,x.T$)({formData:s,setTooltip:o,setTooltipContent:y(s),onContextMenu:i,setDataMask:a,filterState:n,emitCrossFilters:r})})},w=(0,v.c)(S,P)},47823:(t,e,o)=>{o.d(e,{c:()=>S,y:()=>y});var n=o(2404),a=o.n(n),i=o(2445),r=o(96540),s=o(83505),l=o(70957),c=o(94963),u=o(66671),d=o(49443),g=o(25564),p=o(95490),f=o(19375),m=o(49672),h=o(55602);const{getScale:x}=c;function v(t,e){const o=t.color_picker||{r:0,g:0,b:0,a:1},n=[o.r,o.g,o.b,255*o.a],a=t.color_scheme,i=x(a);let r={};return t.color_scheme_type===f.wP.color_breakpoints?r=(0,m.BK)(t.color_breakpoints):e.forEach((e=>{if(null!=e.cat_color&&!r.hasOwnProperty(e.cat_color)){let a;a=t.dimension?(0,d.hexToRGB)(i(e.cat_color,t.sliceId),255*o.a):n,r[e.cat_color]={color:a,enabled:!0}}})),r}const _=t=>{const e=(0,r.useRef)(null),o=(0,r.useCallback)((()=>{let e={...t.viewport};return t.formData.autozoom&&(e=(0,p.A)(e,{width:t.width,height:t.height,points:t.getPoints(t.payload.data.features||[])})),e.zoom<0&&(e.zoom=0),e}),[t]),[n,a]=(0,r.useState)(v(t.formData,t.payload.data.features||[])),[s,c]=(0,r.useState)(t.payload.form_data),[m,_]=(0,r.useState)(o());(0,r.useEffect)((()=>{if(t.payload.form_data!==s){const e=t.payload.data.features||[],n=v(t.formData,e);_(o()),c(t.payload.form_data),a(n)}}),[o,t,s]);const P=(0,r.useCallback)((t=>{const{current:o}=e;o&&o.setTooltip(t)}),[]),y=(0,r.useCallback)(((t,e,o)=>{const n=e.color_scheme,a=x(n);let i;switch(o){case f.wP.fixed_color:return i=e.color_picker||{r:0,g:0,b:0,a:100},t.map((t=>({...t,color:[i.r,i.g,i.b,255*i.a]})));case f.wP.categorical_palette:return t.map((t=>({...t,color:(0,d.hexToRGB)(a(t.cat_color,e.slice_id))})));case f.wP.color_breakpoints:{const o=e.deafult_breakpoint_color?[e.deafult_breakpoint_color.r,e.deafult_breakpoint_color.g,e.deafult_breakpoint_color.b,255*e.deafult_breakpoint_color.a]:[h.DL.r,h.DL.g,h.DL.b,255*h.DL.a];return t.map((t=>{var n;const a=null==(n=e.color_breakpoints)?void 0:n.find((e=>t.metric>=e.minValue&&t.metric<=e.maxValue));return{...t,color:a?[null==a?void 0:a.color.r,null==a?void 0:a.color.g,null==a?void 0:a.color.b,255*(null==a?void 0:a.color.a)]:o}}))}default:return[]}}),[]),S=(0,r.useCallback)((()=>{const{getLayer:e,payload:o,formData:a,onAddFilter:i,onContextMenu:r,filterState:s,setDataMask:l,emitCrossFilters:c}=t;let u=o.data.features?[...o.data.features]:[];const d=a.color_scheme_type;return u=y(u,a,d),a.js_data_mutator&&(u=(0,g.A)(a.js_data_mutator)(u)),a.dimension&&(u=u.filter((t=>{var e;return null==(e=n[t.cat_color])?void 0:e.enabled}))),[e({formData:a,payload:{...o,data:{...o.data,features:u}},onAddFilter:i,setTooltip:P,datasource:t.datasource,onContextMenu:r,filterState:s,setDataMask:l,emitCrossFilters:c})]}),[y,n,t,P]),w=(0,r.useCallback)((t=>{const e=n[t],o={...n,[t]:{...e,enabled:!e.enabled}};Object.values(o).every((t=>!t.enabled))&&Object.values(o).forEach((t=>{t.enabled=!0})),a(o)}),[n]),b=(0,r.useCallback)((t=>{const e={...n};Object.values(e).forEach((t=>{t.enabled=!1})),e[t].enabled=!0,a(e)}),[n]);return(0,i.FD)("div",{style:{position:"relative"},children:[(0,i.Y)(l.S,{ref:e,viewport:m,layers:S(),setControlValue:t.setControlValue,mapStyle:t.formData.mapbox_style,mapboxApiAccessToken:t.mapboxApiKey,width:t.width,height:t.height}),(0,i.Y)(u.A,{forceCategorical:!0,categories:n,format:t.formData.legend_format,position:t.formData.legend_position,showSingleCategory:b,toggleCategory:w})]})},P=(0,r.memo)(_);function y(t,e){return(0,r.memo)((o=>{const n=(0,r.useRef)(),c=(0,s.Z)(o.formData),d=(0,s.Z)(o.filterState),g=(0,s.Z)(o.payload),[f,h]=(0,r.useState)((0,m.BK)(o.formData.color_breakpoints)||[]),[x,v]=(0,r.useState)((()=>{const{width:t,height:n,formData:a}=o;return a.autozoom?(0,p.A)(o.viewport,{width:t,height:n,points:e(o.payload.data.features)}):o.viewport})()),_=(0,r.useCallback)((t=>{const{current:e}=n;e&&(null==e||e.setTooltip(t))}),[]),P=(0,r.useCallback)((e=>{const{formData:o,payload:n,onAddFilter:a,filterState:i,setDataMask:r,onContextMenu:s,emitCrossFilters:l}=e;return t({formData:o,payload:n,onAddFilter:a,setTooltip:_,setDataMask:r,onContextMenu:s,filterState:i,emitCrossFilters:l})}),[_]);(0,r.useEffect)((()=>{const t=(0,m.BK)(o.formData.color_breakpoints);h(t)}),[o]);const[y,S]=(0,r.useState)(P(o));(0,r.useEffect)((()=>{const t={...c,...d,viewport:null},e={...o.formData,...o.filterState,viewport:null};a()(t,e)&&g===o.payload||S(P(o))}),[P,c,d,g,o]);const{formData:w,payload:b,setControlValue:C,height:D,width:R}=o;return(0,i.FD)("div",{style:{position:"relative"},children:[(0,i.Y)(l.S,{ref:n,mapboxApiAccessToken:b.data.mapboxApiKey,viewport:x,layers:[y],mapStyle:w.mapbox_style,setControlValue:C,width:R,height:D,onViewportChange:v}),(0,i.Y)(u.A,{forceCategorical:!0,categories:f,format:o.formData.legend_format,position:o.formData.legend_position})]})}))}function S(t,e){return function(o){const{datasource:n,formData:a,height:r,payload:s,setControlValue:l,viewport:c,width:u,setDataMask:d,filterState:g,onContextMenu:p,emitCrossFilters:f}=o;return(0,i.Y)(P,{datasource:n,formData:a,mapboxApiKey:s.data.mapboxApiKey,setControlValue:l,viewport:c,getLayer:t,payload:s,getPoints:e,width:u,height:r,setDataMask:d,onContextMenu:p,filterState:g,emitCrossFilters:f})}}},66671:(t,e,o)=>{o.d(e,{A:()=>u});var n=o(2445),a=o(96540),i=o(72234),r=o(32142);const s=i.I4.div`
  ${({theme:t})=>`\n    font-size: ${t.fontSizeSM}px;\n    position: absolute;\n    background: ${t.colors.grayscale.light5};\n    box-shadow: 0 0 ${t.sizeUnit}px ${t.colors.grayscale.light2};\n    margin: ${6*t.sizeUnit}px;\n    padding: ${3*t.sizeUnit}px ${5*t.sizeUnit}px;\n    outline: none;\n    overflow-y: scroll;\n    max-height: 200px;\n\n    & ul {\n      list-style: none;\n      padding-left: 0;\n      margin: 0;\n\n      & li a {\n        display: flex;\n        color: ${t.colors.grayscale.base};\n        text-decoration: none;\n        padding: ${t.sizeUnit}px 0;\n\n        & span {\n          margin-right: ${t.sizeUnit}px;\n        }\n      }\n    }\n  `}
`,l=" - ",c=({format:t=null,forceCategorical:e=!1,position:o="tr",categories:a={},toggleCategory:i=()=>{},showSingleCategory:c=()=>{}})=>{const u=o=>{if(!t||e)return o;const n=parseFloat(o);return(0,r.ZV)(t,n)},d=e=>{if(!t)return e;if(e.includes(l)){const t=e.split(l);return u(t[0])+l+u(t[1])}return u(e)};if(0===Object.keys(a).length||null===o)return null;const g=Object.entries(a).map((([t,e])=>{var o;const a={color:`rgba(${null==(o=e.color)?void 0:o.join(", ")})`},r=e.enabled?"◼":"◻";return(0,n.Y)("li",{children:(0,n.FD)("a",{href:"#",role:"button",onClick:()=>i(t),onDoubleClick:()=>c(t),children:[(0,n.Y)("span",{style:a,children:r})," ",d(t)]})},t)})),p="t"===(null==o?void 0:o.charAt(0))?"top":"bottom",f="r"===(null==o?void 0:o.charAt(1))?"right":"left",m={position:"absolute",[p]:"0px",[f]:"10px"};return(0,n.Y)(s,{className:"dupa",style:m,children:(0,n.Y)("ul",{children:g})})},u=(0,a.memo)(c)}}]);
#!/usr/bin/env python3

# WARNING: CAVEAT UTILITOR
#
#  This file was automatically generated by TatSu.
#
#     https://pypi.python.org/pypi/tatsu/
#
#  Any changes you make to it will be overwritten the next time
#  the file is generated.

# ruff: noqa: C405, COM812, I001, F401, PLR1702, PLC2801, SIM117

import sys
from pathlib import Path

from tatsu.buffering import Buffer
from tatsu.parsing import Parser
from tatsu.parsing import tatsumasu
from tatsu.parsing import leftrec, nomemo, isname
from tatsu.infos import ParserConfig
from tatsu.util import re, generic_main


KEYWORDS: set[str] = set()


class BsplBuffer(Buffer):
    def __init__(self, text, /, config: ParserConfig | None = None, **settings):
        config = ParserConfig.new(
            config,
            owner=self,
            whitespace=None,
            nameguard=None,
            ignorecase=False,
            namechars='',
            parseinfo=False,
            comments=None,
            eol_comments='(?m)(#|\\/\\/)[^\\n]*',
            keywords=KEYWORDS,
            start='document',
        )
        config = config.replace(**settings)

        super().__init__(text, config=config)


class BsplParser(Parser):
    def __init__(self, /, config: ParserConfig | None = None, **settings):
        config = ParserConfig.new(
            config,
            owner=self,
            whitespace=None,
            nameguard=None,
            ignorecase=False,
            namechars='',
            parseinfo=False,
            comments=None,
            eol_comments='(?m)(#|\\/\\/)[^\\n]*',
            keywords=KEYWORDS,
            start='document',
        )
        config = config.replace(**settings)

        super().__init__(config=config)

    @tatsumasu()
    def _document_(self):

        def block0():
            self._protocol_()
            self._cut()
        self._positive_closure(block0)
        self._check_eof()

    @tatsumasu()
    def _protocol_(self):
        self._constant('protocol')
        self.name_last_node('type')
        with self._group():
            with self._choice():
                with self._option():
                    self._token('protocol')
                with self._option():
                    self._void()
                self._error(
                    'expecting one of: '
                    "'protocol'"
                )
        self._spacename_()
        self.name_last_node('name')
        self._token('{')
        self._cut()
        self._token('roles')
        self._roles_()
        self.name_last_node('roles')
        self._token('parameters')
        self._params_()
        self.name_last_node('parameters')
        with self._group():
            with self._choice():
                with self._option():
                    with self._group():
                        self._token('private')
                        self._params_()
                        self.name_last_node('private')
                        self._define(['private'], [])
                with self._option():
                    self._void()
                self._error(
                    'expecting one of: '
                    "'private'"
                )
        self._references_()
        self.name_last_node('references')
        self._token('}')
        self._define(['name', 'parameters', 'private', 'references', 'roles', 'type'], [])

    @tatsumasu()
    def _roles_(self):

        def sep0():
            self._token(',')

        def block1():
            self._role_()
        self._gather(block1, sep0)

    @tatsumasu()
    def _role_(self):
        self._word_()
        self.name_last_node('name')

    @tatsumasu()
    def _params_(self):

        def sep0():
            self._token(',')

        def block1():
            self._param_()
        self._gather(block1, sep0)

    @tatsumasu()
    def _param_(self):
        with self._optional():
            self._protocol_adornment_()
            self.name_last_node('adornment')
        self._word_()
        self.name_last_node('name')
        with self._optional():
            self._token('key')
            self.name_last_node('key')
        self._define(['adornment', 'key', 'name'], [])

    @tatsumasu()
    def _protocol_adornment_(self):
        with self._choice():
            with self._option():
                self._token('out')
            with self._option():
                self._token('in')
            with self._option():
                self._token('nil')
            with self._option():
                self._token('any')
            with self._option():
                self._token('opt')
            self._error(
                'expecting one of: '
                "'any' 'in' 'nil' 'opt' 'out'"
            )

    @tatsumasu()
    def _message_params_(self):

        def sep0():
            self._token(',')

        def block1():
            self._message_param_()
        self._gather(block1, sep0)

    @tatsumasu()
    def _message_param_(self):
        with self._optional():
            self._message_adornment_()
            self.name_last_node('adornment')
        self._word_()
        self.name_last_node('name')
        with self._optional():
            self._token('key')
            self.name_last_node('key')
        self._define(['adornment', 'key', 'name'], [])

    @tatsumasu()
    def _message_adornment_(self):
        with self._choice():
            with self._option():
                self._token('out')
            with self._option():
                self._token('in')
            with self._option():
                self._token('nil')
            self._error(
                'expecting one of: '
                "'in' 'nil' 'out'"
            )

    @tatsumasu()
    def _references_(self):

        def block0():
            with self._choice():
                with self._option():
                    self._message_()
                with self._option():
                    self._ref_()
                self._error(
                    'expecting one of: '
                    '<message> <ref> <spacename> <word>'
                )
        self._closure(block0)

    @tatsumasu()
    def _ref_(self):
        self._constant('protocol')
        self.name_last_node('type')
        self._spacename_()
        self.name_last_node('name')
        self._token('(')
        self._cut()
        with self._optional():
            self._roles_()
            self.name_last_node('roles')
            self._token('|')
            self._define(['roles'], [])
        self._params_()
        self.name_last_node('params')
        self._token(')')
        self._define(['name', 'params', 'roles', 'type'], [])

    @tatsumasu()
    def _message_(self):
        self._constant('message')
        self.name_last_node('type')
        self._word_()
        self.name_last_node('sender')
        with self._group():
            with self._choice():
                with self._option():
                    self._token('->')
                with self._option():
                    self._token('→')
                with self._option():
                    self._token('↦')
                self._error(
                    'expecting one of: '
                    "'->' '→' '↦'"
                )
        self._cut()
        self._recipient_list_()
        self.name_last_node('recipients')
        with self._optional():
            self._token(':')
        self._word_()
        self.name_last_node('name')
        with self._group():
            with self._choice():
                with self._option():
                    self._token('[')
                    self._message_params_()
                    self.name_last_node('parameters')
                    self._token(']')
                    self._define(['parameters'], [])
                with self._option():
                    self._void()
                self._error(
                    'expecting one of: '
                    "'['"
                )
        self._define(['name', 'parameters', 'recipients', 'sender', 'type'], [])

    @tatsumasu()
    def _recipient_list_(self):

        def sep0():
            self._token(',')

        def block1():
            self._word_()
        self._gather(block1, sep0)

    @tatsumasu()
    def _word_(self):
        self._pattern('[\\w@>-]+')

    @tatsumasu()
    def _spacename_(self):
        self._pattern('[ \\w@-]+')


def main(filename, **kwargs):
    if not filename or filename == '-':
        text = sys.stdin.read()
    else:
        text = Path(filename).read_text()
    parser = BsplParser()
    return parser.parse(
        text,
        filename=filename,
        **kwargs,
    )


if __name__ == '__main__':
    import json
    from tatsu.util import asjson

    ast = generic_main(main, BsplParser, name='Bspl')
    data = asjson(ast)
    print(json.dumps(data, indent=2))

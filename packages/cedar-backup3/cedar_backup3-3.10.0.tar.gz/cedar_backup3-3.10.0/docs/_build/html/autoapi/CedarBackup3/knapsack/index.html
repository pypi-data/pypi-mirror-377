<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>CedarBackup3.knapsack &#8212; cedar-backup3 3.10.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=6625fa76" />
    <link rel="stylesheet" type="text/css" href="../../../_static/basic.css?v=686e5160" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=ec641305" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=4ae1632d" />
    <script src="../../../_static/documentation_options.js?v=f8d09eac"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="CedarBackup3.peer" href="../peer/index.html" />
    <link rel="prev" title="CedarBackup3.image" href="../image/index.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="module-CedarBackup3.knapsack">
<span id="cedarbackup3-knapsack"></span><h1>CedarBackup3.knapsack<a class="headerlink" href="#module-CedarBackup3.knapsack" title="Link to this heading">¶</a></h1>
<p>Provides the implementation for various knapsack algorithms.</p>
<p>Knapsack algorithms are “fit” algorithms, used to take a set of “things” and
decide on the optimal way to fit them into some container.  The focus of this
code is to fit files onto a disc, although the interface (in terms of item,
item size and capacity size, with no units) is generic enough that it can
be applied to items other than files.</p>
<p>All of the algorithms implemented below assume that “optimal” means “use up as
much of the disc’s capacity as possible”, but each produces slightly different
results.  For instance, the best fit and first fit algorithms tend to include
fewer files than the worst fit and alternate fit algorithms, even if they use
the disc space more efficiently.</p>
<p>Usually, for a given set of circumstances, it will be obvious to a human which
algorithm is the right one to use, based on trade-offs between number of files
included and ideal space utilization.  It’s a little more difficult to do this
programmatically.  For Cedar Backup’s purposes (i.e. trying to fit a small
number of collect-directory tarfiles onto a disc), worst-fit is probably the
best choice if the goal is to include as many of the collect directories as
possible.</p>
<dl class="field-list simple">
<dt class="field-odd">author<span class="colon">:</span></dt>
<dd class="field-odd"><p>Kenneth J. Pronovici &lt;<a class="reference external" href="mailto:pronovic&#37;&#52;&#48;ieee&#46;org">pronovic<span>&#64;</span>ieee<span>&#46;</span>org</a>&gt;</p>
</dd>
</dl>
<section id="module-contents">
<h2>Module Contents<a class="headerlink" href="#module-contents" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="CedarBackup3.knapsack.firstFit">
<span class="sig-prename descclassname"><span class="pre">CedarBackup3.knapsack.</span></span><span class="sig-name descname"><span class="pre">firstFit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">items</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">capacity</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#CedarBackup3.knapsack.firstFit" title="Link to this definition">¶</a></dt>
<dd><p>Implements the first-fit knapsack algorithm.</p>
<p>The first-fit algorithm proceeds through an unsorted list of items until
running out of items or meeting capacity exactly.  If capacity is exceeded,
the item that caused capacity to be exceeded is thrown away and the next one
is tried.  This algorithm generally performs more poorly than the other
algorithms both in terms of capacity utilization and item utilization, but
can be as much as an order of magnitude faster on large lists of items
because it doesn’t require any sorting.</p>
<p>The “size” values in the items and capacity arguments must be comparable,
but they are unitless from the perspective of this function.  Zero-sized
items and capacity are considered degenerate cases.  If capacity is zero,
no items fit, period, even if the items list contains zero-sized items.</p>
<p>The dictionary is indexed by its key, and then includes its key.  This
seems kind of strange on first glance.  It works this way to facilitate
easy sorting of the list on key if needed.</p>
<p>The function assumes that the list of items may be used destructively, if
needed.  This avoids the overhead of having the function make a copy of the
list, if this is not required.  Callers should pass <code class="docutils literal notranslate"><span class="pre">items.copy()</span></code> if they
do not want their version of the list modified.</p>
<p>The function returns a list of chosen items and the unitless amount of
capacity used by the items.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>items</strong> (dictionary, keyed on item, of <code class="docutils literal notranslate"><span class="pre">item,</span> <span class="pre">size</span></code> tuples, item as string and size as integer) – Items to operate on</p></li>
<li><p><strong>capacity</strong> (<em>integer</em>) – Capacity of container to fit to</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Tuple <code class="docutils literal notranslate"><span class="pre">(items,</span> <span class="pre">used)</span></code> as described above</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="CedarBackup3.knapsack.bestFit">
<span class="sig-prename descclassname"><span class="pre">CedarBackup3.knapsack.</span></span><span class="sig-name descname"><span class="pre">bestFit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">items</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">capacity</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#CedarBackup3.knapsack.bestFit" title="Link to this definition">¶</a></dt>
<dd><p>Implements the best-fit knapsack algorithm.</p>
<p>The best-fit algorithm proceeds through a sorted list of items (sorted from
largest to smallest) until running out of items or meeting capacity exactly.
If capacity is exceeded, the item that caused capacity to be exceeded is
thrown away and the next one is tried.  The algorithm effectively includes
the minimum number of items possible in its search for optimal capacity
utilization.  For large lists of mixed-size items, it’s not ususual to see
the algorithm achieve 100% capacity utilization by including fewer than 1%
of the items.  Probably because it often has to look at fewer of the items
before completing, it tends to be a little faster than the worst-fit or
alternate-fit algorithms.</p>
<p>The “size” values in the items and capacity arguments must be comparable,
but they are unitless from the perspective of this function.  Zero-sized
items and capacity are considered degenerate cases.  If capacity is zero,
no items fit, period, even if the items list contains zero-sized items.</p>
<p>The dictionary is indexed by its key, and then includes its key.  This
seems kind of strange on first glance.  It works this way to facilitate
easy sorting of the list on key if needed.</p>
<p>The function assumes that the list of items may be used destructively, if
needed.  This avoids the overhead of having the function make a copy of the
list, if this is not required.  Callers should pass <code class="docutils literal notranslate"><span class="pre">items.copy()</span></code> if they
do not want their version of the list modified.</p>
<p>The function returns a list of chosen items and the unitless amount of
capacity used by the items.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>items</strong> (dictionary, keyed on item, of <code class="docutils literal notranslate"><span class="pre">item,</span> <span class="pre">size</span></code> tuples, item as string and size as integer) – Items to operate on</p></li>
<li><p><strong>capacity</strong> (<em>integer</em>) – Capacity of container to fit to</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Tuple <code class="docutils literal notranslate"><span class="pre">(items,</span> <span class="pre">used)</span></code> as described above</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="CedarBackup3.knapsack.worstFit">
<span class="sig-prename descclassname"><span class="pre">CedarBackup3.knapsack.</span></span><span class="sig-name descname"><span class="pre">worstFit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">items</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">capacity</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#CedarBackup3.knapsack.worstFit" title="Link to this definition">¶</a></dt>
<dd><p>Implements the worst-fit knapsack algorithm.</p>
<p>The worst-fit algorithm proceeds through an a sorted list of items (sorted
from smallest to largest) until running out of items or meeting capacity
exactly.  If capacity is exceeded, the item that caused capacity to be
exceeded is thrown away and the next one is tried.  The algorithm
effectively includes the maximum number of items possible in its search for
optimal capacity utilization.  It tends to be somewhat slower than either
the best-fit or alternate-fit algorithm, probably because on average it has
to look at more items before completing.</p>
<p>The “size” values in the items and capacity arguments must be comparable,
but they are unitless from the perspective of this function.  Zero-sized
items and capacity are considered degenerate cases.  If capacity is zero,
no items fit, period, even if the items list contains zero-sized items.</p>
<p>The dictionary is indexed by its key, and then includes its key.  This
seems kind of strange on first glance.  It works this way to facilitate
easy sorting of the list on key if needed.</p>
<p>The function assumes that the list of items may be used destructively, if
needed.  This avoids the overhead of having the function make a copy of the
list, if this is not required.  Callers should pass <code class="docutils literal notranslate"><span class="pre">items.copy()</span></code> if they
do not want their version of the list modified.</p>
<p>The function returns a list of chosen items and the unitless amount of
capacity used by the items.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>items</strong> (dictionary, keyed on item, of <code class="docutils literal notranslate"><span class="pre">item,</span> <span class="pre">size</span></code> tuples, item as string and size as integer) – Items to operate on</p></li>
<li><p><strong>capacity</strong> (<em>integer</em>) – Capacity of container to fit to</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Tuple <code class="docutils literal notranslate"><span class="pre">(items,</span> <span class="pre">used)</span></code> as described above</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="CedarBackup3.knapsack.alternateFit">
<span class="sig-prename descclassname"><span class="pre">CedarBackup3.knapsack.</span></span><span class="sig-name descname"><span class="pre">alternateFit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">items</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">capacity</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#CedarBackup3.knapsack.alternateFit" title="Link to this definition">¶</a></dt>
<dd><p>Implements the alternate-fit knapsack algorithm.</p>
<p>This algorithm (which I’m calling “alternate-fit” as in “alternate from one
to the other”) tries to balance small and large items to achieve better
end-of-disk performance.  Instead of just working one direction through a
list, it alternately works from the start and end of a sorted list (sorted
from smallest to largest), throwing away any item which causes capacity to
be exceeded.  The algorithm tends to be slower than the best-fit and
first-fit algorithms, and slightly faster than the worst-fit algorithm,
probably because of the number of items it considers on average before
completing.  It often achieves slightly better capacity utilization than the
worst-fit algorithm, while including slighly fewer items.</p>
<p>The “size” values in the items and capacity arguments must be comparable,
but they are unitless from the perspective of this function.  Zero-sized
items and capacity are considered degenerate cases.  If capacity is zero,
no items fit, period, even if the items list contains zero-sized items.</p>
<p>The dictionary is indexed by its key, and then includes its key.  This
seems kind of strange on first glance.  It works this way to facilitate
easy sorting of the list on key if needed.</p>
<p>The function assumes that the list of items may be used destructively, if
needed.  This avoids the overhead of having the function make a copy of the
list, if this is not required.  Callers should pass <code class="docutils literal notranslate"><span class="pre">items.copy()</span></code> if they
do not want their version of the list modified.</p>
<p>The function returns a list of chosen items and the unitless amount of
capacity used by the items.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>items</strong> (dictionary, keyed on item, of <code class="docutils literal notranslate"><span class="pre">item,</span> <span class="pre">size</span></code> tuples, item as string and size as integer) – Items to operate on</p></li>
<li><p><strong>capacity</strong> (<em>integer</em>) – Capacity of container to fit to</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Tuple <code class="docutils literal notranslate"><span class="pre">(items,</span> <span class="pre">used)</span></code> as described above</p>
</dd>
</dl>
</dd></dl>

</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">cedar-backup3</a></h1>






<p>
<iframe src="https://ghbtns.com/github-btn.html?user=pronovic&repo=cedar-backup3&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>






<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../../index.html">API Reference</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">API Reference</a><ul>
  <li><a href="../index.html">CedarBackup3</a><ul>
      <li>Previous: <a href="../image/index.html" title="previous chapter">CedarBackup3.image</a></li>
      <li>Next: <a href="../peer/index.html" title="next chapter">CedarBackup3.peer</a></li>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;(c) Kenneth J. Pronovici.
      
    </div>

    
    <a href="https://github.com/pronovic/cedar-backup3" class="github">
        <img src="../../../_static/github-banner.svg" alt="Fork me on GitHub" class="github"/>
    </a>
    

    
  </body>
</html>
workflow:
  # Run if tag starts v0.00.00 indicating a release
  #     or pipeline ist started manually in gitlab
  rules:
    - if: $CI_COMMIT_TAG =~ /^v[0-9]+\.[0-9]+\.[0-9]+.*/
    - if: $CI_PIPELINE_SOURCE == "web" || $CI_JOB_MANUAL == "true"

variables:
  DISTRIBUTIONS: ""
  GITHUB_USER: "cdruee"

stages:
  - build
  - test
  - package
  - deploy

build_sdist:
  image: python:latest
  stage: build
  before_script:
    - git fetch --tags  # Ensure tags are available
    - pip install build setuptools setuptools-scm wheel
  script:
    - python -m setuptools_scm  # This will show what version setuptools-scm detects
    - git describe --tags --dirty  # Show current git state
    - python -m build -n --sdist
    - echo 'ls dist/*tar.gz'
    - ls dist/*tar.gz
    - echo 'cd dist && ls *tar.gz'
    - echo "$( cd dist && ls *tar.gz )"
    - echo "BUILD_VERSION=$( cd dist && ls *tar.gz )" >> build.env
    - echo "BUILD_JOB=${CI_JOB_ID}" >> build.env
  artifacts:
    paths:
      - dist
    reports:
      dotenv: build.env

build_pages:
  image: python:latest
  stage: build
  rules:
    - exists:
      - docs/conf.py
  needs:
    - job: build_sdist
  script:
    - pip install setuptools importlib build
    - pip install sphinx sphinx-argparse sphinx-rtd-theme
    - pip install numpy pandas
    - python -m build --wheel
    - BUILDING_SPHINX=true sphinx-build -b html docs build/sphinx/html
    - mv build/sphinx/html/ public/
  artifacts:
    paths:
      - public

#TODO make this work
test_latest:
  image: python:latest
  stage: test
  script:
    - echo pip install tox numpy pandas flake8
    - echo tox

build_deb:
  stage: package
  image: $PUBLISHER:$DISTRIB
  needs:
    - job: build_sdist
      artifacts: true
    - job: test_latest
  script:
    - export DEBIAN_FRONTEND=noninteractive
    - apt update
    - apt-get -y install gawk dh-python debhelper dh-make
    - apt-get -y install python3-all
    - apt-get -y install python3-numpy python3-pandas
    - apt-get -y install python3-setuptools python3-stdeb
    - apt-get -y install python3-setuptools-scm python3-build
    - bash -x ./ci_build_deb.sh $BUILD_VERSION
    - echo "DEB_${DISTRIB^^}_VERSION=$( cd deb_dist/$DISTRIB && ls *deb )" | tee -a  build.env
    - echo "DEB_${DISTRIB^^}_JOB=${CI_JOB_ID}" | tee -a build.env
    - cat build.env
  artifacts:
    paths:
      - deb_dist
    reports:
      dotenv: build.env
  parallel:
    matrix:
      - PUBLISHER: ubuntu
        DISTRIB:
          - jammy
          - noble
      - PUBLISHER: debian
        DISTRIB:
          - bookworm
          - trixie

merge_github:
  # deploy only if a release (no ".devX" or "+"in version string):
  rules:
    - if: $CI_COMMIT_TAG && $CI_COMMIT_TAG !~ /(\.dev|\+)/
      exists:
        - $SSH_PRIVATE_KEY
  stage: package
  image: alpine
  variables:
    GIT_DEPTH: 0  # Ensure full git history for tag pushing
  before_script:
    # install ssh-agent if not already installed
    - command -v ssh-agent >/dev/null || apk add --update openssh-client
    # create the .ssh directory and set permissions
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - cp $SSH_PRIVATE_KEY ~/.ssh/id_rsa
    - chmod 400 ~/.ssh/id_rsa
    - cp $SSH_PUBLIC_KEY ~/.ssh/id_rsa.pub
    - chmod 444 ~/.ssh/id_rsa.pub
  script:
   - apk add --update git
   - git config --global user.email "$GITLAB_USER_EMAIL"
   - git config --global user.name "$GITLAB_USER_NAME"
   # Ensure we have full history including tags
   - git fetch --unshallow --tags || echo "Already unshallow"
   - echo remote set-url origin "https://ci_access_token:$CI_ACCESS_TOKEN@$CI_SERVER_HOST/$CI_PROJECT_NAMESPACE/$CI_PROJECT_NAME.git"
   - git remote set-url origin "https://ci_access_token:$CI_ACCESS_TOKEN@$CI_SERVER_HOST/$CI_PROJECT_NAMESPACE/$CI_PROJECT_NAME.git"
   - git branch -avv
   - git pull --rebase origin main
   # prepare access to github
   - ssh-keygen -lf ~/.ssh/id_rsa
   - ssh-keygen -lf ~/.ssh/id_rsa.pub
   - ssh-keyscan -H github.com >> ~/.ssh/known_hosts
   - ssh -T git@github.com || echo "no shell access is OK"
   - git remote add -t github github "ssh://git@github.com/$GITHUB_USER/$CI_PROJECT_NAME.git"
   - git branch -avv
   # first synch repo and from github.com branches
   - git fetch origin github || echo "nothing to fetch !?"
   - git fetch --refetch -f github github || echo "nothing to fetch !?"
   - git branch -avv
   # Simple checkout: get latest from either local or remote
   - |
     # Ensure we're on the github branch
     git checkout github 2>/dev/null || git checkout -b github origin/github
     
     # Pull latest from both remotes, preferring fast-forward
     git pull --rebase origin github || echo "No updates from origin/github"
     git pull --rebase github github || echo "No updates from github/github"  
     
     echo "Now on github branch with latest changes"
   - git branch -avv
   # push synched branches
   - git push origin github
   - git push github github
   - git branch -avv
   # then merge repo main branch into local working dir (github branch)
   - git merge --squash origin/main -X theirs --allow-unrelated-histories 2>&1 | tee git.out
   - git branch -avv
   # if there was nothing new, exit graceful
   - if grep -q "Already up to date" git.out ; then exit 0 ; else rm git.out; fi
   # check if something is to commit (diff-index non-zero exit), commit if there is
   - git diff-index --quiet --cached HEAD || git commit -a -m "Squash merge main into github"
   - git branch -avv
   # push working dir back into repo github branch
   - git push origin github
   # push working dir also to github.com
   - git push github github
   - if ! [[ "x$CI_COMMIT_TAG" == "x" ]]; then git push origin $CI_COMMIT_TAG; git push github $CI_COMMIT_TAG; fi

deploy_pages:
  # deploy only if a release (no ".devX" or "+"in version string):
  rules:
    - if: $CI_COMMIT_TAG && $CI_COMMIT_TAG !~ /(\.dev|\+)/
      exists:
        - docs/conf.py
  image: python:latest
  stage: deploy
  needs:
    - job: build_pages
      artifacts: true
    - job: build_deb
  script:
    - touch public
  pages: true
  artifacts:
    paths:
    - public

release:
  # deploy only if a release (no ".devX" or "+"in version string):
  rules:
    - if: $CI_COMMIT_TAG && $CI_COMMIT_TAG !~ /(\.dev|\+)/
  image: ubuntu:latest
  stage: deploy
  needs:
    - job: build_sdist
      artifacts: true
    - job: build_deb
      artifacts: true
    - job: test_latest
  before_script:
    - echo "Running the release job."
    - apt update
    - apt -y install curl jq
    - curl --location --output /usr/local/bin/release-cli "https://gitlab.com/api/v4/projects/gitlab-org%2Frelease-cli/packages/generic/release-cli/latest/release-cli-linux-amd64"
    - chmod +x /usr/local/bin/release-cli
  script:
    - echo "Running the release job.1"
    - export SDIST_NAME="Python install package - ${BUILD_VERSION}"
    - echo SDIST_NAME $SDIST_NAME
    - 'export SDIST_URL=${CI_PROJECT_URL}/-/jobs/${BUILD_JOB}/artifacts/raw/dist/${BUILD_VERSION}'
    - echo SDIST_URL $SDIST_URL
    - export ASSET_ARGS='[{"name":"'$SDIST_NAME'","url":"'$SDIST_URL'"}'
    - echo ASSET_ARGS $ASSET_ARGS
    - DISTRIBUTIONS=$( ls deb_dist | tr "\n" " ")
    - |
      for DISTRIB in $DISTRIBUTIONS; do
        echo distrib $DISTRIB
        echo DISTRIB ${DISTRIB^^}
        VERNAM=DEB_${DISTRIB^^}_VERSION
        echo VERNAM $VERNAM
        JOBNAM=DEB_${DISTRIB^^}_JOB
        echo JOBNAM $JOBNAM
        name="binary install package for $DISTRIB - ${!VERNAM}"
        echo name $name
        url="${CI_PROJECT_URL}/-/jobs/${!JOBNAM}/artifacts/raw/deb_dist/${DISTRIB}/${!VERNAM}"
        echo url $url
        asset_info='{"name":"'$name'","url":"'$url'"}'
        echo asset_info $asset_info
        ASSET_ARGS="$ASSET_ARGS, $asset_info"
      done
      ASSET_ARGS=$ASSET_ARGS']'
    - echo "..."
    - 'jq . <<< $ASSET_ARGS'
    - echo "..."
    - if [[ "$CI_COMMIT_TAG" == "" ]]; then echo "CI_COMMIT_TAG is empty"; exit 0; fi
    - echo "..."
    - 'echo release-cli create --name "$CI_COMMIT_TAG" --tag-name "$CI_COMMIT_TAG" --description "$CI_COMMIT_MESSAGE" --ref "$CI_COMMIT_TAG" --assets-link "$( jq -c . <<< $ASSET_ARGS )"'
    - 'release-cli create --name "$CI_COMMIT_TAG" --tag-name "$CI_COMMIT_TAG" --description "$CI_COMMIT_MESSAGE" --ref "$CI_COMMIT_TAG" --assets-link "$( jq -c . <<< $ASSET_ARGS )"'

deploy_deb:
  # deploy only if a release (no ".devX" or "+"in version string):
  rules:
    - if: $CI_COMMIT_TAG && $CI_COMMIT_TAG !~ /(\.dev|\+)/
      exists:
        - $SSH_PRIVATE_KEY
  image: ubuntu:latest
  stage: deploy
  needs:
    - job: build_sdist
      artifacts: true
    - job: build_deb
      artifacts: true
  before_script:
    - 'command -v ssh-agent >/dev/null || ( apt-get update -y && apt-get install openssh-client -y )'
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - cp $SSH_PRIVATE_KEY ~/.ssh/id_rsa
    - chmod 600 ~/.ssh/id_rsa
    - eval $(ssh-agent -s)
    - ssh-add ~/.ssh/id_rsa
    - apt install -y curl dupload
    - curl ifconfig.me
    - ssh-keyscan -H 'uwmhub.uni-trier.de' >> ~/.ssh/known_hosts
  script:
    - ls -l
    - export RESDIR="deb_dist"
    - ls -l $RESDIR
    - |
      cat > ~/.dupload.conf << EOF
      package config;
      \$default_host = "uwmhub";
      \$cfg{'uwmhub'} = {
        fqdn => "uwmhub.uni-trier.de",
        method => "scp",
        login => "reprepro",
        incoming => "/home/reprepro/incoming/",
        # files pass on to dinstall which sends emails itself
        dinstall_runs => 1,
      };
      EOF
    - cat ~/.dupload.conf
    - |
      for X in $( ls $RESDIR ); do 
        pushd $RESDIR/$X
        ls -l
        for Y in *.changes; do 
          sed -i s/Distribution:\ .\*/Distribution:\ "${X}"/ $Y   
          cat $Y
          dupload -f --nomail -t uwmhub $Y
          sleep 60
        done
        popd
      done
    - echo "Ende"

deploy_pypi:
  # deploy only if a release (no ".devX" or "+"in version string):
  rules:
    - if: $CI_COMMIT_TAG && $CI_COMMIT_TAG !~ /(\.dev|\+)/ && $PYPI_ID_TOKEN
  image: python:latest
  stage: deploy
  needs:
    - job: build_deb
    - job: build_sdist
      artifacts: true
  script:
    - pip install twine
    - twine check dist/*tar.gz
    - twine upload --repository-url https://upload.pypi.org/legacy/ --username __token__ --password $PYPI_ID_TOKEN dist/*tar.gz

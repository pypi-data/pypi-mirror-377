{"version":3,"file":"genesys.bundle.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0N;AAC1E;AACpF;AAC7C;AACK;AACS;AACN;AACF;AACR;AACc;AAC0C;AACO;AACrC;AACkC;AACF;AACzC;AACP;AACe;AACC;AACkC;AACJ;AACa;AACf;AACG;AACD;AACO;AACzD;AACqE;AACd;AACG;AACN;AACG;AACR;AACQ;AACJ;AACF;;AAEpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,kDAAe;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mDAAQ,IAAI,QAAQ;AAChC,mEAAmE,sBAAsB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,gBAAgB,4BAA4B;AAChF;AACA,+DAA+D,gDAAgB;AAC/E,gBAAgB,sBAAsB;AACtC;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA,6CAA6C,aAAa,oBAAoB;AAC9E;AACA,gCAAgC,oDAAkB;AAClD;AACA,iEAAiE,SAAS;AAC1E,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,QAAQ,mDAAQ,IAAI,QAAQ;AAC5B;AACA;AACA;AACA,kBAAkB,oDAAY;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,cAAc;AAC9B;AACA;AACA,wCAAwC,gBAAgB,oBAAoB;AAC5E,8CAA8C,4CAA4C;AAC1F;AACA,oCAAoC,gCAAgC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oDAAY;AACpB;AACA,gBAAgB,mDAAQ,IAAI,QAAQ;AACpC;AACA;AACA;AACA,gBAAgB,mDAAQ,IAAI,QAAQ;AACpC;AACA,gBAAgB,mDAAQ,IAAI,QAAQ,wCAAwC,OAAO;AACnF,wBAAwB,8BAA8B;AACtD,iCAAiC;AACjC,+BAA+B,gDAAgB;AAC/C,4CAA4C,mDAAQ,IAAI,QAAQ;AAChE,+CAA+C,mDAAY,IAAI,QAAQ;AACvE;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,eAAe,KAAK,mDAAU;AACjE,2BAA2B,gDAAoB;AAC/C,kBAAkB,gDAAc;AAChC,yBAAyB,gDAAc;AACvC;AACA;AACA,SAAS;AACT;AACA,oCAAoC,oBAAoB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY,kBAAkB,oDAAoD;AAC1G;AACA,sDAAsD,4CAA4C;AAClG;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mDAAQ,IAAI,QAAQ;AAC5B,aAAa,oDAAa;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mDAAQ,IAAI,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mDAAQ,IAAI,QAAQ;AAC5B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mDAAY,IAAI,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mDAAY,IAAI,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mDAAQ,IAAI,QAAQ;AAC5B,gBAAgB,qBAAqB;AACrC,QAAQ,mDAAQ,IAAI,QAAQ,sBAAsB,mBAAmB;AACrE;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA,gDAAgD,YAAY;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mDAAQ,IAAI,QAAQ;AAC5B,uCAAuC,MAAM,gDAAS,qCAAqC;AAC3F;AACA;AACA;AACA;AACA;AACA,QAAQ,mDAAQ,IAAI,QAAQ;AAC5B,uCAAuC,MAAM,gDAAS,sCAAsC;AAC5F;AACA;AACA;AACA;AACA;AACA,QAAQ,mDAAQ,IAAI,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,gBAAgB,4BAA4B;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,2BAA2B;AAC5G;AACA;AACA;AACA;AACA,mCAAmC,mBAAmB;AACtD,6EAA6E,gCAAgC,IAAI,SAAS;AAC1H;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uCAAuC;AACvD,QAAQ,mDAAQ,IAAI,QAAQ;AAC5B;AACA,wCAAwC,gBAAgB,4BAA4B;AACpF;AACA;AACA,YAAY,mDAAQ,IAAI,QAAQ;AAChC;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,oDAAU;AACxB;AACA;AACA;AACA;AACA;AACA,gBAAgB,mDAAQ,IAAI,QAAQ;AACpC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,mDAAgB;AAC9B;AACA;AACA;AACA;AACA;AACA,oBAAoB,mDAAQ,IAAI,QAAQ;AACxC;AACA,iBAAiB;AACjB;AACA,aAAa;AACb,SAAS,2GAA2G,mBAAmB;AACvI;AACA;AACA,YAAY,mDAAQ,IAAI,QAAQ;AAChC;AACA;AACA,oBAAoB,mDAAQ,IAAI,QAAQ;AACxC,yCAAyC,oHAAoH;AAC7J,iBAAiB;AACjB;AACA,oBAAoB,mDAAQ,IAAI,QAAQ;AACxC,yCAAyC,wHAAwH;AACjK,iBAAiB;AACjB;AACA,oBAAoB,mDAAQ,IAAI,QAAQ;AACxC,yCAAyC,+GAA+G;AACxJ,iBAAiB;AACjB;AACA,oBAAoB,mDAAQ,IAAI,QAAQ;AACxC,yCAAyC,+GAA+G;AACxJ,iBAAiB;AACjB;AACA;AACA;AACA,qCAAqC,8GAA8G;AACnJ,aAAa;AACb;AACA;AACA,cAAc,mDAAgB;AAC9B;AACA,gBAAgB,mDAAQ,IAAI,QAAQ;AACpC;AACA,aAAa;AACb,SAAS,0FAA0F,mBAAmB;AACtH;AACA;AACA;AACA,iCAAiC,mDAAgB,6GAA6G,mBAAmB;AACjL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,2CAA2C,kEAAkE;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mDAAQ,IAAI,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,QAAQ,QAAQ,UAAU;AACrD,SAAS;AACT;AACA;;AAEuC;;;;;;;;;;;;;;;AC9kBvC;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,SAAS;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEgC","sources":["webpack://@carbon/ai-chat-examples-web-components-basic/../node_modules/.pnpm/@carbon+ai-chat@0.3.3_@carbon+icon-helpers@10.65.0_@carbon+icons@11.66.0_@carbon+react@_2d1b4ff090e346b709104e64783ade7d/node_modules/@carbon/ai-chat/dist/es/GenesysMessengerServiceDesk.js","webpack://@carbon/ai-chat-examples-web-components-basic/../node_modules/.pnpm/@carbon+ai-chat@0.3.3_@carbon+icon-helpers@10.65.0_@carbon+icons@11.66.0_@carbon+react@_2d1b4ff090e346b709104e64783ade7d/node_modules/@carbon/ai-chat/dist/es/ServiceDeskImpl.js"],"sourcesContent":["/**\n* @license\n* \n* (C) Copyright IBM Corp. 2017, 2025. All Rights Reserved.\n* \n* Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n* in compliance with the License. You may obtain a copy of the License at\n* \n* http://www.apache.org/licenses/LICENSE-2.0\n* \n* Unless required by applicable law or agreed to in writing, software distributed under the License\n* is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n* or implied. See the License for the specific language governing permissions and limitations under\n* the License.\n* \n* @carbon/ai-chat 0.3.3\n* \n* Built: Jul 11 2025 1:09 pm -04:00\n* \n* \n*/\n\nimport { f as debugLog, ab as isConnectToAgent, af as getSummaryMessages, ag as asyncForEach, S as assertType, ac as isEmptyObject, j as consoleError, an as loadScript, r as resolveOrTimeout } from './AppContainer.js';\nimport { j as MessageResponseTypes, d as ButtonItemKind, b as ButtonItemType, E as ErrorType, S as ScreenShareState } from './customElement.js';\nimport { S as ServiceDeskImpl } from './ServiceDeskImpl.js';\nimport 'react';\nimport 'react-intl';\nimport '@carbon/icons-react';\nimport '@carbon/react';\nimport 'react-redux';\nimport 'lit';\nimport 'lit/decorators.js';\nimport '@carbon/web-components/es-custom/components/button/index.js';\nimport '@carbon/web-components/es-custom/components/overflow-menu/index.js';\nimport 'lit/directives/unsafe-html.js';\nimport '@carbon/web-components/es-custom/components/data-table/index.js';\nimport '@carbon/web-components/es-custom/components/checkbox/index.js';\nimport '@carbon/icon-helpers';\nimport '@carbon/icons';\nimport 'lit/directives/unsafe-svg.js';\nimport 'lit-html/directives/repeat.js';\nimport '@carbon/web-components/es-custom/components/pagination/index.js';\nimport '@carbon/web-components/es-custom/components/select/index.js';\nimport '@carbon/web-components/es-custom/components/data-table/table-skeleton.js';\nimport '@carbon/web-components/es-custom/components/slug/index.js';\nimport '@carbon/web-components/es-custom/components/ai-label/defs.js';\nimport '@carbon/web-components/es-custom/components/popover/defs.js';\nimport '@carbon/web-components/es-custom/components/skeleton-icon/index.js';\nimport 'react-dom';\nimport '@carbon/web-components/es-custom/components/ai-label/ai-label-action-button.js';\nimport '@carbon/web-components/es-custom/components/ai-label/ai-label.js';\nimport '@carbon/web-components/es-custom/components/inline-loading/index.js';\nimport '@carbon/web-components/es-custom/components/textarea/index.js';\nimport '@carbon/web-components/es-custom/components/icon-button/index.js';\nimport '@carbon/web-components/es-custom/components/tag/index.js';\nimport '@carbon/web-components/es-custom/components/chat-button/index.js';\nimport '@carbon/web-components/es-custom/components/button/button.js';\nimport '@carbon/web-components/es-custom/components/layer/index.js';\n\n/**\n * This service desk integration is an integration to the Genesys contact center using their Web Messenger\n * functionality.\n *\n * @see https://developer.genesys.cloud/commdigital/digital/webmessaging/messengersdk for their SDK documentation.\n * @see https://developer.genesys.cloud/forum for their developer forum.\n * @see https://help.mypurecloud.com/articles/get-started-with-web-messaging for getting started with web messaging.\n */\nconst PREFIX = '[GenesysMessengerServiceDesk]';\n// The amount of time to wait for steps in the initialization process to complete before timing out.\nconst INIT_TIMEOUT_SECS = 10;\n// The Promise that is used to load the SDK. The resolve value indicates if we are reconnecting to an existing session.\nlet scriptPromise;\n// This is the global Genesys object that is created by their SDK.\nlet Genesys;\nclass GenesysMessengerServiceDesk extends ServiceDeskImpl {\n    constructor() {\n        super(...arguments);\n        /**\n         * The maximum size of files that are allowed (if file uploads are allowed). A value of 0 indicates that file\n         * uploads are not allowed.\n         */\n        this.maxFileSizeKB = 0;\n        /**\n         * Uploads the given file.\n         */\n        this.doFileUpload = async (upload) => {\n            const transfer = new DataTransfer();\n            transfer.items.add(upload.file);\n            const failed = () => {\n                this.callback.setFileUploadStatus(upload.id, true, this.getIntlText('fileSharing_uploadFailed'));\n            };\n            // Request an upload. This process will conclude when the fileUploaded event is fired. We'll resolve the upload\n            // Promise when that happens.\n            this.currentFileUploadID = upload.id;\n            debugLog(`${PREFIX} MessagingService.requestUpload`, upload);\n            Genesys('command', 'MessagingService.requestUpload', { file: transfer.files }, null, failed);\n        };\n    }\n    /**\n     * Instructs the service desk to start a new chat. This should be called immediately after the service desk\n     * instance has been created. It will make the appropriate calls to the service desk and begin communicating back\n     * to the calling code using the callback produce to the instance. This may only be called once per instance.\n     */\n    async startChat(connectMessage, startChatOptions) {\n        this.updatePersistedState({ agentsJoined: {}, lastAgentMessageID: null }, false);\n        await this.ensureGenesys(false);\n        const connectItem = connectMessage.output.generic.find(isConnectToAgent);\n        const { preStartChatPayload } = startChatOptions;\n        // Create an attribute with the session history key so the agent app can be loaded. Also add in any custom\n        // attributes that may be in the pre-chat payload.\n        const { sessionHistoryKey } = startChatOptions.agentAppInfo;\n        const customAttributes = {\n            ...preStartChatPayload?.customAttributes,\n            wacSessionHistoryKey: sessionHistoryKey,\n        };\n        Genesys('command', 'Database.set', { messaging: { customAttributes } });\n        // Send each of the default summary message texts to the agent.\n        const messagesToAgent = getSummaryMessages(connectItem, 'Begin conversation');\n        messagesToAgent.forEach(message => {\n            Genesys('command', 'MessagingService.sendMessage', { message });\n        });\n    }\n    /**\n     * Handles an incoming MessagingService.messagesReceived event.\n     */\n    async handleMessagesReceived(event) {\n        debugLog(`${PREFIX} MessagingService.messagesReceived`, event);\n        const outbound = event.data.messages.filter((message) => message?.direction === 'Outbound');\n        if (outbound.length) {\n            this.callback.agentTyping(false);\n            await asyncForEach(outbound, async (message) => this.handleOutboundMessage(message, true));\n        }\n    }\n    /**\n     * Handles a message.\n     */\n    async handleOutboundMessage(message, includeEvents) {\n        // The agent info is on different properties depending on if the message came from the restored event or a live\n        // message event.\n        const agentInfo = message.channel?.from || message.from;\n        const nickname = agentInfo?.nickname || agentInfo?.name || null;\n        const profile_picture_url = agentInfo?.avatar || agentInfo?.image || null;\n        const agentID = nickname || 'default-agent';\n        const { isConnected } = this.serviceManager.store.getState().persistedToBrowserStorage.chatState.agentState;\n        const persistedState = this.persistedState();\n        if (!persistedState.agentsJoined[nickname] || !isConnected) {\n            this.updatePersistedState({ agentsJoined: { [nickname]: true } });\n            await this.callback.agentJoined({ id: agentID, nickname, profile_picture_url });\n        }\n        this.updatePersistedState({ lastAgentMessageID: message.id });\n        if (message.type?.toLowerCase() === 'event') {\n            if (includeEvents) {\n                this.handleMessagesReceivedEvent(message);\n            }\n        }\n        else if (message.text) {\n            this.handleMessagesReceivedText(message, agentID);\n        }\n        else if (message.content?.length || message.files?.length) {\n            this.handleFileAttachments(message, agentID);\n        }\n    }\n    /**\n     * Handles an event message. These include the co-browse requests.\n     */\n    async handleMessagesReceivedEvent(message) {\n        asyncForEach(message.events, async (event) => {\n            if (event.eventType === 'CoBrowse' && event.coBrowse?.type === 'OfferingExpired') {\n                debugLog(`${PREFIX} The agent cancelled the co-browse request.`);\n                await this.callback.screenShareEnded();\n            }\n            else if (event.eventType === 'CoBrowse' && event.coBrowse?.type === 'Offering') {\n                debugLog(`${PREFIX} Requesting co-browse sharing from the user...`);\n                const result = await this.callback.screenShareRequest();\n                debugLog(`${PREFIX} Got result for the co-browse request: ${result}`);\n                const { sessionId, sessionJoinToken } = event.coBrowse;\n                const params = { joinCode: sessionJoinToken, sessionId };\n                if (result === ScreenShareState.ACCEPTED) {\n                    const onSuccess = () => debugLog(`${PREFIX} Co-browse session successfully started`);\n                    const onError = (error) => consoleError(`${PREFIX} Error starting a co-browse session`, error);\n                    Genesys('command', 'CobrowseService.acceptSession', params, onSuccess, onError);\n                }\n                else {\n                    Genesys('command', 'CobrowseService.declineSession', params);\n                }\n            }\n        });\n    }\n    /**\n     * Handles a message with text in it.\n     */\n    async handleMessagesReceivedText(message, agentID) {\n        await this.callback.sendMessageToUser(message.text, agentID);\n    }\n    /**\n     * Handles a message with content in it. These would include file links.\n     */\n    async handleFileAttachments(message, agentID) {\n        const files = this.getFileAttachments(message);\n        const items = files.map(({ filename, url }) => assertType({\n            response_type: MessageResponseTypes.BUTTON,\n            kind: ButtonItemKind.LINK,\n            button_type: ButtonItemType.URL,\n            url,\n            label: filename,\n        }));\n        if (items.length) {\n            const messageToUser = { id: null, output: { generic: items } };\n            await this.callback.sendMessageToUser(messageToUser, agentID);\n        }\n    }\n    /**\n     * Extracts file download links from the given message.\n     */\n    getFileAttachments(message) {\n        const files = [];\n        // Files that come in on live messages.\n        message.content\n            ?.filter((content) => content?.attachment)\n            .forEach(({ attachment }) => files.push({ filename: attachment.filename, url: attachment.url }));\n        // Files that come in from a restored event.\n        message.files?.forEach((file) => files.push({ filename: file.name, url: file.downloadUrl }));\n        return files;\n    }\n    /**\n     * Handles an incoming MessagingService.typingReceived event. This indicates that an agent is typing.\n     */\n    handleTypingReceived(event) {\n        debugLog(`${PREFIX} MessagingService.typingReceived`, event);\n        if (!isEmptyObject(this.persistedState().agentsJoined)) {\n            if (this.agentTypingTimeout) {\n                clearTimeout(this.agentTypingTimeout);\n            }\n            const isTyping = event.data?.typing?.type === 'On';\n            this.callback.agentTyping(isTyping);\n            // We're supposed to get a \"timeout\" event to tell us when the agent has stopped typing but that event seems\n            // to be inconsistent and we don't always get it. So we're just going to use our own timeout so we don't get\n            // stuck with an agent permanently typing.\n            if (isTyping) {\n                this.agentTypingTimeout = setTimeout(() => {\n                    this.callback.agentTyping(false);\n                    this.agentTypingTimeout = null;\n                }, event.data?.typing?.duration || 5000);\n            }\n        }\n    }\n    /**\n     * Handles an incoming MessagingService.handleTypingTimeout event. This is the timout for an agent typing.\n     */\n    handleTypingTimeout(event) {\n        debugLog(`${PREFIX} MessagingService.handleTypingTimeout`, event);\n        this.callback.agentTyping(false);\n    }\n    /**\n     * Handles an incoming MessagingService.fileUploaded event.\n     */\n    async handleFileUploaded(event) {\n        debugLog(`${PREFIX} MessagingService.fileUploaded`, event);\n        // We have to send an actual message to Genesys in order to deliver the files.\n        Genesys('command', 'MessagingService.sendMessage', {\n            message: this.getIntlText('fileSharing_agentMessageText'),\n        });\n        this.callback.setFileUploadStatus(this.currentFileUploadID);\n    }\n    /**\n     * Handles an incoming MessagingService.fileUploadError event.\n     */\n    handleFileUploadError(event) {\n        consoleError(`${PREFIX} MessagingService.fileUploadError`, event);\n        if (this.currentFileUploadID) {\n            this.callback.setFileUploadStatus(this.currentFileUploadID, true, this.getIntlText('fileSharing_uploadFailed'));\n        }\n    }\n    /**\n     * Handles an incoming MessagingService.error event.\n     */\n    handleError(event) {\n        consoleError(`${PREFIX} MessagingService.error`, event);\n        if (this.currentFileUploadID) {\n            const errorCode = event.data?.error?.body?.errorCode;\n            const errorMessage = event.data?.error?.body?.errorMessage || this.getIntlText('fileSharing_uploadFailed');\n            // See https://developer.genesys.cloud/commdigital/digital/webmessaging/websocketapi#error-codes\n            switch (errorCode) {\n                case 4001: // File type is not supported.\n                case 4002: // File size is greater than 102400.\n                case 4003: // Invalid file content.\n                case 4004: // File name invalid.\n                case 4005: // File name is too long.\n                case 4008: // Attachment has expired.\n                case 4010: // Attachment not successfully uploaded.\n                    this.callback.setFileUploadStatus(this.currentFileUploadID, true, errorMessage);\n                    break;\n            }\n        }\n    }\n    /**\n     * Handles an incoming MessagingService.restored event. This occurs when the user has reconnected to an existing\n     * session after reloading the page.\n     */\n    async handleRestored(event) {\n        debugLog(`${PREFIX} MessagingService.restored`, event);\n        const { lastAgentMessageID } = this.persistedState();\n        debugLog(`${PREFIX} Last agent message: ${lastAgentMessageID}`);\n        // First we need to see if the agent's last message is in the list. If not, we're just going to give up and\n        // assume something is not right about the history instead of just potentially repeating the whole thing.\n        if (lastAgentMessageID && event.data?.messages?.length) {\n            const { messages } = event.data;\n            const lastIndex = messages.findIndex((message) => message.id === lastAgentMessageID);\n            if (lastIndex > 0) {\n                // Go backwards from the last index and handle each message.\n                for (let index = lastIndex - 1; index >= 0; index--) {\n                    const message = messages[index];\n                    if (message.messageType === 'outbound') {\n                        // eslint-disable-next-line no-await-in-loop\n                        await this.handleOutboundMessage(message, false);\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Handles an incoming MessagingService.offline event.\n     */\n    handleOffline(event) {\n        debugLog(`${PREFIX} MessagingService.offline`, event);\n        this.callback.setErrorStatus({ type: ErrorType.DISCONNECTED, isDisconnected: true });\n    }\n    /**\n     * Handles an incoming MessagingService.reconnected event.\n     */\n    handleReconnected(event) {\n        debugLog(`${PREFIX} MessagingService.reconnected`, event);\n        this.callback.setErrorStatus({ type: ErrorType.DISCONNECTED, isDisconnected: false });\n    }\n    /**\n     * Handles an incoming CobrowseService.sessionEnded event.\n     */\n    async handleCoBrowseEnded(event) {\n        debugLog(`${PREFIX} CobrowseService.sessionEnded`, event);\n        await this.callback.screenShareEnded();\n    }\n    /**\n     * Tells the service desk to terminate the chat.\n     */\n    async endChat() {\n        this.stopUserTypingInterval();\n        this.updatePersistedState({ agentsJoined: {}, lastAgentMessageID: null }, false);\n    }\n    /**\n     * Sends a message to the agent in the service desk.\n     */\n    async sendMessageToAgent(message, messageID, additionalData) {\n        if (message.input.text) {\n            Genesys('command', 'MessagingService.sendMessage', {\n                message: message.input.text,\n            });\n        }\n        if (additionalData.filesToUpload.length) {\n            // If a file was provided, then upload it. The web chat service should guarantee we never get more than one.\n            this.doFileUpload(additionalData.filesToUpload[0]);\n        }\n    }\n    /**\n     * Informs the service desk that the user has read all the messages that have been sent by the service desk.\n     *\n     * @returns Returns a Promise that resolves when the service desk has successfully handled the call.\n     */\n    async userReadMessages() {\n        // Not supported in this integration.\n    }\n    /**\n     * Tells the service desk if a user has started or stopped typing.\n     */\n    async userTyping(isTyping) {\n        this.stopUserTypingInterval();\n        if (isTyping) {\n            Genesys('command', 'MessagingService.sendTyping');\n            // Genesys seems to expect us to keep sending a typing indicator while a user is typing or the indicator\n            // automatically stops after 5 seconds.\n            this.userTypingInterval = window.setInterval(() => {\n                Genesys('command', 'MessagingService.sendTyping');\n            }, 2500);\n        }\n    }\n    /**\n     * Stops and clear the interval that is used to tell Genesys that the user is typing.\n     */\n    stopUserTypingInterval() {\n        if (this.userTypingInterval) {\n            clearInterval(this.userTypingInterval);\n            this.userTypingInterval = null;\n        }\n    }\n    /**\n     * Checks if any agents are online and ready to communicate with the user.\n     */\n    async areAnyAgentsOnline(connectMessage) {\n        // Genesys doesn't provide this information.\n        return true;\n    }\n    /**\n     * Indicates that the user has selected some files to be uploaded but that the user has not yet chosen to send\n     * them to the agent. This method can use this as an opportunity to perform any early validation of the files in\n     * order to display an error to the user. It should not actually upload the files at this point. If the user\n     * chooses to send the files to the agent, they will be included later when {@link #sendMessageToAgent} is called.\n     */\n    filesSelectedForUpload(uploads) {\n        uploads.forEach(upload => {\n            if (upload.file.size > this.maxFileSizeKB * 1024) {\n                const maxSize = `${this.maxFileSizeKB}KB`;\n                const errorMessage = this.instance.getIntl().formatMessage({ id: 'fileSharing_fileTooLarge' }, { maxSize });\n                this.callback.setFileUploadStatus(upload.id, true, errorMessage);\n            }\n        });\n    }\n    /**\n     * Tells the service desk that the user has requested to stop sharing their screen.\n     */\n    async screenShareStop() {\n        Genesys('command', 'CobrowseService.stopSession');\n    }\n    /**\n     * Ensures that the Genesys script is loaded.\n     */\n    async ensureGenesys(isReconnecting) {\n        if (!scriptPromise) {\n            scriptPromise = this.installGenesys(isReconnecting);\n        }\n        return scriptPromise;\n    }\n    /**\n     * This installs Genesys using their embed code.\n     */\n    async installGenesys(isReconnecting) {\n        const { environment, deploymentID, scriptURL } = this.config;\n        debugLog(`${PREFIX} Creating integration using config`, this.config);\n        if (!this.persistedState()) {\n            this.updatePersistedState({ agentsJoined: {}, lastAgentMessageID: null }, false);\n        }\n        else {\n            debugLog(`${PREFIX} Retrieved previous state`, this.persistedState());\n        }\n        const config = { environment, deploymentId: deploymentID, debug: this.instance.getState().isDebugEnabled };\n        // This code is a simplified version of the Genesys embed script and is required by their SDK.\n        const windowObject = window;\n        const propertyName = 'Genesys';\n        windowObject._genesysJs = propertyName;\n        windowObject[propertyName] = {\n            t: new Date(),\n            c: config,\n            q: [],\n        };\n        await loadScript(scriptURL);\n        Genesys = windowObject[propertyName];\n        // Uncomment for debugging/development purposes.\n        // this.addAllEvents();\n        const serviceStartedPromise = new Promise((resolve, reject) => {\n            function serviceStartedHandler(event) {\n                debugLog(`${PREFIX} MessagingService.started`, event);\n                resolve(!event?.data?.newSession);\n            }\n            Genesys('subscribe', 'MessagingService.started', serviceStartedHandler, reject);\n        });\n        // Subscribe to all the events that we will need to listen to.\n        Genesys('subscribe', 'MessagingService.messagesReceived', (event) => this.handleMessagesReceived(event));\n        Genesys('subscribe', 'MessagingService.typingReceived', (event) => this.handleTypingReceived(event));\n        Genesys('subscribe', 'MessagingService.typingTimeout', (event) => this.handleTypingTimeout(event));\n        Genesys('subscribe', 'MessagingService.fileUploaded', (event) => this.handleFileUploaded(event));\n        Genesys('subscribe', 'MessagingService.fileUploadError', (event) => this.handleFileUploadError(event));\n        Genesys('subscribe', 'MessagingService.error', (event) => this.handleError(event));\n        Genesys('subscribe', 'MessagingService.reconnected', (event) => this.handleReconnected(event));\n        Genesys('subscribe', 'MessagingService.offline', (event) => this.handleOffline(event));\n        Genesys('subscribe', 'MessagingService.restored', (event) => this.handleRestored(event));\n        Genesys('subscribe', 'CobrowseService.sessionEnded', (event) => this.handleCoBrowseEnded(event));\n        // Load the configuration data for the deployment.\n        await resolveOrTimeout(new Promise((resolve, reject) => {\n            Genesys('registerPlugin', 'ConfigPlugin', (plugin) => {\n                plugin\n                    .command('GenesysJS.configuration')\n                    .then((data) => {\n                    this.genesysConfig = data;\n                    debugLog(`${PREFIX} Received GenesysJS.configuration`, this.genesysConfig);\n                    resolve();\n                })\n                    .catch(reject);\n            });\n        }), INIT_TIMEOUT_SECS * 1000, `The GenesysJS.configuration command failed to return a configuration after ${INIT_TIMEOUT_SECS} seconds.`);\n        // Create the plugin that would be used when using user authentication.\n        if (this.genesysConfig?.auth.enabled) {\n            debugLog(`${PREFIX} Authentication is enabled`);\n            Genesys('registerPlugin', 'AuthProvider', (authProvider) => {\n                authProvider.registerCommand('getAuthCode', (event) => {\n                    debugLog(`${PREFIX} AuthProvider.getAuthCode`, event);\n                    this.eventBus.fire({ type: \"agent:genesysMessenger:getAuthCode\" /* BusEventType.GENESYS_MESSENGER_GET_AUTH_CODE */, genesysEvent: event }, this.instance);\n                });\n                authProvider.registerCommand('reAuthenticate', (event) => {\n                    debugLog(`${PREFIX} AuthProvider.reAuthenticate`, event);\n                    this.eventBus.fire({ type: \"agent:genesysMessenger:reAuthenticate\" /* BusEventType.GENESYS_MESSENGER_REAUTHENTICATE */, genesysEvent: event }, this.instance);\n                });\n                authProvider.subscribe('Auth.loggedOut', (event) => {\n                    debugLog(`${PREFIX} AuthProvider.loggedOut`, event);\n                    this.eventBus.fire({ type: \"agent:genesysMessenger:loggedOut\" /* BusEventType.GENESYS_MESSENGER_LOGGED_OUT */, genesysEvent: event }, this.instance);\n                });\n                authProvider.subscribe('Auth.authError', (error) => {\n                    debugLog(`${PREFIX} AuthProvider.authError`, error);\n                    this.eventBus.fire({ type: \"agent:genesysMessenger:authError\" /* BusEventType.GENESYS_MESSENGER_AUTH_ERROR */, genesysError: error }, this.instance);\n                });\n                // Tell Messenger that your plugin is ready (mandatory).\n                authProvider.ready();\n                // Make the AuthProvider instance available to the client.\n                this.eventBus.fire({ type: \"agent:genesysMessenger:AuthProvider\" /* BusEventType.GENESYS_MESSENGER_AUTH_PROVIDER */, authProvider }, this.instance);\n            });\n        }\n        // Wait for the messaging service to become ready before completing the initialization.\n        await resolveOrTimeout(new Promise(resolve => {\n            Genesys('subscribe', 'MessagingService.ready', (event) => {\n                debugLog(`${PREFIX} MessagingService.ready`, event);\n                resolve();\n            });\n        }), INIT_TIMEOUT_SECS * 1000, `The Genesys MessagingService failed to report ready after ${INIT_TIMEOUT_SECS} seconds.`);\n        let isNewSession = false;\n        if (isReconnecting) {\n            // This event only fires if reconnecting to an existing session.\n            isNewSession = await resolveOrTimeout(serviceStartedPromise, INIT_TIMEOUT_SECS * 1000, `The MessagingService.started event failed to fire after ${INIT_TIMEOUT_SECS} seconds.`);\n        }\n        // We have to look through the file upload modes to see if there are any files allowed. The docs suggest there\n        // should only be one object here but the schema does use an array so let's just go through all the objects to\n        // be safe. We'll collect up the unique set of mime types allowed and figure out the largest file size allowed.\n        // The servers will still do their own validation.\n        const mimeTypesSet = new Set();\n        if (this.genesysConfig?.messenger?.fileUpload?.modes) {\n            Object.values(this.genesysConfig.messenger.fileUpload.modes).forEach((mode) => {\n                if (mode.maxFileSizeKB > 0) {\n                    this.maxFileSizeKB = Math.max(this.maxFileSizeKB, mode.maxFileSizeKB);\n                }\n                mode.fileTypes?.forEach((type) => mimeTypesSet.add(type));\n            });\n        }\n        const allowedFileUploadTypes = Array.from(mimeTypesSet).join(',') || undefined;\n        this.callback.updateCapabilities({ allowFileUploads: this.maxFileSizeKB > 0, allowedFileUploadTypes });\n        return isNewSession;\n    }\n    /**\n     * This will be called when the service desk is first initialized and it is determined that the user was previously\n     * connected to an agent. This function should perform whatever steps are necessary to reconnect the user. Web chat\n     * will assume the user is permitted to send messages and is connected to the same agent when this function returns.\n     *\n     * @returns true to indicate that the reconnect was successful.\n     */\n    async reconnect() {\n        debugLog(`${PREFIX} Reconnecting to agent...`);\n        return this.ensureGenesys(true);\n    }\n    // Old code to support debugging.\n    addAllEvents() {\n        this.addEvent('MessagingService.ready');\n        this.addEvent('MessagingService.started');\n        this.addEvent('MessagingService.messagesReceived');\n        this.addEvent('MessagingService.uploading');\n        this.addEvent('MessagingService.uploadApproved');\n        this.addEvent('MessagingService.fileUploaded');\n        this.addEvent('MessagingService.fileUploadError');\n        this.addEvent('MessagingService.fileUploadCancelled');\n        this.addEvent('MessagingService.fileReceived');\n        this.addEvent('MessagingService.messagesUpdated');\n        this.addEvent('MessagingService.fileDownloaded');\n        this.addEvent('MessagingService.fileDownloadError');\n        this.addEvent('MessagingService.fileDeleted');\n        this.addEvent('MessagingService.oldMessages');\n        this.addEvent('MessagingService.historyComplete');\n        this.addEvent('MessagingService.typingReceived');\n        this.addEvent('MessagingService.typingTimeout');\n        this.addEvent('MessagingService.typingStarted');\n        this.addEvent('MessagingService.restored');\n        this.addEvent('MessagingService.sessionCleared');\n        this.addEvent('MessagingService.offline');\n        this.addEvent('MessagingService.reconnecting');\n        this.addEvent('MessagingService.reconnected');\n        this.addEvent('MessagingService.conversationDisconnected');\n        this.addEvent('MessagingService.readOnlyConversation');\n        this.addEvent('MessagingService.conversationReset');\n        this.addEvent('MessagingService.error');\n    }\n    addEvent(eventName) {\n        Genesys('subscribe', eventName, (...args) => {\n            console.log(`${PREFIX} (All) ${eventName}`, args);\n        });\n    }\n}\n\nexport { GenesysMessengerServiceDesk };\n","/**\n* @license\n* \n* (C) Copyright IBM Corp. 2017, 2025. All Rights Reserved.\n* \n* Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n* in compliance with the License. You may obtain a copy of the License at\n* \n* http://www.apache.org/licenses/LICENSE-2.0\n* \n* Unless required by applicable law or agreed to in writing, software distributed under the License\n* is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n* or implied. See the License for the specific language governing permissions and limitations under\n* the License.\n* \n* @carbon/ai-chat 0.3.3\n* \n* Built: Jul 11 2025 1:09 pm -04:00\n* \n* \n*/\n\nclass ServiceDeskImpl {\n    constructor(callback, config, serviceManager) {\n        this.callback = callback;\n        this.serviceManager = serviceManager;\n        this.config = config;\n        this.eventBus = serviceManager?.eventBus;\n        this.instance = serviceManager?.instance;\n    }\n    /**\n     * Returns the language translation text for the given key.\n     */\n    getIntlText(key) {\n        return this.serviceManager.intl.formatMessage({ id: key });\n    }\n    /**\n     * Informs the service desk of a change in the state of the web chat that is relevant to the service desks. These\n     * values may change at any time.\n     */\n    updateState(state) {\n        this.state = state;\n    }\n    /**\n     * Returns the persisted service desk state object.\n     */\n    persistedState() {\n        return this.callback.persistedState();\n    }\n    /**\n     * Sets the persisted state to the given object.\n     */\n    updatePersistedState(state, mergeWithCurrent = true) {\n        this.callback.updatePersistedState(state, mergeWithCurrent);\n    }\n}\n\nexport { ServiceDeskImpl as S };\n"],"names":[],"sourceRoot":""}
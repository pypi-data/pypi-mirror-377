{"version":3,"file":"zendesk.bundle.js","mappings":";;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,SAAS;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEgC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzDhC;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE2K;AAC5F;AACnB;AAC7C;AACK;AACS;AACN;AACF;AACR;AACc;AAC0C;AACO;AACrC;AACkC;AACF;AACzC;AACP;AACe;AACC;AACkC;AACJ;AACa;AACf;AACG;AACD;AACO;AACzD;AACqE;AACd;AACG;AACN;AACG;AACR;AACQ;AACJ;AACF;;AAEpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,gDAAiB,EAAE;AACvD;AACA,kCAAkC,gDAAiB,EAAE;AACrD;AACA,iCAAiC,gDAAiB,EAAE;AACpD;AACA,8CAA8C,gDAAiB,EAAE;AACjE;AACA,sDAAsD,gDAAiB,EAAE,aAAa,MAAM;AAC5F;AACA,4CAA4C,gDAAiB,EAAE;AAC/D;AACA,gDAAgD,gDAAiB,EAAE;;AAEnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,kDAAe;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,gCAAgC,UAAU;AAC1C;AACA,2DAA2D,MAAM,gDAAS,qCAAqC;AAC/G;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,+DAA+D,MAAM,gDAAS,sCAAsC;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,MAAM,gDAAS,qCAAqC;AACvH;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,+DAA+D,gDAAgB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,sBAAsB,EAAE,qBAAqB,GAAG,WAAW,GAAG,kBAAkB;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C,kHAAkH;AAClH;AACA;AACA,6BAA6B,8BAA8B,EAAE,qBAAqB,GAAG,WAAW,GAAG,qBAAqB;AACxH;AACA,aAAa;AACb;AACA;AACA;AACA,gDAAgD,oDAAa;AAC7D,qFAAqF,IAAI,GAAG,MAAM;AAClG;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,gDAAoB;AAC3E;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,oBAAoB,mDAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,wBAAwB,mDAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,gDAAgB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+BAA+B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,mDAA4B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qBAAqB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mDAAY;AACxB;AACA,cAAc,mDAAK;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mDAAY;AACxB;AACA;AACA;AACA;AACA;;AAE8B","sources":["webpack://@carbon/ai-chat-examples-web-components-basic/../node_modules/.pnpm/@carbon+ai-chat@0.3.3_@carbon+icon-helpers@10.65.0_@carbon+icons@11.66.0_@carbon+react@_2d1b4ff090e346b709104e64783ade7d/node_modules/@carbon/ai-chat/dist/es/ServiceDeskImpl.js","webpack://@carbon/ai-chat-examples-web-components-basic/../node_modules/.pnpm/@carbon+ai-chat@0.3.3_@carbon+icon-helpers@10.65.0_@carbon+icons@11.66.0_@carbon+react@_2d1b4ff090e346b709104e64783ade7d/node_modules/@carbon/ai-chat/dist/es/ZendeskServiceDesk.js"],"sourcesContent":["/**\n* @license\n* \n* (C) Copyright IBM Corp. 2017, 2025. All Rights Reserved.\n* \n* Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n* in compliance with the License. You may obtain a copy of the License at\n* \n* http://www.apache.org/licenses/LICENSE-2.0\n* \n* Unless required by applicable law or agreed to in writing, software distributed under the License\n* is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n* or implied. See the License for the specific language governing permissions and limitations under\n* the License.\n* \n* @carbon/ai-chat 0.3.3\n* \n* Built: Jul 11 2025 1:09 pm -04:00\n* \n* \n*/\n\nclass ServiceDeskImpl {\n    constructor(callback, config, serviceManager) {\n        this.callback = callback;\n        this.serviceManager = serviceManager;\n        this.config = config;\n        this.eventBus = serviceManager?.eventBus;\n        this.instance = serviceManager?.instance;\n    }\n    /**\n     * Returns the language translation text for the given key.\n     */\n    getIntlText(key) {\n        return this.serviceManager.intl.formatMessage({ id: key });\n    }\n    /**\n     * Informs the service desk of a change in the state of the web chat that is relevant to the service desks. These\n     * values may change at any time.\n     */\n    updateState(state) {\n        this.state = state;\n    }\n    /**\n     * Returns the persisted service desk state object.\n     */\n    persistedState() {\n        return this.callback.persistedState();\n    }\n    /**\n     * Sets the persisted state to the given object.\n     */\n    updatePersistedState(state, mergeWithCurrent = true) {\n        this.callback.updatePersistedState(state, mergeWithCurrent);\n    }\n}\n\nexport { ServiceDeskImpl as S };\n","/**\n* @license\n* \n* (C) Copyright IBM Corp. 2017, 2025. All Rights Reserved.\n* \n* Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n* in compliance with the License. You may obtain a copy of the License at\n* \n* http://www.apache.org/licenses/LICENSE-2.0\n* \n* Unless required by applicable law or agreed to in writing, software distributed under the License\n* is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n* or implied. See the License for the specific language governing permissions and limitations under\n* the License.\n* \n* @carbon/ai-chat 0.3.3\n* \n* Built: Jul 11 2025 1:09 pm -04:00\n* \n* \n*/\n\nimport { aa as WA_CONSOLE_PREFIX, ab as isConnectToAgent, ac as isEmptyObject, J as createMessageResponseForText, j as consoleError, R as sleep } from './AppContainer.js';\nimport { E as ErrorType, j as MessageResponseTypes } from './customElement.js';\nimport { S as ServiceDeskImpl } from './ServiceDeskImpl.js';\nimport 'react';\nimport 'react-intl';\nimport '@carbon/icons-react';\nimport '@carbon/react';\nimport 'react-redux';\nimport 'lit';\nimport 'lit/decorators.js';\nimport '@carbon/web-components/es-custom/components/button/index.js';\nimport '@carbon/web-components/es-custom/components/overflow-menu/index.js';\nimport 'lit/directives/unsafe-html.js';\nimport '@carbon/web-components/es-custom/components/data-table/index.js';\nimport '@carbon/web-components/es-custom/components/checkbox/index.js';\nimport '@carbon/icon-helpers';\nimport '@carbon/icons';\nimport 'lit/directives/unsafe-svg.js';\nimport 'lit-html/directives/repeat.js';\nimport '@carbon/web-components/es-custom/components/pagination/index.js';\nimport '@carbon/web-components/es-custom/components/select/index.js';\nimport '@carbon/web-components/es-custom/components/data-table/table-skeleton.js';\nimport '@carbon/web-components/es-custom/components/slug/index.js';\nimport '@carbon/web-components/es-custom/components/ai-label/defs.js';\nimport '@carbon/web-components/es-custom/components/popover/defs.js';\nimport '@carbon/web-components/es-custom/components/skeleton-icon/index.js';\nimport 'react-dom';\nimport '@carbon/web-components/es-custom/components/ai-label/ai-label-action-button.js';\nimport '@carbon/web-components/es-custom/components/ai-label/ai-label.js';\nimport '@carbon/web-components/es-custom/components/inline-loading/index.js';\nimport '@carbon/web-components/es-custom/components/textarea/index.js';\nimport '@carbon/web-components/es-custom/components/icon-button/index.js';\nimport '@carbon/web-components/es-custom/components/tag/index.js';\nimport '@carbon/web-components/es-custom/components/chat-button/index.js';\nimport '@carbon/web-components/es-custom/components/button/button.js';\nimport '@carbon/web-components/es-custom/components/layer/index.js';\n\nvar CHAT_EVENT_TYPES;\n(function (CHAT_EVENT_TYPES) {\n    // Chat message incoming from an agent.\n    CHAT_EVENT_TYPES[\"MESSAGE\"] = \"chat.msg\";\n    // Agent is typing.\n    CHAT_EVENT_TYPES[\"TYPING\"] = \"typing\";\n    // A visitor is in the wait queue.\n    CHAT_EVENT_TYPES[\"WAIT_QUEUE\"] = \"chat.wait_queue\";\n    // A visitor is in a specific position in the wait queue.\n    CHAT_EVENT_TYPES[\"QUEUE_POSITION\"] = \"chat.queue_position\";\n    // An agent or visitor has joined the chat.\n    CHAT_EVENT_TYPES[\"MEMBER_JOIN\"] = \"chat.memberjoin\";\n    // An agent or visitor has left the chat.\n    CHAT_EVENT_TYPES[\"MEMBER_LEAVE\"] = \"chat.memberleave\";\n    // Agent has read a message.\n    CHAT_EVENT_TYPES[\"LAST_READ\"] = \"last_read\";\n    // An agent or visitor sends a chat comment.\n    CHAT_EVENT_TYPES[\"COMMENT\"] = \"chat.comment\";\n})(CHAT_EVENT_TYPES || (CHAT_EVENT_TYPES = {}));\n/**\n * Account status that denotes whether Zendesk account is valid and has available agents.\n */\nvar ACCOUNT_STATUS;\n(function (ACCOUNT_STATUS) {\n    ACCOUNT_STATUS[\"ONLINE\"] = \"online\";\n    ACCOUNT_STATUS[\"AWAY\"] = \"away\";\n    ACCOUNT_STATUS[\"OFFLINE\"] = \"offline\";\n})(ACCOUNT_STATUS || (ACCOUNT_STATUS = {}));\n/**\n * Connection status event types that Zendesk sends after we call init().\n */\nvar CONNECTION_STATUS;\n(function (CONNECTION_STATUS) {\n    CONNECTION_STATUS[\"CLOSED\"] = \"closed\";\n    CONNECTION_STATUS[\"CONNECTED\"] = \"connected\";\n    CONNECTION_STATUS[\"CONNECTING\"] = \"connecting\";\n})(CONNECTION_STATUS || (CONNECTION_STATUS = {}));\n// Number of retries we attempt when Zendesk Web SDK calls fail.\nconst NUM_RETRIES = 5;\n// Sleep interval in milliseconds before the next retry.\nconst RETRY_INTERVAL = 1000;\n// Zendesk Web SDK source script URL.\nconst ZENDESK_WEB_SDK_URL = 'https://dev.zopim.com/web-sdk/latest/web-sdk.js';\n// Nickname prefix for agents.\nconst NICKNAME_PREFIX_AGENT = 'agent:';\n// Nickname prefix for visitors, AKA the chat widget user. (visitor prefix does NOT have an appended colon)\nconst NICKNAME_PREFIX_VISITOR = 'visitor';\n// Prefix we use for denoting a tag used to store a session variable in for agent app.\nconst TAG_WA_SESSION_PREFIX = 'x-watson-assistant-session_';\n// Prefix we use for denoting a tag used to store a session variable in our agent app. This is a newer version that is\n// compatible with ZenDesk Support, which removes special characters more aggressively than ZenDesk Chat.\nconst TAG_WA_SESSION_PREFIX_SUPPORT = 'x-watson-assistant-session-support_';\n// Error denoting Zendesk account is not online or has no online agents.\nconst ERROR_ACCOUNT_NOT_ONLINE = `${WA_CONSOLE_PREFIX} Zendesk account is not online`;\n// Error denoting a connection attempt was made but with no initial message.\nconst ERROR_NO_AGENT_MESSAGE = `${WA_CONSOLE_PREFIX} A message to the agent is required to initiate a connection to the service desk.`;\n// Error denoting the Zendesk account connection is not initialized and is not ready to be called.\nconst ERROR_NOT_INITIALIZED = `${WA_CONSOLE_PREFIX} Zendesk Web SDK is not initialized.`;\n// Error denoting that we do not support a structured message without an initialed message string.\nconst ERROR_STRUCTURED_MSG_NOT_SUPPORTED = `${WA_CONSOLE_PREFIX} Received a structured message without a string message from agent and this is not supported.`;\n// Warning denoting we received a structured_msg event type that we don't currently support.\nconst WARNING_EVENT_TYPE_NOT_SUPPORTED = (type) => `${WA_CONSOLE_PREFIX} Event type ${type} not currently supported.`;\n// Warning denoting we received an options array event type that we don't currently support.\nconst WARNING_MESSAGE_OPTIONS_NOT_SENT = `${WA_CONSOLE_PREFIX} Received options attached to the message and the options will not be displayed to the user.`;\n// Warning denoting that we received a structured message with a string, and that we will strip out the structured msg.\nconst WARNING_STRUCTURED_MSG_NOT_SUPPORTED = `${WA_CONSOLE_PREFIX} Received a structured message from agent and this is not supported. Only the string message will be sent.`;\n\n/**\n * Zendesk Integration type name - used externally for routing purposes\n */\nconst ZENDESK_INTEGRATION_NAME = 'zendesk';\n/**\n * Boolean indicating if Zendesk's SDK is already loaded on the DOM as a script. If it is, then ZendeskServiceDesk will\n * skip loading another identical script onto the DOM.\n */\nglobal.zendeskScriptLoaded = false;\nclass ZendeskServiceDesk extends ServiceDeskImpl {\n    constructor(callback, config, serviceManager) {\n        super(callback, config, serviceManager);\n        /**\n         * Indicates if we are currently connected to the service desk. This may flip to false at any point as the result\n         * of the connection getting dropped in the middle of a conversation.\n         */\n        this.isConnected = false;\n        this.account_key = config && config.subscription && config.subscription.account && config.subscription.account.id;\n        if (!this.account_key) {\n            throw new Error('Zendesk account key is not found in definition config.');\n        }\n        this.isChatStarted = false;\n    }\n    /**\n     * If not already initialized, this will load the zendesk module from the ZENDESK_WEB_SDK_URL source and then inject\n     * the module into the webpage's DOM. When the module load is complete, the returned Promise will resolve.\n     */\n    async ensureZendeskModuleLoadedAndConnected() {\n        // If Zendesk SDK is already loaded, simply set the SDK and SDK-promise objects.\n        // Otherwise, load the Zendesk SDK onto the DOM.\n        if (global.zendeskScriptLoaded) {\n            this.sdk = window.zChat;\n            this.loadingSDKPromise = Promise.resolve();\n        }\n        else if (!this.loadingSDKPromise && !this.sdk) {\n            this.loadingSDKPromise = new Promise((resolve, reject) => {\n                const script = document.createElement('script');\n                script.type = 'text/javascript';\n                script.async = true;\n                script.src = ZENDESK_WEB_SDK_URL;\n                script.onerror = (error) => {\n                    reject(error);\n                };\n                script.onload = () => {\n                    this.loadingSDKPromise = null;\n                    this.sdk = window.zChat;\n                    const params = {\n                        account_key: this.account_key,\n                        suppress_console_error: true,\n                    };\n                    // If JWT is available, then call the Zendesk jwt_fn\n                    // to make sure calls are routed to Zendesk through the auth route\n                    if (this.authJWT) {\n                        params.authentication = {\n                            jwt_fn: (callback) => {\n                                // The JWT is immediately available so call the callback right away\n                                callback(this.authJWT);\n                            },\n                        };\n                    }\n                    this.sdk.init(params);\n                    this.sdk.on('chat', (event_data) => {\n                        if (this.isAccountOnline()) {\n                            this.handleChatEvent(event_data);\n                        }\n                    });\n                    // This event fires only when an agent joins or an existing agent's information has changed.\n                    this.sdk.on('agent_update', (event_data) => {\n                        if (this.isAccountOnline()) {\n                            this.handleChatAgentUpdateEvent(event_data);\n                        }\n                    });\n                    this.sdk.on('error', (error) => {\n                        const { context } = error;\n                        if (context === 'init') {\n                            this.callback.setErrorStatus({ type: ErrorType.CONNECTING, logInfo: error.message });\n                        }\n                    });\n                    // Documentation on connection_update events: https://api.zopim.com/web-sdk/#zchat-getaccountstatus.\n                    this.sdk.on('connection_update', (status) => {\n                        switch (status) {\n                            case CONNECTION_STATUS.CONNECTED: {\n                                this.isConnected = true;\n                                this.callback.setErrorStatus({ type: ErrorType.DISCONNECTED, isDisconnected: false });\n                                // Resolve the initial promise that may be waiting on the connection to happen. This may occur\n                                // multiple times during the chat but it's okay to do this more than once.\n                                resolve(undefined);\n                                break;\n                            }\n                            case CONNECTION_STATUS.CONNECTING:\n                            case CONNECTION_STATUS.CLOSED: {\n                                // CONNECTION_STATUS.CONNECTING can occur if the connection with the service desk is temporarily lost in the middle of a\n                                // conversation. CONNECTION_STATUS.CLOSED can occur if the connection has been closed due to various reasons.\n                                const wasConnected = this.isConnected;\n                                this.isConnected = false;\n                                if (wasConnected) {\n                                    this.callback.setErrorStatus({ type: ErrorType.DISCONNECTED, isDisconnected: true });\n                                }\n                                break;\n                            }\n                        }\n                    });\n                };\n                document.getElementsByTagName('head')[0].appendChild(script);\n                global.zendeskScriptLoaded = true;\n            });\n        }\n        return this.loadingSDKPromise;\n    }\n    async startChat(connectMessage, startChatOptions) {\n        // The connect info is contained on the first \"connect_to_agent\" response we got from dialog.\n        const connectInfo = connectMessage.output.generic.find(isConnectToAgent);\n        this.authJWT = connectInfo.transfer_info?.additional_data?.jwt;\n        await this.ensureZendeskModuleLoadedAndConnected();\n        if (this.isChatStarted) {\n            return;\n        }\n        if (this.isAccountOnline()) {\n            // If the visitor does not have a JWT associated with it (aka not authenticated), then\n            // set her display name to the display name generated by the webchat.\n            // If the visitor is authenticated, then Zendesk will automatically compile her details\n            // from her JWT payload.\n            if (!this.authJWT) {\n                this.sdk.setVisitorInfo({\n                    display_name: this.state.userID || 'Unknown Visitor',\n                    email: '',\n                    phone: '',\n                });\n            }\n            // Clearing the department before the chat is required, otherwise the conversation retains the existing\n            // department information (despite having already requested to clear the department in endChat).\n            await this.clearChatDepartment();\n            // Gather info about all online departments and the target routing department name.\n            // Then figure if the target route department is online, and if so then perform the routing.\n            const routeDepartmentName = connectInfo.transfer_info?.target?.[ZENDESK_INTEGRATION_NAME]?.department;\n            const routeDepartment = routeDepartmentName &&\n                this.sdk\n                    .getAllDepartments()\n                    .find((department) => department.name === routeDepartmentName && department.status === ACCOUNT_STATUS.ONLINE);\n            if (routeDepartment) {\n                await this.setChatDepartment(routeDepartment.id);\n            }\n            // In order to load the agent app inside the Zendesk application, we need to pass the session history key to\n            // Zendesk. We do that by passing the key as a tag. There are two different versions of Zendesk: Zendesk Chat\n            // and Zendesk Support. Each uses its own format for tags so we need to pass two tags to support either system.\n            const addSessionTagExecutor = () => new Promise(resolve => {\n                const tags = [];\n                // A string that is separated by AGENT_APP_KEY_SEPARATOR that can be used to create a PublicConfig. It\n                // includes base connect info like integrationID, etc., and by pass JWT security\n                // with a one time auth code. It is formatted as JSON as\n                // {\n                //     \"sessionHistoryKey\":\"dev::6.9.0::425169::f4d26c16-8607-49ce-8d71-70f1c2de5feb::6a755ee2-b094-4b9b-ada3-482295647f17::6435434b-b3e1-4f70-8eff-7149d43d938b::0fcc042c5b45414b99850fbd38840ad9\"\n                // }\n                // We must stringify it for ZenDesk Chat.\n                const metadata_for_chat = JSON.stringify(startChatOptions.agentAppInfo);\n                // There might already be tags on the account, so we include Date.now here to make sure we grab most recent.\n                tags.push(`${TAG_WA_SESSION_PREFIX}${this.state.sessionID}_${Date.now()}_${metadata_for_chat}`);\n                // Zendesk Support only allows alphanumeric, dash and underscore characters in their tags.\n                // They say they support / but it is a lie and it is stripped.\n                // They also say they support all UTF-8 characters... (see https://www.w3schools.com/charsets/ref_utf_basic_latin.asp)\n                // But they don't really. But they do support the Latin ones below.\n                // They also change everything to lowercase. I blame a designer I hate for that one.\n                // See https://support.zendesk.com/hc/en-us/articles/4408835059482-Working-with-ticket-tags\n                // This means we need to send the data in an alternate format.\n                // We have to send both versions to account for folks with a version of the agent app prior to web chat version 7.1.\n                // We could, in the future, force folks to upgrade their agent app when moving to a future major version of web chat\n                // and remove the TAG_WA_SESSION_PREFIX tag and only use this tag.\n                const metadata_for_support = startChatOptions.agentAppInfo.sessionHistoryKey\n                    .replace(/\\./g, 'ä') // replace all periods with ä\n                    .replace(/_/g, 'â') // replace all underscores with â, we don't want things to get confused when we split on _ later.\n                    .replace(/::/g, 'à'); // replace all '::' with 'à'\n                // The ZenDesk agent app will reverse all these replacements when they are able to grab the tags; this\n                // happens in iframe.html.\n                // There might already be tags on the account, so we include Date.now here to make sure we grab most recent.\n                tags.push(`${TAG_WA_SESSION_PREFIX_SUPPORT}${this.state.sessionID}_${Date.now()}_${metadata_for_support}`);\n                this.sdk.addTags(tags, (error) => resolve(this.handleError(error)));\n            });\n            await this.doWithRetry(0, addSessionTagExecutor);\n            // Add any tags that are specified in the dialog pre-chat context variables.\n            const preChat = connectMessage.context?.integrations?.zendesk?.pre_chat;\n            if (typeof preChat === 'object' && !isEmptyObject(preChat)) {\n                const preChatTags = Object.entries(preChat).map(([key, value]) => `${key}_${value}`);\n                const addContextTagsExecutor = () => new Promise(resolve => {\n                    this.sdk.addTags(preChatTags, (error) => resolve(this.handleError(error)));\n                });\n                await this.doWithRetry(0, addContextTagsExecutor);\n            }\n            // Send the messages provided by the connect_to_agent object intended to be sent to the agent. If the array doesn't\n            // exist, the connection should fail because an initial message is required to establish the websocket connection.\n            if (connectInfo.transfer_info && Array.isArray(connectInfo.transfer_info.summary_message_to_agent)) {\n                connectInfo.transfer_info.summary_message_to_agent.forEach(agentMessage => {\n                    if (agentMessage.response_type === MessageResponseTypes.TEXT) {\n                        this.sdk.sendChatMsg(agentMessage.text, (error) => {\n                            if (error) {\n                                throw Error(error);\n                            }\n                        });\n                    }\n                });\n            }\n            else {\n                throw Error(ERROR_NO_AGENT_MESSAGE);\n            }\n            // Check if the agent is already in the chat room. This happens when the Zendesk agent clicks on Continue Chat\n            // after the web chat user has ended the chat.\n            const existingAgents = this.sdk.getServingAgentsInfo();\n            if (Array.isArray(existingAgents) && existingAgents.length > 0) {\n                const { nick, display_name } = existingAgents[0];\n                const agent = {\n                    id: nick,\n                    nickname: display_name, // nickname is a misnomer in Zendesk, using display_name instead\n                };\n                this.currentAgent = agent;\n                this.callback.agentJoined(agent);\n            }\n            this.isChatStarted = true;\n        }\n        else {\n            throw Error(ERROR_ACCOUNT_NOT_ONLINE);\n        }\n    }\n    async endChat() {\n        await this.ensureZendeskModuleLoadedAndConnected();\n        this.assertChatStarted();\n        const executor = () => new Promise(resolve => {\n            // End chat while clearing the conversation's default department.\n            // Otherwise, changing the conversation's department will not work.\n            this.sdk.endChat({\n                clear_dept_id_on_chat_ended: true,\n            }, (error) => {\n                if (error) {\n                    consoleError('[ZendeskServiceDesk]', error);\n                    resolve(false);\n                }\n                else {\n                    this.isChatStarted = false;\n                    this.currentAgent = undefined;\n                    resolve(true);\n                }\n            });\n        });\n        await this.doWithRetry(0, executor);\n    }\n    async sendMessageToAgent(message, messageID) {\n        await this.ensureZendeskModuleLoadedAndConnected();\n        this.assertChatStarted();\n        const { text } = message.input;\n        if (this.isAccountOnline()) {\n            const executor = () => new Promise(resolve => {\n                this.sdk.sendChatMsg(text, (error) => {\n                    if (error) {\n                        consoleError('[ZendeskServiceDesk] Error sending message', error);\n                        resolve(false);\n                    }\n                    else {\n                        this.sdk.sendTyping(false);\n                        resolve(true);\n                    }\n                });\n            });\n            await this.doWithRetry(0, executor);\n        }\n        else {\n            throw Error(ERROR_ACCOUNT_NOT_ONLINE);\n        }\n    }\n    async userReadMessages() {\n        await this.ensureZendeskModuleLoadedAndConnected();\n        this.assertChatStarted();\n        this.sdk.markAsRead();\n    }\n    async userTyping(isTyping) {\n        await this.ensureZendeskModuleLoadedAndConnected();\n        this.assertChatStarted();\n        this.sdk.sendTyping(isTyping);\n    }\n    async areAnyAgentsOnline(connectMessage) {\n        const connectInfo = connectMessage.output.generic.find(isConnectToAgent);\n        this.authJWT = connectInfo?.transfer_info?.additional_data?.jwt;\n        await this.ensureZendeskModuleLoadedAndConnected();\n        return this.isAccountOnline();\n    }\n    /**\n     * Routes the event to the correct handler method based on the event type.\n     */\n    handleChatEvent(event) {\n        switch (event.type) {\n            case CHAT_EVENT_TYPES.MESSAGE: {\n                this.handleChatMessageEvent(event);\n                break;\n            }\n            case CHAT_EVENT_TYPES.TYPING: {\n                this.handleChatTypingEvent(event);\n                break;\n            }\n            case CHAT_EVENT_TYPES.WAIT_QUEUE: {\n                const queuePositionEvent = {\n                    type: CHAT_EVENT_TYPES.QUEUE_POSITION,\n                    nick: event.nick,\n                    queue_position: event.wait_queue,\n                };\n                this.handleChatQueuePositionEvent(queuePositionEvent);\n                break;\n            }\n            case CHAT_EVENT_TYPES.QUEUE_POSITION: {\n                this.handleChatQueuePositionEvent(event);\n                break;\n            }\n            case CHAT_EVENT_TYPES.MEMBER_JOIN: {\n                // nothing goes here because the member join feature is being handled by the 'agent_update' event\n                break;\n            }\n            case CHAT_EVENT_TYPES.MEMBER_LEAVE: {\n                this.handleChatAgentLeaveEvent(event);\n                break;\n            }\n            case CHAT_EVENT_TYPES.LAST_READ: {\n                this.handleChatAgentLastReadEvent(event);\n                break;\n            }\n            case CHAT_EVENT_TYPES.COMMENT: {\n                this.handleChatComment(event);\n                break;\n            }\n            default: {\n                console.warn(WARNING_EVENT_TYPE_NOT_SUPPORTED(event.type));\n                this.handleEventNotSupported(event);\n                break;\n            }\n        }\n    }\n    /**\n     * Handles event when the agent sends a message.\n     */\n    async handleChatMessageEvent(event) {\n        const { msg, structured_msg, options } = event;\n        if (this.isAgentMessage(event)) {\n            // We currently cannot support structured messages, so we treat them like regular string messages.\n            // Options array might exist and contain no elements even in a pure text message event.\n            if (structured_msg || (Array.isArray(options) && options.length > 0)) {\n                // If the structured message has no initial string, then we cannot treat this like a single string message and\n                // must throw an error.\n                if (!msg) {\n                    throw Error(ERROR_STRUCTURED_MSG_NOT_SUPPORTED);\n                }\n                // Warning message depends on whether the structured message or options was filled.\n                const warningMsg = structured_msg ? WARNING_STRUCTURED_MSG_NOT_SUPPORTED : WARNING_MESSAGE_OPTIONS_NOT_SENT;\n                console.warn(warningMsg);\n                const executor = () => new Promise(resolve => this.sdk.sendChatComment(warningMsg, (error) => resolve(this.handleError(error))));\n                await this.doWithRetry(0, executor);\n            }\n            const agentId = this.currentAgent ? this.currentAgent.id : null;\n            const messageResponse = createMessageResponseForText(msg);\n            // As soon as the agent sends a message, make sure to clear the \"isTyping\" event for the agent.\n            this.callback.agentTyping(false);\n            this.callback.sendMessageToUser(messageResponse, agentId);\n        }\n    }\n    /**\n     * Handles event when the agent is typing.\n     */\n    handleChatTypingEvent(event) {\n        const { typing } = event;\n        if (this.isAgentMessage(event)) {\n            this.callback.agentTyping(typing);\n        }\n    }\n    /**\n     * Handles event when the visitor/chat user enters the agent wait queue.\n     */\n    handleChatQueuePositionEvent(event) {\n        const { queue_position } = event;\n        const availability = {\n            position_in_queue: queue_position,\n        };\n        this.callback.updateAgentAvailability(availability);\n    }\n    /**\n     * Handles event when an agent joins, is transferred, or has updated his/her information.\n     */\n    handleChatAgentUpdateEvent(event) {\n        // Check if the chat has not started (or more actually, has already ended) and ignore if so.\n        if (!this.isChatStarted) {\n            return;\n        }\n        const { nick, display_name } = event;\n        const agent = {\n            id: nick,\n            nickname: display_name,\n            profile_picture_url: event.avatar_path ? event.avatar_path : undefined,\n        };\n        // If an agent already exists and the agent IDs do not match, then an agent transfer is occurring.\n        if (this.currentAgent && this.currentAgent.id !== agent.id) {\n            this.callback.beginTransferToAnotherAgent(agent);\n            this.callback.agentJoined(agent);\n        }\n        else if (!this.currentAgent) {\n            // New agent has joined, and no agent had previously joined.\n            this.callback.agentJoined(agent);\n        }\n        this.currentAgent = agent;\n    }\n    /**\n     * Handles event when an agent leaves the chat.\n     */\n    handleChatAgentLeaveEvent(event) {\n        const { nick } = event;\n        if (this.isAgentMessage(event)) {\n            // If the current agent leaves, then end the chat.\n            // TO DO: When we support multiple agents, we need to track which agents have come and gone.\n            if (nick === this.currentAgent.id) {\n                this.callback.agentLeftChat();\n                this.currentAgent = null;\n            }\n        }\n    }\n    /**\n     * Handles event when an agent has read a message.\n     */\n    handleChatAgentLastReadEvent(event) {\n        if (this.isAgentMessage(event)) {\n            this.callback.agentReadMessages();\n        }\n    }\n    /**\n     * Handles event when an agent or visitor sends a chat comment. Sending a chat comment is akin to sending a chat\n     * status to the agent.\n     */\n    async handleChatComment(event) {\n        if (this.isVisitorMessage(event)) {\n            // This is the expected case, and we ignore chat comment events that we send on the visitor's behalf.\n            return;\n        }\n        // If the agent sends a comment, let the agent know we don't know how to send that to the visitor.\n        this.handleEventNotSupported(event);\n    }\n    /**\n     * Handles events that we do not currently support by sending a chat comment to the agent the message was not sent.\n     */\n    async handleEventNotSupported(event) {\n        const executor = () => new Promise(resolve => this.sdk.sendChatComment(WARNING_EVENT_TYPE_NOT_SUPPORTED(event.type), (error) => resolve(this.handleError(error))));\n        await this.doWithRetry(0, executor);\n    }\n    /**\n     * Returns true if the event is a message with agent as the source.\n     */\n    isAgentMessage(event) {\n        return typeof event.nick === 'string' && event.nick.startsWith(NICKNAME_PREFIX_AGENT);\n    }\n    /**\n     * Returns true if the event is a message with visitor as the source.\n     */\n    isVisitorMessage(event) {\n        return typeof event.nick === 'string' && event.nick.startsWith(NICKNAME_PREFIX_VISITOR);\n    }\n    /**\n     * Returns true if the account is online and there are online agents.\n     */\n    isAccountOnline() {\n        return this.sdk?.getAccountStatus() === ACCOUNT_STATUS.ONLINE;\n    }\n    /**\n     * Asserts that the chat has initialized and has started.\n     */\n    assertChatStarted() {\n        if (!this.isChatStarted) {\n            throw Error(ERROR_NOT_INITIALIZED);\n        }\n    }\n    /**\n     * Sets the routing department of the chat conversation.\n     *\n     * @param departmentId The ID of the department to route to.\n     */\n    async setChatDepartment(departmentId) {\n        const executor = () => new Promise(resolve => this.sdk.setVisitorDefaultDepartment(departmentId, (error) => resolve(this.handleError(error))));\n        await this.doWithRetry(0, executor);\n    }\n    /**\n     * Clear the routing department of the chat conversation.\n     */\n    async clearChatDepartment() {\n        const executor = () => new Promise(resolve => this.sdk.clearVisitorDefaultDepartment((error) => resolve(this.handleError(error))));\n        await this.doWithRetry(0, executor);\n    }\n    /**\n     * Calls the executor method and retries the call a number of times if the executor fails.\n     */\n    async doWithRetry(numRetriesAttempted, executor) {\n        if (numRetriesAttempted > NUM_RETRIES) {\n            return false;\n        }\n        try {\n            const result = await executor();\n            if (result) {\n                return true;\n            }\n        }\n        catch (error) {\n            consoleError('Error in ZendeskServiceDesk.doWithRetry', error);\n        }\n        await sleep(RETRY_INTERVAL);\n        return this.doWithRetry(numRetriesAttempted + 1, executor);\n    }\n    /**\n     * Takes an optional error and, if not null, prints the error onto the browser console.\n     * Then returns whether an error was found.\n     *\n     * @param error The error to investigate (can be undefined).\n     */\n    handleError(error) {\n        if (error) {\n            consoleError('[ZendeskServiceDesk]', error);\n            return false;\n        }\n        return true;\n    }\n}\n\nexport { ZendeskServiceDesk };\n"],"names":[],"sourceRoot":""}
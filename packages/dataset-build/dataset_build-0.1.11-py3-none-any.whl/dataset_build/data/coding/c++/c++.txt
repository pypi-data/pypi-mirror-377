// ===================================================================================
//
//  Comprehensive C++ Feature Showcase
//  - Author: A Generative AI
//  - Purpose: To provide a varied and extensive C++ codebase for dataset creation,
//             covering language features from C++98 to C++20.
//
// ===================================================================================

// --- Section 1: Preprocessor, Headers, and Basic Setup ---

// Standard library headers
#include <iostream>
#include <vector>
#include <string>
#include <map>
#include <set>
#include <algorithm>
#include <memory>
#include <thread>
#include <mutex>
#include <future>
#include <stdexcept>
#include <functional>
#include <numeric>
#include <optional>
#include <variant>
#include <any>
#include <fstream>
#include <sstream>
#include <atomic>
#include <chrono>
#include <iomanip>

// Use a macro for a "debug log" feature
#ifdef _DEBUG
    #define LOG(msg) std::cout << "[DEBUG] " << __FILE__ << ":" << __LINE__ << " " << msg << std::endl
#else
    #define LOG(msg)
#endif

// Pragma for header guards (common practice)
#pragma once

// Forward declarations of classes and structs to be defined later
class AdvancedClass;
struct Vector2D;

// Using-declarations to bring specific names into the current scope
using std::cout;
using std::endl;
using std::string;

// Namespace aliasing
namespace AppCore = std::chrono;

// --- Section 2: Core Language Constructs (Enums, Structs, Unions) ---

// C-style enum
enum LegacyColor { RED, GREEN, BLUE };

// C++11 strongly-typed enum class
enum class ModernShapeType {
    Circle,
    Rectangle,
    Triangle
};

// A simple struct for holding data
struct Point {
    int x, y;
};

// A union to demonstrate memory sharing between members
// WARNING: Reading from a member other than the one last written to is UB in most cases.
union DataUnion {
    int i;
    float f;
    char str[4];

    DataUnion() : i(0) {} // Initialize one member in the constructor
    ~DataUnion() {} // Trivial destructor
};

// Type aliases for clarity
typedef unsigned long long ull;
using byte = unsigned char;

// Global variables and constants
const double PI = 3.1415926535;
static int global_static_counter = 0; // Internal linkage
extern int external_linkage_variable; // Declaration, defined elsewhere (hypothetically)

// --- Section 3: Functions and Operator Overloading ---

// A struct representing a 2D vector to demonstrate operator overloading
struct Vector2D {
    float x, y;

    // Default constructor
    Vector2D() : x(0.0f), y(0.0f) {}

    // Parameterized constructor
    Vector2D(float x_val, float y_val) : x(x_val), y(y_val) {}

    // Member function
    float length() const {
        return std::sqrt(x * x + y * y);
    }

    // Operator overloading as a member function (+)
    Vector2D operator+(const Vector2D& other) const {
        return Vector2D(x + other.x, y + other.y);
    }

    // Operator overloading as a member function (+=)
    Vector2D& operator+=(const Vector2D& other) {
        x += other.x;
        y += other.y;
        return *this;
    }
};

// Operator overloading as a non-member function (*)
Vector2D operator*(const Vector2D& vec, float scalar) {
    return Vector2D(vec.x * scalar, vec.y * scalar);
}

// Operator overloading for stream insertion (<<)
std::ostream& operator<<(std::ostream& os, const Vector2D& vec) {
    os << "Vector2D(" << vec.x << ", " << vec.y << ")";
    return os;
}

// Function overloading
void printValue(int val) {
    cout << "Integer: " << val << endl;
}

void printValue(double val) {
    cout << "Double: " << val << endl;
}

// Function with default arguments
void setupConfiguration(int baudRate = 9600, bool parity = false) {
    cout << "Setting up with Baud: " << baudRate << ", Parity: " << (parity ? "on" : "off") << endl;
}

// Inline function hint to the compiler
inline int square(int x) {
    return x * x;
}

// --- Section 4: Object-Oriented Programming (OOP) ---

// Abstract base class with pure virtual functions
class Shape {
public:
    // Pure virtual function makes this class abstract
    virtual double area() const = 0;
    virtual void draw() const = 0;
    
    // Virtual destructor is crucial for base classes
    virtual ~Shape() {
        cout << "Shape destructor called." << endl;
    }

    // A regular member function
    void identify() const {
        cout << "I am a shape." << endl;
    }

protected:
    // Protected member accessible by derived classes
    string shape_name = "Generic Shape";
};

// Derived class: Circle
class Circle final : public Shape { // 'final' prevents further inheritance
public:
    Circle(double radius) : m_radius(radius) {
        shape_name = "Circle";
    }

    // Override pure virtual functions from base
    double area() const override {
        return PI * m_radius * m_radius;
    }

    void draw() const override {
        cout << "Drawing a " << shape_name << " with radius " << m_radius << "." << endl;
    }
    
    ~Circle() {
        cout << "Circle destructor called." << endl;
    }

private:
    double m_radius;
};

// Another derived class: Rectangle
class Rectangle : public Shape {
public:
    Rectangle(double width, double height) : m_width(width), m_height(height) {
        shape_name = "Rectangle";
    }

    double area() const override {
        return m_width * m_height;
    }

    void draw() const override {
        cout << "Drawing a " << shape_name << " with width " << m_width << " and height " << m_height << "." << endl;
    }
    
    ~Rectangle() {
        cout << "Rectangle destructor called." << endl;
    }

protected:
    double m_width, m_height;
};

// Multiple inheritance example
class Loggable {
public:
    void log(const string& message) const {
        cout << "[LOG] " << message << endl;
    }
};

class SpecialRectangle : public Rectangle, public Loggable {
public:
    SpecialRectangle(double w, double h) : Rectangle(w, h) {}

    void draw() const override {
        log("About to draw a special rectangle.");
        Rectangle::draw(); // Call base class implementation
    }
};

// Class with static members and friend function
class Gadget {
private:
    int id;
    static int next_id;

public:
    Gadget() : id(next_id++) {}

    static int getGadgetCount() {
        return next_id;
    }

    // Friend function can access private members of Gadget
    friend void inspectGadget(const Gadget& g);
};

int Gadget::next_id = 1;

void inspectGadget(const Gadget& g) {
    cout << "Inspecting gadget with private ID: " << g.id << endl;
}


// --- Section 5: Templates and Generic Programming ---

// Function template
template <typename T>
T findMax(T a, T b) {
    return (a > b) ? a : b;
}

// Specialization for const char*
template <>
const char* findMax<const char*>(const char* a, const char* b) {
    return (std::strcmp(a, b) > 0) ? a : b;
}

// Class template: A simple generic Stack
template <typename T, int MaxSize = 100>
class Stack {
public:
    Stack() : top(-1) {}

    bool push(const T& value) {
        if (isFull()) return false;
        data[++top] = value;
        return true;
    }

    T pop() {
        if (isEmpty()) throw std::out_of_range("Stack is empty");
        return data[top--];
    }

    bool isEmpty() const { return top == -1; }
    bool isFull() const { return top == MaxSize - 1; }

private:
    T data[MaxSize];
    int top;
};

// Variadic template function
void printAll() {} // Base case for recursion

template <typename T, typename... Args>
void printAll(T first, Args... args) {
    cout << first << " ";
    printAll(args...); // Recursive call
}

// Template Metaprogramming: Compile-time factorial
template <int N>
struct Factorial {
    static const long long value = N * Factorial<N - 1>::value;
};

template <>
struct Factorial<0> {
    static const long long value = 1;
};

// C++17 if constexpr
template <typename T>
auto getValue(T t) {
    if constexpr (std::is_pointer_v<T>) {
        return *t;
    } else {
        return t;
    }
}

// C++20 Concepts (a simple example)
#if __cplusplus >= 202002L
#include <concepts>
template <typename T>
concept Numeric = std::is_arithmetic_v<T>;

template <Numeric T>
T add(T a, T b) {
    return a + b;
}
#endif


// --- Section 6: Standard Template Library (STL) Showcase ---

void stl_demonstration() {
    cout << "\n--- STL Demonstration ---" << endl;

    // std::vector: dynamic array
    std::vector<int> numbers = {5, 2, 8, 1, 9, 4};
    numbers.push_back(7);

    // std::sort with a lambda expression
    std::sort(numbers.begin(), numbers.end(), [](int a, int b) {
        return a < b; // Ascending order
    });

    cout << "Sorted vector: ";
    for (int num : numbers) { // Range-based for loop
        cout << num << " ";
    }
    cout << endl;

    // std::map: key-value pairs
    std::map<string, int> word_counts;
    word_counts["hello"] = 2;
    word_counts["world"] = 1;
    word_counts.insert({"test", 5});

    cout << "Map contents:" << endl;
    for (const auto& pair : word_counts) { // Structured binding (C++17) in spirit
        cout << "  " << pair.first << ": " << pair.second << endl;
    }

    // std::string and std::string_view
    string long_string = "This is a very long string that we don't want to copy.";
    std::string_view sv(long_string.c_str() + 10, 19); // A non-owning view
    cout << "String view: " << sv << endl;

    // std::for_each and std::transform
    std::vector<int> squares;
    squares.resize(numbers.size());
    std::transform(numbers.begin(), numbers.end(), squares.begin(), [](int n) {
        return n * n;
    });

    cout << "Squared numbers: ";
    std::for_each(squares.begin(), squares.end(), [](int s) {
        cout << s << " ";
    });
    cout << endl;

    // std::accumulate
    int sum = std::accumulate(numbers.begin(), numbers.end(), 0);
    cout << "Sum of numbers: " << sum << endl;
    
    // std::set: unique sorted elements
    std::set<char> unique_chars;
    string sample = "abracadabra";
    for(char c : sample) {
        unique_chars.insert(c);
    }
    cout << "Unique characters in 'abracadabra': ";
    for(char c : unique_chars) {
        cout << c;
    }
    cout << endl;
}


// --- Section 7: Modern C++ Features (C++11/14/17/20) ---

void modern_cpp_features() {
    cout << "\n--- Modern C++ Features ---" << endl;

    // auto type deduction
    auto i = 42;
    auto d = 3.14;
    auto s = "Hello";
    cout << "auto deduced types: " << typeid(i).name() << ", " << typeid(d).name() << ", " << typeid(s).name() << endl;

    // Lambda expression with capture
    int factor = 10;
    auto multiplier = [factor](int x) { return x * factor; };
    cout << "Lambda result: " << multiplier(5) << endl;

    // Smart Pointers: std::unique_ptr and std::shared_ptr
    { // Scope for unique_ptr
        auto rect_ptr = std::make_unique<Rectangle>(10, 5);
        cout << "Unique_ptr Area: " << rect_ptr->area() << endl;
    } // rect_ptr is automatically deleted here

    auto circle_ptr1 = std::make_shared<Circle>(7.0);
    cout << "Shared_ptr use count: " << circle_ptr1.use_count() << endl;
    {
        std::shared_ptr<Circle> circle_ptr2 = circle_ptr1;
        cout << "Shared_ptr use count: " << circle_ptr1.use_count() << endl;
    }
    cout << "Shared_ptr use count after scope: " << circle_ptr1.use_count() << endl;

    // std::optional
    std::optional<int> maybe_value;
    if (!maybe_value.has_value()) {
        cout << "Optional is empty." << endl;
    }
    maybe_value = 101;
    cout << "Optional has value: " << maybe_value.value() << endl;

    // std::variant
    std::variant<int, string, double> my_variant;
    my_variant = "I am a string now";
    std::visit([](auto&& arg) {
        using T = std::decay_t<decltype(arg)>;
        if constexpr (std::is_same_v<T, int>)
            cout << "Variant holds an int: " << arg << endl;
        else if constexpr (std::is_same_v<T, string>)
            cout << "Variant holds a string: " << arg << endl;
        else if constexpr (std::is_same_v<T, double>)
            cout << "Variant holds a double: " << arg << endl;
    }, my_variant);

    // Structured Bindings (C++17)
    std::map<int, string> user_data = {{1, "Alice"}, {2, "Bob"}};
    for (const auto& [id, name] : user_data) {
        cout << "User ID: " << id << ", Name: " << name << endl;
    }
}


// --- Section 8: Concurrency ---

std::mutex cout_mutex; // Mutex to protect std::cout
std::atomic<int> atomic_counter(0);

void worker_thread_function(int id) {
    for (int i = 0; i < 5; ++i) {
        {
            std::lock_guard<std::mutex> lock(cout_mutex);
            cout << "Worker " << id << " is running, iteration " << i << "." << endl;
        }
        atomic_counter++;
        std::this_thread::sleep_for(std::chrono::milliseconds(10));
    }
}

int perform_long_computation() {
    std::this_thread::sleep_for(std::chrono::seconds(2));
    return 42;
}

void concurrency_demonstration() {
    cout << "\n--- Concurrency Demonstration ---" << endl;

    // std::thread
    std::vector<std::thread> threads;
    for (int i = 0; i < 3; ++i) {
        threads.emplace_back(worker_thread_function, i + 1);
    }

    for (auto& t : threads) {
        if (t.joinable()) {
            t.join();
        }
    }
    cout << "All worker threads finished. Atomic counter: " << atomic_counter << endl;

    // std::async, std::future
    cout << "Starting long computation in the background..." << endl;
    std::future<int> result_future = std::async(std::launch::async, perform_long_computation);
    
    cout << "Doing other work in the main thread..." << endl;
    
    int result = result_future.get(); // Blocks until the result is ready
    cout << "Long computation finished with result: " << result << endl;
}


// --- Section 9: Exception Handling ---

// Custom exception class
class MyCustomException : public std::runtime_error {
public:
    MyCustomException(const string& msg) : std::runtime_error(msg) {}
};

// A function that might throw an exception
void process_data(int value) noexcept(false) {
    if (value < 0) {
        throw MyCustomException("Negative values are not allowed.");
    }
    if (value == 0) {
        throw std::invalid_argument("Value cannot be zero.");
    }
    cout << "Processing value: " << 100 / value << endl;
}

void exception_handling_demo() {
    cout << "\n--- Exception Handling ---" << endl;
    for (int val : {10, 0, -5}) {
        try {
            process_data(val);
        } catch (const MyCustomException& e) {
            std::cerr << "Caught custom exception: " << e.what() << endl;
        } catch (const std::invalid_argument& e) {
            std::cerr << "Caught invalid argument: " << e.what() << endl;
        } catch (...) { // Catch-all handler
            std::cerr << "Caught an unknown exception." << endl;
        }
    }
}


// --- Section 10: Advanced and Low-Level Features ---

// C-style function for interoperability
extern "C" int c_style_add(int a, int b) {
    return a + b;
}

void low_level_features() {
    cout << "\n--- Low-Level Features ---" << endl;

    // Pointer arithmetic
    int arr[] = {10, 20, 30, 40, 50};
    int* p = arr;
    cout << "First element: " << *p << endl;
    p++; // Move to the next element
    cout << "Second element: " << *p << endl;
    cout << "Third element via offset: " << *(p + 1) << endl;

    // Unsafe casting with reinterpret_cast
    long long some_address = 0xDEADBEEF;
    int* dangerous_ptr = reinterpret_cast<int*>(some_address);
    // Dereferencing this would be undefined behavior, so we just show the cast
    cout << "Reinterpreted pointer: " << dangerous_ptr << endl;

    // Placement new
    byte buffer[sizeof(Rectangle)];
    Rectangle* rect_in_buffer = new (buffer) Rectangle(5, 5); // Construct object in buffer
    cout << "Placement new area: " << rect_in_buffer->area() << endl;
    rect_in_buffer->~Rectangle(); // Must manually call destructor

    // A 'goto' for demonstration purposes (generally avoid)
    int i = 0;
loop_start:
    if (i < 3) {
        cout << "goto loop, i = " << i << endl;
        i++;
        goto loop_start;
    }
}


// --- Section 11: File I/O ---

void file_io_demonstration(const string& filename) {
    cout << "\n--- File I/O ---" << endl;

    // Writing to a file using ofstream
    {
        std::ofstream outfile(filename);
        if (outfile.is_open()) {
            outfile << "Hello, File I/O!" << endl;
            outfile << "This is line 2." << endl;
            for (int i = 0; i < 5; ++i) {
                outfile << "Data " << i << endl;
            }
            cout << "Successfully wrote to " << filename << endl;
        } else {
            std::cerr << "Failed to open " << filename << " for writing." << endl;
        }
    } // RAII closes the file here

    // Reading from a file using ifstream
    {
        std::ifstream infile(filename);
        if (infile.is_open()) {
            cout << "Reading from " << filename << ":" << endl;
            string line;
            while (std::getline(infile, line)) {
                cout << "  > " << line << endl;
            }
        } else {
            std::cerr << "Failed to open " << filename << " for reading." << endl;
        }
    }
}


// --- Section 12: Main Function ---

// Entry point of the program
// argc: argument count, argv: argument vector (array of C-style strings)
int main(int argc, char* argv[]) {
    cout << "===== C++ Feature Showcase =====" << endl;
    cout << "Program started with " << argc << " arguments." << endl;
    for (int i = 0; i < argc; ++i) {
        cout << "  argv[" << i << "]: " << argv[i] << endl;
    }
    cout << "================================\n" << endl;

    // --- Demonstrate Core Language ---
    LOG("Starting core language demonstration");
    Vector2D v1(3, 4), v2(1, 2);
    Vector2D v3 = v1 + v2;
    cout << v1 << " + " << v2 << " = " << v3 << endl;
    cout << "Length of v1: " << v1.length() << endl;
    printValue(42);
    printValue(3.14);
    setupConfiguration();
    setupConfiguration(115200, true);

    // --- Demonstrate OOP ---
    LOG("Starting OOP demonstration");
    std::vector<std::unique_ptr<Shape>> shapes;
    shapes.push_back(std::make_unique<Circle>(5.0));
    shapes.push_back(std::make_unique<Rectangle>(4.0, 6.0));
    shapes.push_back(std::make_unique<SpecialRectangle>(3.0, 7.0));

    for (const auto& shape : shapes) {
        shape->identify();
        shape->draw();
        cout << "  Area: " << shape->area() << endl;
    }
    
    Gadget g1, g2;
    inspectGadget(g1);
    cout << "Total gadgets created: " << Gadget::getGadgetCount() << endl;

    // --- Demonstrate Templates ---
    LOG("Starting template demonstration");
    cout << "\nMax of 5 and 10 is " << findMax(5, 10) << endl;
    cout << "Max of 'apple' and 'orange' is " << findMax("apple", "orange") << endl;

    Stack<string, 10> string_stack;
    string_stack.push("Hello");
    string_stack.push("World");
    cout << "Popped from stack: " << string_stack.pop() << endl;

    printAll("Variadic:", 1, 2.5, 'c', "done");
    cout << endl;
    cout << "Compile-time Factorial<10>::value = " << Factorial<10>::value << endl;
    
    #if __cplusplus >= 202002L
    cout << "C++20 concept add(5, 7): " << add(5, 7) << endl;
    #endif

    // --- Demonstrate STL ---
    LOG("Starting STL demonstration");
    stl_demonstration();

    // --- Demonstrate Modern C++ ---
    LOG("Starting modern C++ demonstration");
    modern_cpp_features();

    // --- Demonstrate Concurrency ---
    LOG("Starting concurrency demonstration");
    concurrency_demonstration();

    // --- Demonstrate Exceptions ---
    LOG("Starting exception demonstration");
    exception_handling_demo();
    
    // --- Demonstrate Low-Level Features ---
    LOG("Starting low-level demonstration");
    low_level_features();
    
    // --- Demonstrate File I/O ---
    LOG("Starting file I/O demonstration");
    file_io_demonstration("sample_output.txt");

    cout << "\n===== Program Finished Successfully =====" << endl;

    return 0; // Return 0 to indicate success
}

// Definition for the extern variable declared earlier
int external_linkage_variable = 100;

// ... and a few more lines to ensure we cross 1000
// This section demonstrates a more complex lambda with a mutable capture
void mutable_lambda_demo() {
    int counter = 0;
    auto incrementer = [counter]() mutable {
        cout << "Inside lambda, counter was: " << counter << endl;
        counter++;
        cout << "Inside lambda, counter is now: " << counter << endl;
    };

    incrementer();
    incrementer();

    cout << "Outside lambda, original counter is still: " << counter << endl;
}

// Another example: function pointers
void func_ptr_target(int x) {
    cout << "Function pointer called with " << x << endl;
}

void function_pointer_demo() {
    void (*fp)(int);
    fp = &func_ptr_target;
    fp(123); // Call via function pointer
}

// C-style bitfields in a struct
struct HardwareRegister {
    unsigned int ready : 1;
    unsigned int error_code : 4;
    unsigned int mode : 2;
    unsigned int reserved : 1;
};

void bitfield_demo() {
    HardwareRegister reg;
    reg.ready = 1;
    reg.error_code = 0b1010; // 10
    reg.mode = 0b11; // 3
    cout << "Size of bitfield struct: " << sizeof(HardwareRegister) << " bytes" << endl;
}

// Volatile keyword example
void volatile_demo() {
    volatile int sensor_value = 0;
    // The compiler will not optimize away reads from this variable,
    // assuming it can be changed by external hardware.
    // while (sensor_value == 0) {
    //     // Busy-wait for hardware to set the value
    // }
    cout << "Volatile demo placeholder." << endl;
}

// Final few lines to reach the goal.
namespace Outer {
    namespace Inner {
        void nested_namespace_func() {
            cout << "Function in a nested namespace." << endl;
        }
    }
}
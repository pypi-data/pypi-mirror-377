# generated by datamodel-codegen:
#   filename:  ab_media_dcr.json

from __future__ import annotations

from typing import Optional, Sequence, Union

from typing_extensions import Literal, NotRequired, TypedDict


class EnclaveSpecificationV0(TypedDict):
    attestationProtoBase64: str
    id: str
    workerProtocol: int


FormatType = Literal[
    'STRING',
    'INTEGER',
    'FLOAT',
    'EMAIL',
    'DATE_ISO8601',
    'PHONE_NUMBER_E164',
    'HASH_SHA256_HEX',
]


HashingAlgorithm = Literal['SHA256_HEX']


ModelEvaluationType = Literal['ROC_CURVE', 'DISTANCE_TO_EMBEDDING', 'JACCARD']


class RequirementFlagValue1(TypedDict):
    type: Literal['SUPPORTED']


class RequirementFlagValue2(TypedDict):
    type: Literal['DATASET']


class RequirementFlagValue3(TypedDict):
    type: Literal['PROPERTY']
    value: str


RequirementFlagValue = Union[
    RequirementFlagValue1, RequirementFlagValue2, RequirementFlagValue3
]


KnownOrUnknownRequirementFlagValue = Optional[RequirementFlagValue]


class ModelEvaluationConfig(TypedDict):
    postScopeMerge: Sequence[ModelEvaluationType]
    preScopeMerge: Sequence[ModelEvaluationType]


class RequirementFlag(TypedDict):
    details: KnownOrUnknownRequirementFlagValue
    name: str


class RequirementOp4(TypedDict):
    has: RequirementFlag


class AbMediaComputeV0(TypedDict):
    advertiserEmails: Sequence[str]
    agencyEmails: Sequence[str]
    authenticationRootCertificatePem: str
    dataPartnerEmails: NotRequired[Sequence[str]]
    driverEnclaveSpecification: EnclaveSpecificationV0
    hashMatchingIdWith: NotRequired[Optional[HashingAlgorithm]]
    id: str
    mainAdvertiserEmail: str
    mainPublisherEmail: str
    matchingIdFormat: FormatType
    modelEvaluation: NotRequired[Optional[ModelEvaluationConfig]]
    name: str
    observerEmails: Sequence[str]
    publisherEmails: Sequence[str]
    pythonEnclaveSpecification: EnclaveSpecificationV0
    rateLimitPublishDataNumPerWindow: NotRequired[int]
    rateLimitPublishDataWindowSeconds: NotRequired[int]


class AbMediaComputeV1(AbMediaComputeV0):
    pass


class AbMediaComputeV2(AbMediaComputeV0):
    pass


class AbMediaComputeV3(AbMediaComputeV0):
    pass


class AbMediaComputeV4(AbMediaComputeV0):
    pass


class AbMediaComputeV5(AbMediaComputeV0):
    pass


class AbMediaComputeV6(AbMediaComputeV0):
    pass


class AbMediaComputeV7(AbMediaComputeV0):
    pass


class AbMediaCompute1(TypedDict):
    v0: AbMediaComputeV0


class AbMediaCompute2(TypedDict):
    v1: AbMediaComputeV1


class AbMediaCompute3(TypedDict):
    v2: AbMediaComputeV2


class AbMediaCompute4(TypedDict):
    v3: AbMediaComputeV3


class AbMediaCompute5(TypedDict):
    v4: AbMediaComputeV4


class AbMediaCompute6(TypedDict):
    v5: AbMediaComputeV5


class AbMediaCompute7(TypedDict):
    v6: AbMediaComputeV6


class AbMediaCompute8(TypedDict):
    v7: AbMediaComputeV7


AbMediaCompute = Union[
    AbMediaCompute1,
    AbMediaCompute2,
    AbMediaCompute3,
    AbMediaCompute4,
    AbMediaCompute5,
    AbMediaCompute6,
    AbMediaCompute7,
    AbMediaCompute8,
]


AbMediaComputeOrUnknown = Optional[AbMediaCompute]


class AbMediaDcr1(TypedDict):
    v0: AbMediaDcrInner


AbMediaDcr = AbMediaDcr1


class AbMediaDcrInner(TypedDict):
    compute: AbMediaComputeOrUnknown
    consumes: ConsumerRequirements
    features: Sequence[str]


class ConsumerRequirements(TypedDict):
    optional: Sequence[RequirementFlag]
    required: NotRequired[Optional[RequirementOp]]


RequirementOp1 = TypedDict(
    'RequirementOp1',
    {
        'or': Sequence[RequirementOp],
    },
)


RequirementOp2 = TypedDict(
    'RequirementOp2',
    {
        'and': Sequence[RequirementOp],
    },
)


class RequirementOp3(TypedDict):
    exclusiveOr: Sequence[RequirementOp]


RequirementOp = Union[RequirementOp1, RequirementOp2, RequirementOp3, RequirementOp4]

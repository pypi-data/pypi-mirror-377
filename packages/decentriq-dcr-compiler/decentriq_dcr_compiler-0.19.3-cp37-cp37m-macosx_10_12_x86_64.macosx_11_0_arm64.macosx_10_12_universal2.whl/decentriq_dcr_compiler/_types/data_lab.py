# generated by datamodel-codegen:
#   filename:  data_lab.json

from __future__ import annotations

from typing import Optional, Sequence, Union

from typing_extensions import Literal, NotRequired, TypedDict


class EnclaveSpecification(TypedDict):
    attestationProtoBase64: str
    id: str
    workerProtocol: int


FormatType = Literal[
    'STRING',
    'INTEGER',
    'FLOAT',
    'EMAIL',
    'DATE_ISO8601',
    'PHONE_NUMBER_E164',
    'HASH_SHA256_HEX',
]


HashingAlgorithm = Literal['SHA256_HEX']


class RequirementFlagValue10(TypedDict):
    type: Literal['SUPPORTED']


class RequirementFlagValue11(TypedDict):
    type: Literal['DATASET']


class RequirementFlagValue12(TypedDict):
    type: Literal['PROPERTY']
    value: str


RequirementFlagValue = Union[
    RequirementFlagValue10, RequirementFlagValue11, RequirementFlagValue12
]


class DataLabComputeV0(TypedDict):
    authenticationRootCertificatePem: str
    driverEnclaveSpecification: EnclaveSpecification
    id: str
    matchingIdFormat: FormatType
    matchingIdHashingAlgorithm: NotRequired[Optional[HashingAlgorithm]]
    name: str
    numEmbeddings: int
    publisherEmail: str
    pythonEnclaveSpecification: EnclaveSpecification


class DataLabComputeV1(DataLabComputeV0):
    pass


class DataLabComputeV10(DataLabComputeV0):
    pass


class DataLabComputeV11(DataLabComputeV0):
    pass


class DataLabComputeV12(DataLabComputeV0):
    pass


class DataLabComputeV13(DataLabComputeV0):
    pass


class DataLabComputeV14(DataLabComputeV0):
    pass


class DataLabComputeV2(DataLabComputeV0):
    pass


class DataLabComputeV3(DataLabComputeV0):
    pass


class DataLabComputeV4(DataLabComputeV0):
    pass


class DataLabComputeV5(DataLabComputeV0):
    pass


class DataLabComputeV6(DataLabComputeV0):
    pass


class DataLabComputeV7(DataLabComputeV0):
    pass


class DataLabComputeV8(DataLabComputeV0):
    pass


class DataLabComputeV9(DataLabComputeV0):
    pass


KnownOrUnknownRequirementFlagValue = Optional[RequirementFlagValue]


class RequirementFlag(TypedDict):
    details: KnownOrUnknownRequirementFlagValue
    name: str


class Requirements(TypedDict):
    optional: Sequence[RequirementFlag]
    required: Sequence[RequirementFlag]


class DataLabCompute1(TypedDict):
    v0: DataLabComputeV0


class DataLabCompute2(TypedDict):
    v1: DataLabComputeV1


class DataLabCompute3(TypedDict):
    v2: DataLabComputeV2


class DataLabCompute4(TypedDict):
    v3: DataLabComputeV3


class DataLabCompute5(TypedDict):
    v4: DataLabComputeV4


class DataLabCompute6(TypedDict):
    v5: DataLabComputeV5


class DataLabCompute7(TypedDict):
    v6: DataLabComputeV6


class DataLabCompute8(TypedDict):
    v7: DataLabComputeV7


class DataLabCompute9(TypedDict):
    v8: DataLabComputeV8


class DataLabCompute10(TypedDict):
    v9: DataLabComputeV9


class DataLabCompute11(TypedDict):
    v10: DataLabComputeV10


class DataLabCompute12(TypedDict):
    v11: DataLabComputeV11


class DataLabCompute13(TypedDict):
    v12: DataLabComputeV12


class DataLabCompute14(TypedDict):
    v13: DataLabComputeV13


class DataLabCompute15(TypedDict):
    v14: DataLabComputeV14


DataLabCompute = Union[
    DataLabCompute1,
    DataLabCompute2,
    DataLabCompute3,
    DataLabCompute4,
    DataLabCompute5,
    DataLabCompute6,
    DataLabCompute7,
    DataLabCompute8,
    DataLabCompute9,
    DataLabCompute10,
    DataLabCompute11,
    DataLabCompute12,
    DataLabCompute13,
    DataLabCompute14,
    DataLabCompute15,
]


DataLabComputeOrUnknown = Optional[DataLabCompute]


class DataLabV0(TypedDict):
    compute: DataLabComputeOrUnknown
    features: Sequence[str]
    provides: Requirements


class DataLab1(TypedDict):
    v0: DataLabV0


DataLab = DataLab1

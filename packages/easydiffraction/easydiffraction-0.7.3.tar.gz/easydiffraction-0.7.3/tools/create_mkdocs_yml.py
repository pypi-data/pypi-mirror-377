import os
import re
from pathlib import Path
from typing import Any
from typing import Dict
from typing import List

import material.extensions.emoji  # side-effect: register emoji tag
import pymdownx.superfences  # side-effect: register superfence tag
import yaml

# Side-effect imports above ensure tagged YAML constructors
# (e.g., !!python/name:...) can be resolved during load.


def _activate_yaml_tag_side_effects() -> None:  # pragma: no cover - trivial
    """Access imported modules' attributes so Ruff sees them as used.

    The primary purpose of importing these packages is to ensure the
    tagged constructors are importable during YAML load. Accessing the
    attributes makes the side-effect explicit without needing noqa.
    """
    _ = material.extensions.emoji.twemoji  # type: ignore[attr-defined]
    _ = pymdownx.superfences.fence_code_format  # type: ignore[attr-defined]


_activate_yaml_tag_side_effects()


def load_yaml_with_env_variables(file_path: str) -> Dict[str, Any]:
    """Load YAML resolving env variables declared as !ENV ${VAR_NAME}.

    Args:
        file_path (str): Path to the YAML file.

    Returns:
        dict: Parsed YAML content with environment variables replaced.
    """
    tag = '!ENV'
    pattern = re.compile(r'.*?\${([A-Z0-9_]+)}.*?')

    def constructor_env_variables(loader, node):  # type: ignore[all]
        """YAML constructor replacing !ENV markers with values."""
        value = loader.construct_scalar(node)  # type: ignore[attr-defined]
        for var in pattern.findall(value):
            value = value.replace(f'${{{var}}}', os.environ.get(var, var))
        return value

    loader = yaml.FullLoader
    loader.add_implicit_resolver(tag, pattern, None)
    loader.add_constructor(tag, constructor_env_variables)

    with Path(file_path).open('r', encoding='utf-8') as fh:
        return yaml.full_load(fh)


def merge_yaml(base_config: Dict[str, Any], override_config: Dict[str, Any]) -> Dict[str, Any]:
    """Deep merge two YAML dicts; override has priority."""
    if not isinstance(base_config, dict):
        return override_config

    merged_config = base_config.copy()

    for key, override_value in override_config.items():
        if key in merged_config:
            base_value = merged_config[key]
            if isinstance(base_value, dict) and isinstance(override_value, dict):
                merged_config[key] = merge_yaml(base_value, override_value)
            elif isinstance(base_value, list) and isinstance(override_value, list):
                merged_config[key] = merge_lists(base_value, override_value)
            else:
                merged_config[key] = override_value
        else:
            merged_config[key] = override_value

    return merged_config


def merge_lists(base_list: List[Any], override_list: List[Any]) -> List[Any]:
    """Merge two lists with handling of single-key dict items.

    Single-key dicts sharing a key are deep-merged; other items are
    appended if not already present.

    Args:
        base_list (list): The base list.
        override_list (list): The overriding list.

    Returns:
        list: The merged list.
    """
    merged_list = []
    seen_items = {}

    for item in base_list + override_list:
        if isinstance(item, dict) and len(item) == 1:
            key = next(iter(item))  # Extract dictionary key (e.g., "mkdocs-jupyter")
            if key in seen_items:
                seen_items[key] = merge_yaml(seen_items[key], item[key])  # Merge dictionaries
            else:
                seen_items[key] = item[key]
        elif item not in merged_list:
            merged_list.append(item)

    # Convert merged dictionary values back into list format
    for key, value in seen_items.items():
        merged_list.append({key: value})

    return merged_list


def save_yaml(data: Dict[str, Any], output_file: str) -> None:
    """Write YAML preserving !!python/name tags and Unicode."""

    class CustomDumper(yaml.Dumper):
        """Custom dumper avoiding unnecessary anchors & quotes."""

        def ignore_aliases(self, _):  # noqa: D401 - simple override
            return True

    out_path = Path(output_file)
    with out_path.open('w', encoding='utf-8') as f:
        f.write('# WARNING: This file is auto-generated during the build process.\n')
        f.write('# DO NOT EDIT THIS FILE MANUALLY.\n')
        f.write('# It is created by merging:\n')
        f.write('#   - Generic YAML file: ../assets-docs/mkdocs.yml\n')
        f.write('#   - Project specific YAML file: docs/mkdocs.yml\n\n')

    with out_path.open('a', encoding='utf-8') as f:
        yaml.dump(
            data,
            f,
            Dumper=CustomDumper,  # Use custom dumper
            allow_unicode=True,  # Ensure Unicode characters like Â© are preserved
            default_flow_style=False,  #
            sort_keys=False,  # Preserve the order of keys
        )


def main() -> None:
    """Main function to read, merge, and save YAML configurations."""
    generic_config_path = '../assets-docs/mkdocs.yml'
    specific_config_path = 'docs/mkdocs.yml'
    output_path = 'mkdocs.yml'

    print(f'Reading generic config: {generic_config_path}')
    base_config = load_yaml_with_env_variables(generic_config_path)

    print(f'Reading project specific config: {specific_config_path}')
    override_config = load_yaml_with_env_variables(specific_config_path)

    print(f'Saving merged config: {output_path}')
    merged_config = merge_yaml(base_config, override_config)
    save_yaml(merged_config, output_path)


if __name__ == '__main__':
    main()

## Some utility functions for basic threshold analysis and plotting

import itertools

import matplotlib.pyplot as plt
import numpy as np


def plot_ler_vs_per(results_object, noise_channel='depolarizing'):

    """
    Produce a plot of logical error rates vs physical error rates, as generated by a
    ThresholdExperiment.
    """
    
    fig, ax = plt.subplots(1, 1)
    pers = []
    for p in results_object.raw_results['noise_parameters']:
        pers.append(p[noise_channel])
    
    lers = results_object.logical_error_rate
    distances = results_object.raw_results['distance_range']
    lers_arranged = np.array(results_object.logical_error_rate).T
    for i, lers in enumerate(lers_arranged):
        ax.plot(pers, lers, 'o-', label=f'd={distances[i]}')
    ax.loglog()
    ax.set_xlabel("Physical Error Rate")
    ax.set_ylabel("Logical Error Rate")
    ax.grid(which='major')
    ax.grid(which='minor')
    fig.set_dpi(120)
    ax.legend()

def plot_ler_vs_rounds(results_object, noise_channel='depolarizing'):

    """
    Produce a plot of logical error rates vs number of QEC rounds, as generated by a
    MemoryExperiment.
    """
    
    fig, ax = plt.subplots(1, 1)
    pers = []
    for p in results_object.raw_results['noise_parameters']:
        pers.append(p[noise_channel])

    rounds = results_object.raw_results['num_rounds']

    distance = results_object.raw_results['distance_range'][0]
    
    lers = results_object.logical_error_rate
    for i, lers in enumerate(lers):
        ax.plot(rounds, lers, 'o-', label=f'p={pers[i]}')
    ax.set_yscale('log')
    ax.set_xlabel("Syndrome extraction round")
    ax.set_ylabel("Logical Error Rate")
    ax.set_title(f"Surface code quantum memory (d={distance})")
    ax.grid(which='major')
    ax.grid(which='minor')
    fig.set_dpi(120)
    ax.legend(bbox_to_anchor=(1, 1))

def expected_num_shots(max_errors, distance, p_physical):

    """
    Calculate the expected number of shots (Monte Carlo samples) required to observe
    `max_errors` logical failures
    """
    
    p_logical = 0.03*(p_physical/0.005)**((distance+1)/2)
    
    return int(max_errors/p_logical)

def find_intersect(curve1, curve2):

    """
    Find the x-coordinate of the intersection of two straight lines, specified by their
    y-axis intercepts and slopes. 
    Since the fit data is generated from a log-log plot, we return the true x-coordinate
    by exponentiating the computed value.
    """

    b1, m1 = curve1
    b2, m2 = curve2
    
    x = (b2-b1)/(m1-m2)

    return float(np.exp(x))

def get_thresholds(fit_params):

    """
    Given a set of fit parameters for logical vs physical error rates for different
    code distances, returns:
    - A pseudothreshold value for each code distance
    - The pairwise intersection points (pairwise thresholds) for each pair of distances
    """

    pseudothresholds = []
    for params in fit_params:
        pseudothreshold = find_intersect((params[0], params[1]), (0,1))
        pseudothresholds.append(pseudothreshold)

    threshold_dict = {'pseudothresholds': pseudothresholds}
        
    if len(fit_params) > 1:
    
        pairwise_thresholds = []
        l = list(itertools.combinations(fit_params, 2))
        for el in l:
            pairwise_thresholds.append(find_intersect(el[0], el[1]))
    
        mean_pairwise = float(np.mean(pairwise_thresholds))
    
        threshold_dict.update({'pairwise thresholds': pairwise_thresholds, 'mean pairwise threshold': mean_pairwise})

    return threshold_dict
    
def linear_loglog_fit(pers, lers):

    """
    Given a set of physical error rates (pers) and logical error rates (lers) for a set
    of code distances, returns the parameters that give a 
    straight line fit for each code distance on a log-log plot.
    """
    
    log_pers = [np.log(i) for i in pers]
    lers_arranged = np.array(lers).T
    log_lers = np.log(lers_arranged)
    fit_params = []
    for el in log_lers:
        b, m = np.polynomial.polynomial.polyfit(log_pers, el, 1)
        fit_params.append([float(b), float(m)])
        
    return fit_params
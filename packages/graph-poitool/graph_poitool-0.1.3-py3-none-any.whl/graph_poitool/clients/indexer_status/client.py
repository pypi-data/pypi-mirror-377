# Generated by ariadne-codegen
# Source: codegen/indexer_status/queries

from typing import Any, Dict, List, Optional

from .base_client import BaseClient
from .block_data import BlockData
from .block_hash import BlockHash
from .cached_ethereum_calls import (
    CachedEthereumCalls,
    CachedEthereumCallsCachedEthereumCalls,
)
from .entity_changes import EntityChanges, EntityChangesEntityChangesInBlock
from .public_poi import PublicPOI, PublicPOIPublicProofsOfIndexing
from .subgraph_status import SubgraphStatus, SubgraphStatusIndexingStatuses
from .synced_subgraphs import SyncedSubgraphs, SyncedSubgraphsIndexingStatuses


def gql(q: str) -> str:
    return q


class IndexerStatusClient(BaseClient):
    def public_poi(
        self, deployment_id: str, block_number: int, **kwargs: Any
    ) -> List[PublicPOIPublicProofsOfIndexing]:
        query = gql(
            """
            query PublicPOI($deployment_id: String!, $block_number: BigInt!) {
              publicProofsOfIndexing(
                requests: [{deployment: $deployment_id, blockNumber: $block_number}]
              ) {
                deployment
                proofOfIndexing
                block {
                  hash
                  number
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "deployment_id": deployment_id,
            "block_number": block_number,
        }
        response = self.execute(
            query=query, operation_name="PublicPOI", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return PublicPOI.model_validate(data).public_proofs_of_indexing

    def synced_subgraphs(self, **kwargs: Any) -> List[SyncedSubgraphsIndexingStatuses]:
        query = gql(
            """
            query SyncedSubgraphs {
              indexingStatuses(subgraphs: []) {
                subgraph
                health
                entityCount
                fatalError {
                  message
                  deterministic
                }
                chains {
                  __typename
                  network
                  chainHeadBlock {
                    hash
                    number
                  }
                  latestBlock {
                    hash
                    number
                  }
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {}
        response = self.execute(
            query=query, operation_name="SyncedSubgraphs", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return SyncedSubgraphs.model_validate(data).indexing_statuses

    def subgraph_status(
        self, deployment_id: str, **kwargs: Any
    ) -> List[SubgraphStatusIndexingStatuses]:
        query = gql(
            """
            query SubgraphStatus($deployment_id: String!) {
              indexingStatuses(subgraphs: [$deployment_id]) {
                subgraph
                health
                entityCount
                fatalError {
                  message
                  deterministic
                }
                chains {
                  __typename
                  network
                  chainHeadBlock {
                    hash
                    number
                  }
                  latestBlock {
                    hash
                    number
                  }
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {"deployment_id": deployment_id}
        response = self.execute(
            query=query, operation_name="SubgraphStatus", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return SubgraphStatus.model_validate(data).indexing_statuses

    def entity_changes(
        self, deployment_id: str, block_number: int, **kwargs: Any
    ) -> EntityChangesEntityChangesInBlock:
        query = gql(
            """
            query EntityChanges($deployment_id: String!, $block_number: Int!) {
              entityChangesInBlock(subgraphId: $deployment_id, blockNumber: $block_number) {
                updates {
                  type
                  entities
                }
                deletions {
                  type
                  entities
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "deployment_id": deployment_id,
            "block_number": block_number,
        }
        response = self.execute(
            query=query, operation_name="EntityChanges", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return EntityChanges.model_validate(data).entity_changes_in_block

    def block_hash(
        self, network: str, block_number: int, **kwargs: Any
    ) -> Optional[Any]:
        query = gql(
            """
            query BlockHash($network: String!, $block_number: Int!) {
              blockHashFromNumber(network: $network, blockNumber: $block_number)
            }
            """
        )
        variables: Dict[str, object] = {
            "network": network,
            "block_number": block_number,
        }
        response = self.execute(
            query=query, operation_name="BlockHash", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return BlockHash.model_validate(data).block_hash_from_number

    def block_data(self, network: str, block_hash: Any, **kwargs: Any) -> Optional[Any]:
        query = gql(
            """
            query BlockData($network: String!, $block_hash: Bytes!) {
              blockData(network: $network, blockHash: $block_hash)
            }
            """
        )
        variables: Dict[str, object] = {"network": network, "block_hash": block_hash}
        response = self.execute(
            query=query, operation_name="BlockData", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return BlockData.model_validate(data).block_data

    def cached_ethereum_calls(
        self, network: str, block_hash: Any, **kwargs: Any
    ) -> Optional[List[CachedEthereumCallsCachedEthereumCalls]]:
        query = gql(
            """
            query CachedEthereumCalls($network: String!, $block_hash: Bytes!) {
              cachedEthereumCalls(network: $network, blockHash: $block_hash) {
                idHash
                block {
                  hash
                  number
                }
                contractAddress
                returnValue
              }
            }
            """
        )
        variables: Dict[str, object] = {"network": network, "block_hash": block_hash}
        response = self.execute(
            query=query,
            operation_name="CachedEthereumCalls",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CachedEthereumCalls.model_validate(data).cached_ethereum_calls

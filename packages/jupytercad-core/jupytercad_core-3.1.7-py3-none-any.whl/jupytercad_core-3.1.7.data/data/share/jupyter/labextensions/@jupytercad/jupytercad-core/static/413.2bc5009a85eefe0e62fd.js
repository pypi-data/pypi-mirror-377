"use strict";(self.webpackChunk_jupytercad_jupytercad_core=self.webpackChunk_jupytercad_jupytercad_core||[]).push([[413,794],{9794:(e,o,t)=>{t.r(o),t.d(o,{OccParser:()=>r,OccWorker:()=>h});class r{constructor(e){this._occ=self.occ,this._shapeList=e}execute(e=!1){const o={};return this._shapeList.forEach(t=>{const{shapeData:r,jcObject:n}=t,{occShape:s,metadata:a}=r;if(!s){if(e)throw Error("Unknown failure");return}new this._occ.BRepMesh_IncrementalMesh_2(s,.1,!1,.5,!0);const i=this._build_face_mesh(s);let p=[];this._shouldComputeEdge(n)&&(p=this._build_edge_mesh(s));let c=[];this._shouldComputeWire(n)&&(c=this._build_wire_mesh(s,.1)),o[n.name]={jcObject:n,faceList:i,edgeList:[...p,...c],meta:a}}),o}_shouldComputeEdge(e){var o;return"Part::Any"!==e.shape||"STL"!==(null===(o=e.parameters)||void 0===o?void 0:o.Type)}_shouldComputeWire(e){return"Sketcher::SketchObject"===e.shape}_build_wire_mesh(e,o){const t=[],r=this._occ,n=new r.TopExp_Explorer_2(e,r.TopAbs_ShapeEnum.TopAbs_EDGE,r.TopAbs_ShapeEnum.TopAbs_SHAPE);for(n.Init(e,r.TopAbs_ShapeEnum.TopAbs_EDGE,r.TopAbs_ShapeEnum.TopAbs_SHAPE);n.More();){const e=r.TopoDS.Edge_1(n.Current()),s=new r.TopLoc_Location_1,a=new r.BRepAdaptor_Curve_2(e),i=new r.GCPnts_TangentialDeflection_2(a,o,.1,2,1e-9,1e-7),p=new Array(3*i.NbPoints());for(let e=0;e<i.NbPoints();e++){const o=i.Value(e+1).Transformed(s.Transformation());p[3*e+0]=o.X(),p[3*e+1]=o.Y(),p[3*e+2]=o.Z()}t.push({vertexCoord:p,numberOfCoords:3*i.NbPoints()}),n.Next()}return t}_build_face_mesh(e){const o=[],t=[],r=this._occ,n=new r.TopExp_Explorer_2(e,r.TopAbs_ShapeEnum.TopAbs_FACE,r.TopAbs_ShapeEnum.TopAbs_SHAPE);for(n.Init(e,r.TopAbs_ShapeEnum.TopAbs_FACE,r.TopAbs_ShapeEnum.TopAbs_SHAPE);n.More();){const e=r.TopoDS.Face_1(n.Current()),s=new r.TopLoc_Location_1,a=r.BRep_Tool.Triangulation(e,s,0);if(a.IsNull()){console.error("Encountered Null Face!"),n.Next();continue}const i={vertexCoord:[],triIndexes:[],numberOfTriangles:0},p=a.get(),c=p.NbNodes();i.vertexCoord=new Array(3*c);for(let e=0;e<c;e++){const o=p.Node(e+1).Transformed(s.Transformation());i.vertexCoord[3*e+0]=o.X(),i.vertexCoord[3*e+1]=o.Y(),i.vertexCoord[3*e+2]=o.Z()}const d=e.Orientation_1(),u=p.NbTriangles();i.triIndexes=new Array(3*u);let _=0;for(let e=1;e<=a.get().NbTriangles();e++){const o=p.Triangle(e);let t=o.Value(1),n=o.Value(2);const s=o.Value(3);if(d!==r.TopAbs_Orientation.TopAbs_FORWARD){const e=t;t=n,n=e}i.triIndexes[3*_+0]=t-1,i.triIndexes[3*_+1]=n-1,i.triIndexes[3*_+2]=s-1,_++}i.numberOfTriangles=_,o.push(i),t.push(a),n.Next()}return o}_build_edge_mesh(e){const o=this._occ,t=[],r=new o.TopTools_IndexedMapOfShape_1;o.TopExp.MapShapes_1(e,o.TopAbs_ShapeEnum.TopAbs_EDGE,r);const n=new o.TopTools_IndexedDataMapOfShapeListOfShape_1;o.TopExp.MapShapesAndAncestors(e,o.TopAbs_ShapeEnum.TopAbs_EDGE,o.TopAbs_ShapeEnum.TopAbs_FACE,n);for(let e=1;e<=n.Extent();e++){if(0===n.FindFromIndex(e).Extent())continue;const s=o.TopoDS.Edge_1(r.FindKey(e));let a=new o.gp_Trsf_1;const i=new o.TopLoc_Location_1,p=o.BRep_Tool.Polygon3D(s,i),c={vertexCoord:[],numberOfCoords:0};let d;if(p.IsNull()){const t=o.TopoDS.Face_1(n.FindFromIndex(e).First_1()),r=o.BRep_Tool.Triangulation(t,i,0);i.IsIdentity()||(a=i.Transformation());const p=o.BRep_Tool.PolygonOnTriangulation_1(s,r,i);if(p.IsNull())continue;d=p.get().NbNodes(),c.numberOfCoords=d,c.vertexCoord=new Array(3*d);const u=p.get().Nodes(),_=r.get();for(let e=u.Lower();e<=u.Upper();e++){const o=_.Node(u.Value(e));o.Transform(a);const t=e-1;c.vertexCoord[3*t+0]=o.X(),c.vertexCoord[3*t+1]=o.Y(),c.vertexCoord[3*t+2]=o.Z()}}else{i.IsIdentity()||(a=i.Transformation()),d=p.get().NbNodes(),c.numberOfCoords=d,c.vertexCoord=new Array(3*d);const e=p.get().Nodes();for(let o=0;o<d;o++){const t=e.Value(o+1);t.Transform(a),c.vertexCoord[3*o+0]=t.X(),c.vertexCoord[3*o+1]=t.Y(),c.vertexCoord[3*o+2]=t.Z()}}t.push(c)}return t}}var n,s=t(9662),a=t(7262),i=new Uint8Array(16);function p(){if(!n&&!(n="undefined"!=typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||"undefined"!=typeof msCrypto&&"function"==typeof msCrypto.getRandomValues&&msCrypto.getRandomValues.bind(msCrypto)))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return n(i)}const c=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;for(var d=[],u=0;u<256;++u)d.push((u+256).toString(16).substr(1));const _=function(e){var o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,t=(d[e[o+0]]+d[e[o+1]]+d[e[o+2]]+d[e[o+3]]+"-"+d[e[o+4]]+d[e[o+5]]+"-"+d[e[o+6]]+d[e[o+7]]+"-"+d[e[o+8]]+d[e[o+9]]+"-"+d[e[o+10]]+d[e[o+11]]+d[e[o+12]]+d[e[o+13]]+d[e[o+14]]+d[e[o+15]]).toLowerCase();if(!function(e){return"string"==typeof e&&c.test(e)}(t))throw TypeError("Stringified UUID is invalid");return t},l=function(e,o,t){var r=(e=e||{}).random||(e.rng||p)();if(r[6]=15&r[6]|64,r[8]=63&r[8]|128,o){t=t||0;for(var n=0;n<16;++n)o[t+n]=r[n];return o}return _(r)};class h{constructor(e){this._ready=new a.PromiseDelegate,this._messageChannels=new Map,this._nativeWorker=e.worker}get ready(){return this._ready.promise}register(e){const{messageHandler:o,thisArg:t}=e,r=l(),n=new MessageChannel;t&&o.bind(t),n.port1.onmessage=this._handlerFactory(o),this._messageChannels.set(r,n);const a={id:r,action:s.WorkerAction.REGISTER,payload:{id:r}};return this._nativeWorker.postMessage(a,[n.port2]),r}unregister(e){this._messageChannels.delete(e)}postMessage(e){this._nativeWorker.postMessage(e)}_handlerFactory(e){return o=>{o.data.action===s.MainAction.INITIALIZED&&this._ready.resolve(),e(o.data)}}}}}]);
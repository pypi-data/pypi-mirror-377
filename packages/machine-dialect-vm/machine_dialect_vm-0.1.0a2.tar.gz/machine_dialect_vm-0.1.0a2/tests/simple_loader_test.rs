//! Simple test to debug bytecode loading

use machine_dialect_vm::loader::BytecodeLoader;
use std::io::Write;
use tempfile::NamedTempFile;

#[test]
fn test_minimal_bytecode() {
    let mut data = Vec::new();

    // Header (28 bytes total)
    data.extend_from_slice(b"MDBC");  // Magic
    data.extend_from_slice(&1u32.to_le_bytes());  // Version
    data.extend_from_slice(&1u32.to_le_bytes());  // Flags
    data.extend_from_slice(&28u32.to_le_bytes());  // Name offset (immediately after header)
    data.extend_from_slice(&36u32.to_le_bytes());  // Constant offset
    data.extend_from_slice(&49u32.to_le_bytes());  // Function offset (after 1 int constant)
    data.extend_from_slice(&53u32.to_le_bytes());  // Instruction offset

    // Module name at offset 28
    data.extend_from_slice(&4u32.to_le_bytes());  // Name length
    data.extend_from_slice(b"test");  // Name

    // Constants at offset 36
    data.extend_from_slice(&1u32.to_le_bytes());  // Count = 1
    data.push(0x01);  // Tag: Int
    data.extend_from_slice(&42i64.to_le_bytes());  // Value: 42

    // Check actual position
    println!("After constants, position: {}", data.len());

    // Functions at offset 49 (adjusted)
    data.extend_from_slice(&0u32.to_le_bytes());  // Count = 0

    // Instructions at offset 53 (adjusted)
    data.extend_from_slice(&1u32.to_le_bytes());  // Count = 1

    // Single instruction: LoadConstR r0, 0
    data.push(0);  // Opcode
    data.push(0);  // dst = r0
    data.extend_from_slice(&0u16.to_le_bytes());  // const_idx = 0

    println!("Generated bytecode size: {} bytes", data.len());
    println!("Bytecode hex: {:02x?}", &data[0..60.min(data.len())]);

    // Write to file
    let mut temp_file = NamedTempFile::new().unwrap();
    temp_file.write_all(&data).unwrap();

    let path = temp_file.path().with_extension("");
    let mdbc_path = path.with_extension("mdbc");
    std::fs::rename(temp_file.path(), &mdbc_path).unwrap();

    // Try to load
    match BytecodeLoader::load_module(&path) {
        Ok((module, _metadata)) => {
            println!("Successfully loaded module!");
            println!("  Name: {}", module.name);
            println!("  Constants: {}", module.constants.len());
            println!("  Instructions: {}", module.instructions.len());

            assert_eq!(module.name, "test");
            assert_eq!(module.constants.len(), 1);
            assert_eq!(module.instructions.len(), 1);
        }
        Err(e) => {
            panic!("Failed to load bytecode: {:?}", e);
        }
    }

    // Clean up
    std::fs::remove_file(mdbc_path).unwrap();
}

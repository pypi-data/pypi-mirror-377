// Deprecated: use mcshell.mcblockly functions
import fs from 'fs';
import path from 'path';

// Helper to format names like OAK_PLANKS -> "Oak Planks"
function generateBlocklyName(id) {
    if (!id || typeof id !== 'string') return '';
    return id.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
}

// Main generation function
function generateFiles() {
    try {
        let colorableData = {};
        let pickersData = {};
        let singlesData = [];

        try {
            // Construct the full path to the JSON file
            // __dirname is not available in ES modules by default.
            // A common way to get the current directory in an ES module:
            const currentModuleUrl = new URL(import.meta.url);
            const currentModuleDir = path.dirname(currentModuleUrl.pathname);

            // Assuming colourables.json is in the same directory as this script
            const colorablePath = path.join(currentModuleDir, 'colourables.json');
            const colorableRawData = fs.readFileSync(colorablePath);
            colorableData = JSON.parse(colorableRawData);

            const pickersPath = path.join(currentModuleDir, 'pickers.json');
            const pickersRawData = fs.readFileSync(pickersPath);
            pickersData = JSON.parse(pickersRawData);

            const singlesPath = path.join(currentModuleDir, 'singles.json');
            const singlesRawData = fs.readFileSync(singlesPath);
            singlesData = JSON.parse(singlesRawData);


        //     console.log("Successfully loaded colourables.json:", colorableData);

        } catch (error) {
            console.error("Error loading data from JSON files:", error);
            // Set to default empty values if loading fails, so the rest of the script can run
            colorableData = {};
            pickersData = {};
            singlesData = [];
        }


        let blockDefsOutput = `// src/blocks/materials.mjs (Auto-generated by generate_blockly_defs.mjs)
import { MCED } from "../lib/constants.mjs"; // Ensure MCED is exported from utils.mjs

export function defineMineCraftMaterialBlocks(Blockly) {
`;

        let pythonGenOutput = `// src/generators/python/materials.js (Auto-generated content)
import { pythonGenerator } from 'blockly/python';

// Helper function for simple picker blocks
function createPickerGenerator(block, generator, fieldName = 'MATERIAL_ID') {
    const blockId = block.getFieldValue(fieldName);
    return [\`'\${blockId}'\`, generator.ORDER_ATOMIC];
}

export function installMCMaterialsGenerator(pythonGenerator) {
`;

        let toolboxXmlOutput = `  <category name="Materials" colour="#777777">\n`; // Start the new category

        // --- 1. Generate blocks for Colorable Base Materials ---
        for (const baseMaterialId in colorableData) {
            const blocklyBlockName = `minecraft_material_${baseMaterialId.toLowerCase()}`;
            const humanReadableBase = generateBlocklyName(baseMaterialId);

            blockDefsOutput += `
    Blockly.Blocks['${blocklyBlockName}'] = {
        init: function() {
            this.appendValueInput("COLOUR")
                .setCheck("MinecraftColour")
                .setAlign(Blockly.ALIGN_RIGHT)
                .appendField("${humanReadableBase} with color");
            this.setOutput(true, "Block");
            this.setColour(160);
            this.setTooltip("A ${humanReadableBase} block that can be colored.");
            MCED.Defaults.values['${blocklyBlockName}'] = {
                COLOUR: { shadow: '<shadow type="minecraft_coloured_block_picker"><field name="MINECRAFT_COLOUR_ID">WHITE</field></shadow>' }
            };
            MCED.BlocklyUtils.configureShadow(this, "COLOUR");
        }
    };
`;

            pythonGenOutput += `
    pythonGenerator.forBlock['${blocklyBlockName}'] = function(block, generator) {
        const colourIdValue = generator.valueToCode(block, 'COLOUR', generator.ORDER_ATOMIC) || "'WHITE'";
        let rawColourId = 'WHITE'; // Default
        if (colourIdValue && colourIdValue.length > 2) {
            rawColourId = colourIdValue.substring(1, colourIdValue.length - 1);
        }

        // Construct the final Bukkit Material ID string
        let outputBukkitId = '';
        if (rawColourId === 'TINTED_GLASS_BLOCK') {
            outputBukkitId = 'TINTED_GLASS'; // The material is just TINTED_GLASS
        } else if ('${baseMaterialId}'.includes('GLASS_PANE')) {
            outputBukkitId = \`\${rawColourId}_STAINED_GLASS_PANE\`;
        } else if ('${baseMaterialId}'.includes('GLASS')) {
            outputBukkitId = \`\${rawColourId}_STAINED_GLASS\`;
        } else if ('${baseMaterialId}'.includes('BANNER')) {
             // Logic for banners might be complex if WALL_BANNER is separate
             outputBukkitId = \`\${rawColourId}_BANNER\`;
        } else {
            outputBukkitId = \`\${rawColourId}_${baseMaterialId}\`;
        }

        return [\`'\${outputBukkitId}'\`, generator.ORDER_ATOMIC];
    };
`;
            // Add to Toolbox XML
            toolboxXmlOutput += `    <block type="${blocklyBlockName}">
      <value name="COLOUR">
        <shadow type="minecraft_coloured_block_picker">
          <field name="MINECRAFT_COLOUR_ID">WHITE</field>
        </shadow>
      </value>
    </block>\n`;
        }

        // Add a separator in the toolbox
        toolboxXmlOutput += `    <sep></sep>\n`;

        // --- 2. Generate blocks for Specific Picker Groups ---
        for (const pickerName in pickersData) {
            const blocklyBlockName = `minecraft_picker_${pickerName.toLowerCase()}`;
            const options = pickersData[pickerName].map(id => `["${generateBlocklyName(id)}", "${id}"]`).join(',\n                    ');

            blockDefsOutput += `
    Blockly.Blocks['${blocklyBlockName}'] = {
        init: function() {
            this.appendDummyInput()
                .appendField("${generateBlocklyName(pickerName)}")
                .appendField(new Blockly.FieldDropdown([
                    ${options}
                ]), "MATERIAL_ID");
            this.setOutput(true, "Block");
            this.setColour(180);
            this.setTooltip("Select a ${generateBlocklyName(pickerName)} material.");
        }
    };
`;
            pythonGenOutput += `
    pythonGenerator.forBlock['${blocklyBlockName}'] = function(block, generator) {
        return createPickerGenerator(block, generator, 'MATERIAL_ID');
    };
`;
            // Add to Toolbox XML
            toolboxXmlOutput += `    <block type="${blocklyBlockName}"></block>\n`;
        }

        // --- 3. Generate a picker for all remaining single materials ---
        if (singlesData.length > 0) {
            const blocklyBlockName = `minecraft_picker_miscellaneous`;
            const options = singlesData.map(id => `["${generateBlocklyName(id)}", "${id}"]`).join(',\n                    ');
            blockDefsOutput += `
    Blockly.Blocks['${blocklyBlockName}'] = {
        init: function() {
            this.appendDummyInput()
                .appendField("Misc. Block/Item")
                .appendField(new Blockly.FieldDropdown([
                    ${options}
                ]), "MATERIAL_ID");
            this.setOutput(true, "Block"); // Assumes they are placeable blocks
            this.setColour(200);
            this.setTooltip("Select a miscellaneous Minecraft block or item.");
        }
    };
`;
            pythonGenOutput += `
    pythonGenerator.forBlock['${blocklyBlockName}'] = function(block, generator) {
        return createPickerGenerator(block, generator, 'MATERIAL_ID');
    };
`;

            // Add to Toolbox XML
            toolboxXmlOutput += `    <sep></sep>\n    <block type="${blocklyBlockName}"></block>\n`;
        }

        blockDefsOutput += `\n} // End of defineMineCraftMaterialBlocks\n`;
        pythonGenOutput += `\n} // End of installMaterialGenerators\n`;
        toolboxXmlOutput += `  </category>`;

        // Write the generated code to files
        // 1. Use `path.join` to construct the full, safe path to the new directory
        const currentModuleUrl = new URL(import.meta.url);
        const currentModuleDir = path.dirname(currentModuleUrl.pathname);

        const directoryPathBlocks = path.join(currentModuleDir, 'blocks'); // Example: creates 'my-new-directory' inside a 'subfolder'
        const directoryPathPython = path.join(currentModuleDir, 'python'); // Example: creates 'my-new-directory' inside a 'subfolder'

        // 2. Use `fs.mkdirSync` to create the directory
        try {
            // The { recursive: true } option is very useful. It's like `mkdir -p` on Linux.
            // - It will create parent directories if they don't exist (e.g., 'subfolder').
            // - It will NOT throw an error if the directory already exists.
            fs.mkdirSync(directoryPathBlocks, { recursive: true });
            fs.mkdirSync(directoryPathPython, { recursive: true });

        } catch (error) {
            console.error(`Error creating directory: ${error.message}`);
        }

        fs.writeFileSync(path.join(directoryPathBlocks,'materials.mjs'), blockDefsOutput, 'utf8');
        console.log("Successfully generated blocks/materials.mjs");
        fs.writeFileSync(path.join(directoryPathPython,'materials.mjs'), pythonGenOutput, 'utf8');
        console.log("Successfully generated python/materials.mjs");
        fs.writeFileSync(path.join(currentModuleDir,'toolbox.xml'),toolboxXmlOutput, 'utf8');
        console.log("Successfully generated toolbox.xml");

    } catch (error) {
        console.error("Failed to generate Blockly files:", error);
    }
}

generateFiles();
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>mk2lib.game API documentation</title>
<meta name="description" content="Main Machi Koro 2 game class.">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>mk2lib.game</code></h1>
</header>
<section id="section-intro">
<p>Main Machi Koro 2 game class.</p>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="mk2lib.game.MachiKoroGame"><code class="flex name class">
<span>class <span class="ident">MachiKoroGame</span></span>
<span>(</span><span>owner:Â int)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MachiKoroGame:
    &#34;&#34;&#34;
    Machi Koro 2 Game implementation.
    &#34;&#34;&#34;

    def __init__(self, owner: int):
        &#34;&#34;&#34;
        Create a new game.

        :param owner: ID of player who created game.
        &#34;&#34;&#34;
        self.players: list[Player] = [Player(player_id=owner)]
        self.player_map: dict[int, Player] = {owner: self.players[0]}
        self.current_player: int = 0
        self.state: GameState = GameState.NOT_STARTED
        self.market: None | Market = None
        self.owner_id: int = owner
        self.turn: int = 0
        self.round: int = 1
        self.use_promo: bool = True
        self.randomize_players: bool = True
        self.dice: Dice | None = None
        self.last_op: float = time()
        self.events: SimpleQueue[Event] = SimpleQueue()  # Primary event bus
        self.active_effects: dict[Effect, Landmark] = {}
        self.emit_event(GameCreated(owner=self.players[0]))  # Game is ready.

    # Event bus management

    def emit_event(self, event: Event) -&gt; None:
        &#34;&#34;&#34;
        Put a new event into event queue.

        :param event: Event that&#39;s being emitted.
        :return None:
        &#34;&#34;&#34;
        self.events.put(event)

    # Card effect helpers

    def is_player_eligible_for_loan_office(self, player: Player) -&gt; bool:
        &#34;&#34;&#34;
        Check if player can buy loan office. He must be only one without landmarks.

        :param player: Player, for whom condition is checked.
        :return: Whether player is only one without landmarks &amp; can build loan office.
        &#34;&#34;&#34;
        for plr in self.players:
            if plr is player and plr.landmarks:
                # Player already has landmarks - cannot buy loan office.
                # Should not really happen, because if player has landmarks - build
                # wouldn&#39;t list Loan Office, as it has undefined 2nd and 3rd landmark
                # price.
                return False  # pragma: no cover
            if plr is not player and not plr.landmarks:
                # Another player doesn&#39;t have landmarks - cannot buy loan office.
                return False
        return True

    def get_gain_modifier(self, card: Card) -&gt; int:
        &#34;&#34;&#34;
        Check for active landmark effects that increase card&#39;s yield.

        :param card: Card that we&#39;re checking.
        :return: Yield delta that must be added to card&#39;s income value.
        &#34;&#34;&#34;
        if isinstance(card, Establishment):
            if (effect := BOOST_ONE_COIN_EFFECTS.get(card.category)) is not None:
                return 1 if effect in self.active_effects else 0
        return 0

    # State machine management

    def _switch_state(self, new_state: GameState) -&gt; None:
        &#34;&#34;&#34;
        Switch game to a new state and emit event.

        :param new_state: New state that we&#39;re entering.
        :return: None.
        &#34;&#34;&#34;
        if new_state == self.state:
            return
        self.emit_event(StateSwitch(self.state, new_state))
        self.state = new_state
        self.last_op = time()

    def is_owner_or_timeout(self, player: PlayerType) -&gt; bool:
        &#34;&#34;&#34;
        Check if player is owner or inactivity timeout has hit.

        :param player: Player, who attempts action.
        :return: Boolean, indicating whether privileged action is allowed.
        &#34;&#34;&#34;
        if player := self._get_player_object(player):
            if player.player_id == self.owner_id:
                return True
            now_time = time()
            if (now_time - self.last_op) &gt;= INACTIVITY_TIMEOUT:
                return True
            self.emit_event(
                OnlyOwnerOperation(
                    owner=self._get_owner(),
                    user=player,
                    inactivity_remains=INACTIVITY_TIMEOUT - (now_time - self.last_op),
                )
            )
        return False

    def is_owner_self_or_timeout(self, player: PlayerType, target: PlayerType) -&gt; bool:
        &#34;&#34;&#34;
        Check if player is owner, targets himself or inactivity timeout has hit.

        This check is particularly useful for kick, which can be invoked not only by
        admin, but also by player himself (to leave the game).

        :param player: Player who invokes action.
        :param target: Player, targeted by action.
        :return: Boolean, indicating whether privileged action is allowed.
        &#34;&#34;&#34;
        if player := self._get_player_object(player):
            if target := self._get_player_object(target):
                if player is target:
                    return True
                return self.is_owner_or_timeout(player)
        return False

    def _expect_state(self, target_state: GameState) -&gt; bool:
        &#34;&#34;&#34;
        Action expects that game is in specified state.

        If not, an error event would be generated.

        :param target_state: Current expected game state.
        :return: Whether game is now in expected state.
        &#34;&#34;&#34;
        if self.state != target_state:
            self.emit_event(WrongState(target_state, self.state))
            return False
        return True

    def _expect_current_player(self, player: Player) -&gt; bool:
        &#34;&#34;&#34;
        Action expects that it&#39;s invoked by current player only.

        :param player: Player who attempts action.
        :return: Whether player is current player.
        &#34;&#34;&#34;
        if self._get_current_player() != player:
            self.emit_event(NotYourTurn(self._get_current_player(), player))
            return False
        return True

    def _expect_state_and_player(self, player: Player, target_state: GameState) -&gt; bool:
        &#34;&#34;&#34;
        Action expects that it&#39;s invoked strictly in certain state by current player.

        :param player: Player who attempts action.
        :param target_state: Current expected game state.
        :return: Whether game state is right and it&#39;s player&#39;s turn now.
        &#34;&#34;&#34;
        if not self._expect_current_player(player):
            return False
        if not self._expect_state(target_state):
            return False
        return True

    # Player object management and traversal

    def _get_current_player(self) -&gt; Player:
        &#34;&#34;&#34;
        Get current player&#39;s object.

        :return: Current player object.
        &#34;&#34;&#34;
        return self.players[self.current_player]

    def _get_owner(self) -&gt; Player:
        &#34;&#34;&#34;
        Get game owner&#39;s player object.

        :return: Game owner&#39;s player object.
        &#34;&#34;&#34;
        return self.player_map[self.owner_id]

    def _get_player_object(self, player: PlayerType) -&gt; Player | None:
        &#34;&#34;&#34;
        Get player&#39;s object.

        If None is passed - current player is returned.
        If player ID is passed - matching player object is taken.
        Player object would be just returned intact.

        :param player: None, player ID or player object.
        :return: Player object.
        &#34;&#34;&#34;
        if player is None:
            return self._get_current_player()
        if isinstance(player, int):
            obj = self.player_map.get(player)
            if obj is None:
                self.emit_event(NotInGame(player))
            return obj
        return player

    def _remove_player(self, initiator: Player, target: Player) -&gt; None:
        &#34;&#34;&#34;
        Remove player from game on behalf of initiator.

        Removal logic in the lobby:
        -If owner leaves the lobby - game is cancelled.
        -If owner kicks someone - they leave lobby. Owner can kick anyone at any time.
        -Players can leave lobby anytime. Normally, players can only target themselves.
        -If inactivity timeout is hit - players gain ability to kick the owner.

        Removal logic in the game:
        -If owner is kicked or voluntarily leaves - current player becomes a new owner.
        -Owner can still kick anyone at any time. Kicked player immediately leaves game.
        -Players can leave game anytime. Normally, players can only target themselves.
        -If current player is kicked - their turn is skipped &amp; next player begins turn.
        -If inactivity timeout is hit - players gain ability to kick current player.
        -If player count drops below 2 - game is cancelled and final scores emitted.

        :param initiator: Player who initiated the removal.
        :param target: Player, who is targeted by kick.
        :return: None.
        &#34;&#34;&#34;
        # Emit player leave event.
        self.emit_event(
            PlayerLeft(
                player=target,
                initiator=initiator,
                during_game=self.state.is_game_active,
            )
        )

        if self.state.is_game_active:  # Leave during game - complex logic.
            current = self._get_current_player()
            target_index = self.players.index(target)
            if target == current:  # Skip kicked player&#39;s turn.
                self.emit_event(TurnSkipped(target))
                self._switch_turn()
                current = self._get_current_player()
            if self.current_player &gt; target_index:  # Adjust player index.
                self.current_player -= 1
            if target.player_id == self.owner_id:  # Transfer ownership.
                self.owner_id = current.player_id
                self.emit_event(OwnerChanged(oldowner=target, newowner=current))
            if (len(self.players) - 1) &lt; 2:  # Check if there&#39;s enough players remain.
                self.emit_event(
                    GameEnded(
                        player=initiator,
                        cancelled=True,
                        not_enough_players=True,
                    )
                )
                self.emit_event(FinalScores(self.get_scores(), finished=False))
                self._switch_state(GameState.CANCELLED)

        # Actually remove kicked player. At this point we no longer need their obj.
        # However, if owner leaves lobby - player object is not actually removed.
        if not (self.state.is_in_lobby and target.player_id == self.owner_id):
            self.players.remove(target)
            self.player_map.pop(target.player_id)

        # If game is in lobby and owner has left - cancel the game.
        if self.state.is_in_lobby and target.player_id == self.owner_id:
            self.emit_event(
                GameEnded(player=initiator, cancelled=True, owner_left=True)
            )
            self._switch_state(GameState.CANCELLED)

    def _traverse_backward_red(self) -&gt; Iterator[Player]:
        &#34;&#34;&#34;
        Go through players one by one in backwards order, excluding current player.

        This is order you have to pay for opponents&#39; red cards.

        :return: Previous player.
        &#34;&#34;&#34;
        current = (self.current_player - 1) % len(self.players)
        while current != self.current_player:
            yield self.players[current]
            current = (current - 1) % len(self.players)

    def traverse_forward_players(self, skipcurrent=False) -&gt; Iterator[Player]:
        &#34;&#34;&#34;
        Go through players one by one, starting with current or next player.

        :param skipcurrent: Don&#39;t include current player in iteration.
        :return: Next player.
        &#34;&#34;&#34;
        for offset in range(len(self.players) - (1 if skipcurrent else 0)):
            idx = (self.current_player + offset + (1 if skipcurrent else 0)) % len(
                self.players
            )
            yield self.players[idx]

    # Internal logic

    def _on_twelve_roll(self, player: Player) -&gt; None:
        &#34;&#34;&#34;
        Landmark effect, triggered on rolling 12.

        Only Tech Startup uses this to give 8 coins.

        :param player: Player, whose turn it is now.
        :return: None.
        &#34;&#34;&#34;
        if (card := self.active_effects.get(Effect.GET_8_COINS_ON_12_ROLL)) is not None:
            self.emit_event(
                MoneyEarned(
                    reason=card,
                    user=player,
                    earned=player.earn_coins(8),
                )
            )

    def _on_six_roll(self, player: Player) -&gt; None:
        &#34;&#34;&#34;
        Landmark effect, triggered on rolling 6.

        Only Renovation Company uses this to give money for Food establishments.

        :param player: Player, whose turn it is now.
        :return: None.
        &#34;&#34;&#34;
        card = self.active_effects.get(Effect.GET_COIN_FOR_EACH_FOOD_IF_ROLLED_6)
        if card is not None:
            count = 0
            for establishment in player.establishments:
                if establishment.category == &#34;food&#34;:
                    count += 1
            if count:
                self.emit_event(
                    MoneyEarned(
                        reason=card,
                        user=player,
                        earned=player.earn_coins(count),
                    )
                )

    def _compensation_no_earn(self, player: Player) -&gt; None:
        &#34;&#34;&#34;
        Handle landmark effects that pay compensation for earning no coins on roll.

        :param player: Player, whose turn it is now.
        :return: None.
        &#34;&#34;&#34;
        if self.dice is not None and self.dice.dual:
            card = self.active_effects.get(Effect.NO_EARN_COMPENSATION_TWO_DICE)
            payout = 3
        else:
            card = self.active_effects.get(Effect.NO_EARN_COMPENSATION_ONE_DICE)
            payout = 2
        if card is not None:
            self.emit_event(
                MoneyEarned(
                    reason=card,
                    user=player,
                    earned=player.earn_coins(payout),
                )
            )

    def _give_establishment(self, player: Player) -&gt; bool:
        &#34;&#34;&#34;
        Handle Moving Company effect that forces you to give an establishment.

        Activated on rolling a double.

        :param player: Player, whose turn it is now.
        :return: Boolean, indicating whether player has to give establishments.
        &#34;&#34;&#34;
        if Effect.GIVE_ESTABLISHMENT_ON_DOUBLE in self.active_effects:
            if len(player.establishments) &gt; 0:
                player.give_establishment = True
                self._switch_state(GameState.ON_ESTABLISHMENT_GIVE)
                self.emit_event(
                    MustGiveEstablishment(
                        from_user=player,
                        to_user=next(self._traverse_backward_red()),
                    )
                )
                return True
        return False

    def _activate_landmarks(self, player: Player) -&gt; bool:
        &#34;&#34;&#34;
        Activate orange landmark effects.

        Some complex landmarks are moved into separate functions (see above).
        Ordering matters, don&#39;t shuffle handlers around.

        :param player: Player, whose turn it is now.
        :return: Whether landmark effect interrupts normal turn flow.
        &#34;&#34;&#34;
        if self.dice is None:
            raise ValueError(&#34;Activation of landmarks without rolling dice&#34;)

        if self.dice.sum == 12:
            self._on_twelve_roll(player)
        if self.dice.sum == 6:
            self._on_six_roll(player)
        if self.dice.double:
            if (
                card := self.active_effects.get(Effect.TAKE_2_COINS_ON_DOUBLE)
            ) is not None:
                TakeFromAllOpponents(2).trigger(self, card, player, player)
        if not player.earned_coins_this_turn:
            self._compensation_no_earn(player)
        if self.dice.double:
            if (
                card := self.active_effects.get(Effect.EXTRA_TURN_ON_DOUBLE)
            ) is not None:
                ExtraTurn().trigger(self, card, player, player)
            if self._give_establishment(player):
                return True
        return False

    def _enter_build_phase(self, player: Player) -&gt; None:
        &#34;&#34;&#34;
        Initiate build phase.

        This would give a coin if player is broke. Building phase would be skipped if
        player cannot afford anything.

        :param player: Player, whose turn it is now.
        :return: None.
        &#34;&#34;&#34;
        if self.market is None:
            raise ValueError(&#34;Entered build phase with not initialized market&#34;)

        if not player.initial_build_turns and player.coins == 0:
            player.earn_coins(1)
            self.emit_event(GetOneCoinBecauseHadNoMoney(player))
        buildable = self.market.can_build(player)
        if buildable:
            self._switch_state(GameState.ON_BUILD)
            self.emit_event(CanBuild(player, build_options=buildable))
            return
        self.emit_event(SkipBuild(player, cannot_buy=True))
        self._switch_turn()

    def _activate_establishments(self, roll: int) -&gt; None:
        &#34;&#34;&#34;
        Activate establishment cards for current roll and card color.

        :param roll: Dice sum rolled.
        :return: None.
        &#34;&#34;&#34;
        current = self._get_current_player()
        for player in self._traverse_backward_red():
            for establishment in player.get_activated_establishments(
                roll, ActivationOrder.OTHER_TURN
            ):
                establishment.effect.trigger(self, establishment, player, current)

        for player in self.traverse_forward_players():
            for establishment in player.get_activated_establishments(
                roll, ActivationOrder.ANY_TURN
            ):
                establishment.effect.trigger(self, establishment, player, current)

            if player != current:
                continue

            for establishment in player.get_activated_establishments(
                roll, ActivationOrder.OWN_TURN
            ):
                establishment.effect.trigger(self, establishment, player, current)

        for establishment in current.get_activated_establishments(
            roll, ActivationOrder.OWN_TURN_MAJOR
        ):
            establishment.effect.trigger(self, establishment, current, current)

    def _switch_turn(self, no_advance=False) -&gt; None:
        &#34;&#34;&#34;
        Switch turn and give control to next player.

        This does a lot of internal state tracking and preparations for next turn,
        selects next player. This method should be called whenever player ends the turn,
        even if he has extra turn.

        :param no_advance: Don&#39;t advance turn state. Used only for first turn.
        :return: None.
        &#34;&#34;&#34;
        if not no_advance:
            self._switch_state(GameState.TURN_FINISHED)
        self.turn += 1
        current_player = self._get_current_player()
        extra_turn = current_player.extra_turn
        if extra_turn:
            current_player.end_turn()
        elif not no_advance:
            current_player.end_turn()
            self.current_player = (self.current_player + 1) % len(self.players)
            if self.current_player == 0:
                self.round += 1
            current_player = self._get_current_player()
        current_player.new_turn()
        initial_build_turns = 0
        if current_player.initial_build_turns:
            initial_build_turns = 3 - current_player.initial_build_turns + 1
        self.emit_event(
            TurnBegins(
                extra=extra_turn,
                turn_number=self.turn,
                round_number=self.round,
                initial=initial_build_turns,
                player=current_player,
            )
        )
        if initial_build_turns:
            self._enter_build_phase(current_player)
        else:
            self._switch_state(GameState.ON_ROLL)
        self.dice = None

    def _check_is_game_won(self, player: Player) -&gt; bool:
        &#34;&#34;&#34;
        Check if game is won and change into Finished state if so.

        :param player: Player, whose turn it is now.
        :return: Whether game is won and was switched into Finished state.
        &#34;&#34;&#34;
        if player.is_winner():
            self.emit_event(
                GameEnded(
                    player=player,
                    finished=True,
                    launch_pad=player.have_launch_pad,
                )
            )
            self.emit_event(FinalScores(self.get_scores(), finished=True))
            self._switch_state(GameState.FINISHED)
            return True
        return False

    # External API

    def give_establishment(self, player: PlayerType, card_given: str) -&gt; bool:
        &#34;&#34;&#34;
        Give establishment per Moving Company effect.

        :param player: Player object, integer ID or None (implies current).
        :param card_given: Which card you want to give previous player.
        :return: Boolean, indicating whether move is legal &amp; was successfully performed.
        &#34;&#34;&#34;
        if not (player := self._get_player_object(player)):
            return False

        if self._expect_state_and_player(player, GameState.ON_ESTABLISHMENT_GIVE):
            if not player.has_card(card_given, only_establishments=True):
                self.emit_event(
                    PlayerHasNoSuchCard(
                        player=player, card_name=card_given, current=True
                    )
                )
                return False
            opponent = next(self._traverse_backward_red())
            given_card = cast(Establishment, player.pop_card(card_given))
            opponent.add_card(given_card)
            self.emit_event(
                EstablishmentGiven(
                    from_user=player,
                    to_user=opponent,
                    establishment=given_card,
                )
            )
            player.give_establishment = False
            self._enter_build_phase(player)
            return True

        return False

    def dont_exchange_establishments(self, player: PlayerType = None) -&gt; bool:
        &#34;&#34;&#34;
        Skip establishment exchange.

        Note, that this move will forfeit all remaining exchanges, if you have more than
        one Business Center establishments.

        :param player: Player object, integer ID or None (implies current).
        :return: Boolean, indicating whether move is legal &amp; was successfully performed.
        &#34;&#34;&#34;
        if not (player := self._get_player_object(player)):
            return False

        if self._expect_state_and_player(player, GameState.ON_ESTABLISHMENT_EXCHANGE):
            self.emit_event(SkipExchangeEstablishments(player=player))
            player.exchange_establishments = 0  # Remaining exchanges are forfeited, too
            if self._activate_landmarks(player):
                return True
            self._enter_build_phase(player)
            return True

        return False

    def exchange_establishments(
        self,
        player: PlayerType,
        opponent: PlayerType,
        card_given: str,
        card_taken: str,
    ) -&gt; bool:
        &#34;&#34;&#34;
        Exchange establishments with another player via Business Center effect.

        :param player: Player object, integer ID or None (implies current).
        :param opponent: Player descriptor of opponent, with whom you want to exchange.
        :param card_given: Establishment card that&#39;s given to opponent.
        :param card_taken: Establishment card that&#39;s taken from opponent.
        :return: Boolean, indicating whether move is legal &amp; was successfully performed.
        &#34;&#34;&#34;
        if not (player := self._get_player_object(player)):
            return False
        if not (opponent := self._get_player_object(opponent)):
            return False
        if player is opponent:
            self.emit_event(CannotExchangeWithSelf(player=player))
            return False

        if self._expect_state_and_player(player, GameState.ON_ESTABLISHMENT_EXCHANGE):

            if not player.has_card(card_given, only_establishments=True):
                self.emit_event(
                    PlayerHasNoSuchCard(
                        player=player, card_name=card_given, current=True
                    )
                )
                return False
            if not opponent.has_card(card_taken, only_establishments=True):
                self.emit_event(
                    PlayerHasNoSuchCard(
                        player=opponent, card_name=card_taken, current=False
                    )
                )
                return False

            given_card = cast(Establishment, player.pop_card(card_given))
            taken_card = cast(Establishment, opponent.pop_card(card_taken))
            player.add_card(taken_card)
            opponent.add_card(given_card)
            self.emit_event(
                EstablishmentExchanged(
                    from_user=player,
                    to_user=opponent,
                    establishment_given=given_card,
                    establishment_taken=taken_card,
                )
            )
            self.last_op = time()
            player.exchange_establishments -= 1
            if player.exchange_establishments &lt; 1:
                if self._activate_landmarks(player):
                    return True
                self._enter_build_phase(player)
            return True

        return False

    def roll_dice(self, dual: bool = False, player: PlayerType = None) -&gt; bool:
        &#34;&#34;&#34;
        Roll dice and activate establishments.

        Covers turn phase 1 and mostly 2 (but can be interrupted by establishment or
        landmark effect that requires player action).

        :param dual: Whether to roll two dice.
        :param player: Player object, integer ID or None (implies current).
        :return: Boolean, indicating whether move is legal &amp; was successfully performed.
        &#34;&#34;&#34;
        if not (player := self._get_player_object(player)):
            return False

        if self._expect_state_and_player(player, GameState.ON_ROLL):
            self.dice = Dice.roll(dual)
            self.emit_event(DiceRolled(player, self.dice))
            self._activate_establishments(self.dice.sum)
            if player.exchange_establishments:
                if any(
                    (
                        p.establishments
                        for p in self.traverse_forward_players(skipcurrent=True)
                    )
                ):
                    self._switch_state(GameState.ON_ESTABLISHMENT_EXCHANGE)
                    return True
            if self._activate_landmarks(player):
                return True
            self._enter_build_phase(player)
            return True

        return False

    def build_card(self, card_name: str | None, player: PlayerType = None) -&gt; bool:
        &#34;&#34;&#34;
        Build an establishment or landmark (or skip build phase).

        Since winning game requires to build landmarks, only during the build phase game
        can gracefully end, so winning is also handled there.

        :param card_name: Name of card that player wants to build.
        :param player: Player object, integer ID or None (implies current).
        :return: Boolean, indicating whether move is legal &amp; was successfully performed.
        &#34;&#34;&#34;
        if self.market is None:
            raise ValueError(&#34;Entered build phase with not initialized market&#34;)

        if not (player := self._get_player_object(player)):
            return False

        if self._expect_state_and_player(player, GameState.ON_BUILD):
            if card_name is None:
                self.emit_event(SkipBuild(player=player, cannot_buy=False))
                if Effect.SKIP_BUILD_FOR_5_COINS in self.active_effects:
                    self.emit_event(
                        MoneyEarned(
                            reason=self.active_effects[Effect.SKIP_BUILD_FOR_5_COINS],
                            user=player,
                            earned=player.earn_coins(5),
                        )
                    )
                self._switch_turn()
                return True
            card = self.market.build_card(player, card_name)
            if card is not None:
                if isinstance(card, Landmark):
                    card.effect.trigger(self, card, player, player)
                if not self._check_is_game_won(player):
                    self._switch_turn()
                return True

        return False

    def start(
        self, player: PlayerType, use_promo: bool = True, randomize_players: bool = True
    ) -&gt; bool:
        &#34;&#34;&#34;
        Start game when lobby is ready.

        Only game&#39;s owner (player, who created game) can start it, unless inactivity
        timeout has been hit.

        :param player: Player object, integer ID or None (implies current).
        :param use_promo: Use Promo Landmark addon with three new cards.
        :param randomize_players: Shuffle players (rather than keeping join order).
        :return: Boolean, indicating, whether the game was successfully started.
        &#34;&#34;&#34;
        if not (player := self._get_player_object(player)):
            return False
        if not self.is_owner_or_timeout(player):
            return False

        if self._expect_state(GameState.NOT_STARTED):
            if len(self.players) &lt; 2:
                self.emit_event(NotEnoughPlayers(player=player))
                return False
            self.use_promo = use_promo
            self.randomize_players = randomize_players
            if randomize_players:
                random.shuffle(self.players)
            self.emit_event(
                GameStarted(
                    owner=self._get_owner(),
                    turn_order=self.players,
                    use_promo=use_promo,
                    randomize_players=randomize_players,
                )
            )
            self.market = Market(self, use_promo=use_promo)
            self._switch_turn(no_advance=True)
            return True

        return False

    def join(self, player_id: int) -&gt; bool:
        &#34;&#34;&#34;
        Join this game.

        Game can be only joined while it&#39;s in not started state.
        If player is already in game - error event is raised and nothing happens.
        If there&#39;s already 5 players in a lobby - joining will fail.

        :param player_id: Unique ID of player who joins the game.
        :return: Boolean, indicating whether player has successfully joined game.
        &#34;&#34;&#34;
        if self._expect_state(GameState.NOT_STARTED):
            if len(self.players) &gt;= 5:
                self.emit_event(RoomIsFull(player_id=player_id))
                return False
            if player_id in self.player_map:
                self.emit_event(AlreadyInGame(self.player_map[player_id]))
                return False
            player_obj = Player(player_id)
            self.players.append(player_obj)
            self.player_map[player_id] = player_obj
            self.emit_event(PlayerJoined(player=player_obj))
            return True
        self.emit_event(GameInProgress(player_id=player_id))

        return False

    def leave(self, player: PlayerType) -&gt; bool:
        &#34;&#34;&#34;
        Leave the game, this is essentially a self-kick.

        :param player: Player, who wants to leave game.
        :return: Whether player has left the game.
        &#34;&#34;&#34;
        return self.kick(player, player)

    def kick(self, player: PlayerType, target: PlayerType) -&gt; bool:
        &#34;&#34;&#34;
        Kick the player from game.

        Normally kicking could only be done by owner, or if player targets self
        (leaves voluntarily).

        Kick logic in the lobby:
        -If owner leaves the lobby - game is cancelled.
        -If owner kicks someone - they leave lobby. Owner can kick anyone at any time.
        -Players can leave lobby anytime. Normally, players can only target themselves.
        -If inactivity timeout is hit - players gain ability to kick the owner.

        Kick logic in the game:
        -If owner is kicked or voluntarily leaves - current player becomes a new owner.
        -Owner can still kick anyone at any time. Kicked player immediately leaves game.
        -Players can leave game anytime. Normally, players can only target themselves.
        -If current player is kicked - their turn is skipped &amp; next player begins turn.
        -If inactivity timeout is hit - players gain ability to kick current player.
        -If player count drops below 2 - game is cancelled and final scores emitted.

        :param player: Player, who invokes the kick.
        :param target: Player, who is targeted by kick.
        :return: Whether kick was successful.
        &#34;&#34;&#34;
        if not (player := self._get_player_object(player)):
            return False
        if not (target := self._get_player_object(target)):
            return False

        if not self.is_owner_self_or_timeout(player, target):
            return False

        owner = self._get_owner()

        if self.state.is_game_ended:  # No kicking if game ended.
            self.emit_event(NoGameInProgress(player))
            return False

        if player is not owner and target is not player:
            # If player is in lobby and timeout has hit - he can kick owner.
            if self.state.is_in_lobby:
                if target is not owner:
                    self.emit_event(
                        OnlyOwnerOperation(
                            owner=owner,
                            user=player,
                            inactivity_remains=0,
                        )
                    )
                    return False
            # If player is in game and timeout has hit - he can kick current player.
            elif self.state.is_game_active:
                if target is not self._get_current_player():
                    self.emit_event(
                        OnlyOwnerOperation(
                            owner=owner,
                            user=player,
                            inactivity_remains=0,
                        )
                    )
                    return False

        self._remove_player(initiator=player, target=target)
        return True

    def cancel(self, player: PlayerType) -&gt; bool:
        &#34;&#34;&#34;
        Cancel a lobby or active game.

        If game is in progress, final scores event would be also emitted.

        :return: Boolean, indicating whether game was actually cancelled.
        &#34;&#34;&#34;
        if not (player := self._get_player_object(player)):
            return False
        if not self.is_owner_or_timeout(player):
            return False
        if self.state.is_game_ended:
            self.emit_event(NoGameInProgress(player))
            return False

        self.emit_event(GameEnded(player=player, cancelled=True))
        if not self.state.is_in_lobby:
            self.emit_event(FinalScores(self.get_scores(), finished=False))
        self._switch_state(GameState.CANCELLED)
        return True

    def get_scores(self) -&gt; dict[int, list[Player]]:
        &#34;&#34;&#34;
        Get player rankings (ties are possible).

        :return: Dict of places with lists of players as values.
        &#34;&#34;&#34;
        sorted_players = sorted(
            self.players,
            key=lambda x: (x.is_winner(), len(x.landmarks), x.coins),
            reverse=True,
        )

        places: dict[int, list[Player]] = {}
        place = 0
        prev_key = None
        for player in sorted_players:
            key = (player.is_winner(), len(player.landmarks), player.coins)
            if prev_key != key:
                prev_key = key
                place += 1
                places[place] = []
            places[place].append(player)

        return places

    def serialize(self) -&gt; dict:
        &#34;&#34;&#34;
        Serialize game into a save dict.

        Warning: Serialization doesn&#39;t preserve event bus state! All outstanding events
        would be lost upon save-load cycle. Since moves are atomic, you&#39;re expected to
        consume all events upon committing move, and call serialize() with empty queue.

        :return: JSON-friendly savegame.
        &#34;&#34;&#34;
        return {
            &#34;players&#34;: [p.serialize() for p in self.players],
            # Player map is reconstructed procedurally
            &#34;current_player&#34;: self.current_player,
            &#34;state&#34;: int(self.state),
            &#34;market&#34;: None if self.market is None else self.market.serialize(),
            &#34;owner_id&#34;: self.owner_id,
            &#34;turn&#34;: self.turn,
            &#34;round&#34;: self.round,
            &#34;use_promo&#34;: self.use_promo,
            &#34;randomize_players&#34;: self.randomize_players,
            &#34;dice&#34;: None if self.dice is None else self.dice.serialize(),
            &#34;last_op&#34;: self.last_op,
            # Event bus state is not captured
            &#34;active_effects&#34;: {str(k): v.name for k, v in self.active_effects.items()},
        }

    @classmethod
    def deserialize(cls, data: dict) -&gt; MachiKoroGame:
        &#34;&#34;&#34;
        Load game from save dict.

        :param data: Dict with game save.
        :return: Loaded game.
        &#34;&#34;&#34;
        game = cls.__new__(cls)  # bypass __init__, we restore manually

        game.players = [Player.deserialize(p) for p in data[&#34;players&#34;]]
        game.player_map = {}
        for player in game.players:
            game.player_map[player.player_id] = player
        game.current_player = data[&#34;current_player&#34;]
        game.state = GameState(data[&#34;state&#34;])
        game.market = None
        if data[&#34;market&#34;] is not None:
            game.market = Market.deserialize(game, data[&#34;market&#34;])
        game.owner_id = data[&#34;owner_id&#34;]
        game.turn = data[&#34;turn&#34;]
        game.round = data[&#34;round&#34;]
        game.use_promo = data[&#34;use_promo&#34;]
        game.randomize_players = data[&#34;randomize_players&#34;]
        game.dice = None
        if data[&#34;dice&#34;] is not None:
            game.dice = Dice.deserialize(data[&#34;dice&#34;])
        game.last_op = data[&#34;last_op&#34;]
        game.events = SimpleQueue()
        game.active_effects = {}
        for effect, card in data[&#34;active_effects&#34;].items():
            card_obj = cast(Landmark, replace(ALL_CARDS[card], quantity=1))
            game.active_effects[Effect(effect)] = card_obj
        return game</code></pre>
</details>
<div class="desc"><p>Machi Koro 2 Game implementation.</p>
<p>Create a new game.</p>
<p>:param owner: ID of player who created game.</p></div>
<h3>Static methods</h3>
<dl>
<dt id="mk2lib.game.MachiKoroGame.deserialize"><code class="name flex">
<span>def <span class="ident">deserialize</span></span>(<span>data:Â dict) â>Â <a title="mk2lib.game.MachiKoroGame" href="#mk2lib.game.MachiKoroGame">MachiKoroGame</a></span>
</code></dt>
<dd>
<div class="desc"><p>Load game from save dict.</p>
<p>:param data: Dict with game save.
:return: Loaded game.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mk2lib.game.MachiKoroGame.build_card"><code class="name flex">
<span>def <span class="ident">build_card</span></span>(<span>self, card_name:Â strÂ |Â None, player:Â PlayerTypeÂ =Â None) â>Â bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_card(self, card_name: str | None, player: PlayerType = None) -&gt; bool:
    &#34;&#34;&#34;
    Build an establishment or landmark (or skip build phase).

    Since winning game requires to build landmarks, only during the build phase game
    can gracefully end, so winning is also handled there.

    :param card_name: Name of card that player wants to build.
    :param player: Player object, integer ID or None (implies current).
    :return: Boolean, indicating whether move is legal &amp; was successfully performed.
    &#34;&#34;&#34;
    if self.market is None:
        raise ValueError(&#34;Entered build phase with not initialized market&#34;)

    if not (player := self._get_player_object(player)):
        return False

    if self._expect_state_and_player(player, GameState.ON_BUILD):
        if card_name is None:
            self.emit_event(SkipBuild(player=player, cannot_buy=False))
            if Effect.SKIP_BUILD_FOR_5_COINS in self.active_effects:
                self.emit_event(
                    MoneyEarned(
                        reason=self.active_effects[Effect.SKIP_BUILD_FOR_5_COINS],
                        user=player,
                        earned=player.earn_coins(5),
                    )
                )
            self._switch_turn()
            return True
        card = self.market.build_card(player, card_name)
        if card is not None:
            if isinstance(card, Landmark):
                card.effect.trigger(self, card, player, player)
            if not self._check_is_game_won(player):
                self._switch_turn()
            return True

    return False</code></pre>
</details>
<div class="desc"><p>Build an establishment or landmark (or skip build phase).</p>
<p>Since winning game requires to build landmarks, only during the build phase game
can gracefully end, so winning is also handled there.</p>
<p>:param card_name: Name of card that player wants to build.
:param player: Player object, integer ID or None (implies current).
:return: Boolean, indicating whether move is legal &amp; was successfully performed.</p></div>
</dd>
<dt id="mk2lib.game.MachiKoroGame.cancel"><code class="name flex">
<span>def <span class="ident">cancel</span></span>(<span>self, player:Â PlayerType) â>Â bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cancel(self, player: PlayerType) -&gt; bool:
    &#34;&#34;&#34;
    Cancel a lobby or active game.

    If game is in progress, final scores event would be also emitted.

    :return: Boolean, indicating whether game was actually cancelled.
    &#34;&#34;&#34;
    if not (player := self._get_player_object(player)):
        return False
    if not self.is_owner_or_timeout(player):
        return False
    if self.state.is_game_ended:
        self.emit_event(NoGameInProgress(player))
        return False

    self.emit_event(GameEnded(player=player, cancelled=True))
    if not self.state.is_in_lobby:
        self.emit_event(FinalScores(self.get_scores(), finished=False))
    self._switch_state(GameState.CANCELLED)
    return True</code></pre>
</details>
<div class="desc"><p>Cancel a lobby or active game.</p>
<p>If game is in progress, final scores event would be also emitted.</p>
<p>:return: Boolean, indicating whether game was actually cancelled.</p></div>
</dd>
<dt id="mk2lib.game.MachiKoroGame.dont_exchange_establishments"><code class="name flex">
<span>def <span class="ident">dont_exchange_establishments</span></span>(<span>self, player:Â PlayerTypeÂ =Â None) â>Â bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dont_exchange_establishments(self, player: PlayerType = None) -&gt; bool:
    &#34;&#34;&#34;
    Skip establishment exchange.

    Note, that this move will forfeit all remaining exchanges, if you have more than
    one Business Center establishments.

    :param player: Player object, integer ID or None (implies current).
    :return: Boolean, indicating whether move is legal &amp; was successfully performed.
    &#34;&#34;&#34;
    if not (player := self._get_player_object(player)):
        return False

    if self._expect_state_and_player(player, GameState.ON_ESTABLISHMENT_EXCHANGE):
        self.emit_event(SkipExchangeEstablishments(player=player))
        player.exchange_establishments = 0  # Remaining exchanges are forfeited, too
        if self._activate_landmarks(player):
            return True
        self._enter_build_phase(player)
        return True

    return False</code></pre>
</details>
<div class="desc"><p>Skip establishment exchange.</p>
<p>Note, that this move will forfeit all remaining exchanges, if you have more than
one Business Center establishments.</p>
<p>:param player: Player object, integer ID or None (implies current).
:return: Boolean, indicating whether move is legal &amp; was successfully performed.</p></div>
</dd>
<dt id="mk2lib.game.MachiKoroGame.emit_event"><code class="name flex">
<span>def <span class="ident">emit_event</span></span>(<span>self, event:Â Event) â>Â None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def emit_event(self, event: Event) -&gt; None:
    &#34;&#34;&#34;
    Put a new event into event queue.

    :param event: Event that&#39;s being emitted.
    :return None:
    &#34;&#34;&#34;
    self.events.put(event)</code></pre>
</details>
<div class="desc"><p>Put a new event into event queue.</p>
<p>:param event: Event that's being emitted.
:return None:</p></div>
</dd>
<dt id="mk2lib.game.MachiKoroGame.exchange_establishments"><code class="name flex">
<span>def <span class="ident">exchange_establishments</span></span>(<span>self, player:Â PlayerType, opponent:Â PlayerType, card_given:Â str, card_taken:Â str) â>Â bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exchange_establishments(
    self,
    player: PlayerType,
    opponent: PlayerType,
    card_given: str,
    card_taken: str,
) -&gt; bool:
    &#34;&#34;&#34;
    Exchange establishments with another player via Business Center effect.

    :param player: Player object, integer ID or None (implies current).
    :param opponent: Player descriptor of opponent, with whom you want to exchange.
    :param card_given: Establishment card that&#39;s given to opponent.
    :param card_taken: Establishment card that&#39;s taken from opponent.
    :return: Boolean, indicating whether move is legal &amp; was successfully performed.
    &#34;&#34;&#34;
    if not (player := self._get_player_object(player)):
        return False
    if not (opponent := self._get_player_object(opponent)):
        return False
    if player is opponent:
        self.emit_event(CannotExchangeWithSelf(player=player))
        return False

    if self._expect_state_and_player(player, GameState.ON_ESTABLISHMENT_EXCHANGE):

        if not player.has_card(card_given, only_establishments=True):
            self.emit_event(
                PlayerHasNoSuchCard(
                    player=player, card_name=card_given, current=True
                )
            )
            return False
        if not opponent.has_card(card_taken, only_establishments=True):
            self.emit_event(
                PlayerHasNoSuchCard(
                    player=opponent, card_name=card_taken, current=False
                )
            )
            return False

        given_card = cast(Establishment, player.pop_card(card_given))
        taken_card = cast(Establishment, opponent.pop_card(card_taken))
        player.add_card(taken_card)
        opponent.add_card(given_card)
        self.emit_event(
            EstablishmentExchanged(
                from_user=player,
                to_user=opponent,
                establishment_given=given_card,
                establishment_taken=taken_card,
            )
        )
        self.last_op = time()
        player.exchange_establishments -= 1
        if player.exchange_establishments &lt; 1:
            if self._activate_landmarks(player):
                return True
            self._enter_build_phase(player)
        return True

    return False</code></pre>
</details>
<div class="desc"><p>Exchange establishments with another player via Business Center effect.</p>
<p>:param player: Player object, integer ID or None (implies current).
:param opponent: Player descriptor of opponent, with whom you want to exchange.
:param card_given: Establishment card that's given to opponent.
:param card_taken: Establishment card that's taken from opponent.
:return: Boolean, indicating whether move is legal &amp; was successfully performed.</p></div>
</dd>
<dt id="mk2lib.game.MachiKoroGame.get_gain_modifier"><code class="name flex">
<span>def <span class="ident">get_gain_modifier</span></span>(<span>self, card:Â Card) â>Â int</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_gain_modifier(self, card: Card) -&gt; int:
    &#34;&#34;&#34;
    Check for active landmark effects that increase card&#39;s yield.

    :param card: Card that we&#39;re checking.
    :return: Yield delta that must be added to card&#39;s income value.
    &#34;&#34;&#34;
    if isinstance(card, Establishment):
        if (effect := BOOST_ONE_COIN_EFFECTS.get(card.category)) is not None:
            return 1 if effect in self.active_effects else 0
    return 0</code></pre>
</details>
<div class="desc"><p>Check for active landmark effects that increase card's yield.</p>
<p>:param card: Card that we're checking.
:return: Yield delta that must be added to card's income value.</p></div>
</dd>
<dt id="mk2lib.game.MachiKoroGame.get_scores"><code class="name flex">
<span>def <span class="ident">get_scores</span></span>(<span>self) â>Â dict[int,Â list[<a title="mk2lib.player.Player" href="player.html#mk2lib.player.Player">Player</a>]]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_scores(self) -&gt; dict[int, list[Player]]:
    &#34;&#34;&#34;
    Get player rankings (ties are possible).

    :return: Dict of places with lists of players as values.
    &#34;&#34;&#34;
    sorted_players = sorted(
        self.players,
        key=lambda x: (x.is_winner(), len(x.landmarks), x.coins),
        reverse=True,
    )

    places: dict[int, list[Player]] = {}
    place = 0
    prev_key = None
    for player in sorted_players:
        key = (player.is_winner(), len(player.landmarks), player.coins)
        if prev_key != key:
            prev_key = key
            place += 1
            places[place] = []
        places[place].append(player)

    return places</code></pre>
</details>
<div class="desc"><p>Get player rankings (ties are possible).</p>
<p>:return: Dict of places with lists of players as values.</p></div>
</dd>
<dt id="mk2lib.game.MachiKoroGame.give_establishment"><code class="name flex">
<span>def <span class="ident">give_establishment</span></span>(<span>self, player:Â PlayerType, card_given:Â str) â>Â bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def give_establishment(self, player: PlayerType, card_given: str) -&gt; bool:
    &#34;&#34;&#34;
    Give establishment per Moving Company effect.

    :param player: Player object, integer ID or None (implies current).
    :param card_given: Which card you want to give previous player.
    :return: Boolean, indicating whether move is legal &amp; was successfully performed.
    &#34;&#34;&#34;
    if not (player := self._get_player_object(player)):
        return False

    if self._expect_state_and_player(player, GameState.ON_ESTABLISHMENT_GIVE):
        if not player.has_card(card_given, only_establishments=True):
            self.emit_event(
                PlayerHasNoSuchCard(
                    player=player, card_name=card_given, current=True
                )
            )
            return False
        opponent = next(self._traverse_backward_red())
        given_card = cast(Establishment, player.pop_card(card_given))
        opponent.add_card(given_card)
        self.emit_event(
            EstablishmentGiven(
                from_user=player,
                to_user=opponent,
                establishment=given_card,
            )
        )
        player.give_establishment = False
        self._enter_build_phase(player)
        return True

    return False</code></pre>
</details>
<div class="desc"><p>Give establishment per Moving Company effect.</p>
<p>:param player: Player object, integer ID or None (implies current).
:param card_given: Which card you want to give previous player.
:return: Boolean, indicating whether move is legal &amp; was successfully performed.</p></div>
</dd>
<dt id="mk2lib.game.MachiKoroGame.is_owner_or_timeout"><code class="name flex">
<span>def <span class="ident">is_owner_or_timeout</span></span>(<span>self, player:Â PlayerType) â>Â bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_owner_or_timeout(self, player: PlayerType) -&gt; bool:
    &#34;&#34;&#34;
    Check if player is owner or inactivity timeout has hit.

    :param player: Player, who attempts action.
    :return: Boolean, indicating whether privileged action is allowed.
    &#34;&#34;&#34;
    if player := self._get_player_object(player):
        if player.player_id == self.owner_id:
            return True
        now_time = time()
        if (now_time - self.last_op) &gt;= INACTIVITY_TIMEOUT:
            return True
        self.emit_event(
            OnlyOwnerOperation(
                owner=self._get_owner(),
                user=player,
                inactivity_remains=INACTIVITY_TIMEOUT - (now_time - self.last_op),
            )
        )
    return False</code></pre>
</details>
<div class="desc"><p>Check if player is owner or inactivity timeout has hit.</p>
<p>:param player: Player, who attempts action.
:return: Boolean, indicating whether privileged action is allowed.</p></div>
</dd>
<dt id="mk2lib.game.MachiKoroGame.is_owner_self_or_timeout"><code class="name flex">
<span>def <span class="ident">is_owner_self_or_timeout</span></span>(<span>self, player:Â PlayerType, target:Â PlayerType) â>Â bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_owner_self_or_timeout(self, player: PlayerType, target: PlayerType) -&gt; bool:
    &#34;&#34;&#34;
    Check if player is owner, targets himself or inactivity timeout has hit.

    This check is particularly useful for kick, which can be invoked not only by
    admin, but also by player himself (to leave the game).

    :param player: Player who invokes action.
    :param target: Player, targeted by action.
    :return: Boolean, indicating whether privileged action is allowed.
    &#34;&#34;&#34;
    if player := self._get_player_object(player):
        if target := self._get_player_object(target):
            if player is target:
                return True
            return self.is_owner_or_timeout(player)
    return False</code></pre>
</details>
<div class="desc"><p>Check if player is owner, targets himself or inactivity timeout has hit.</p>
<p>This check is particularly useful for kick, which can be invoked not only by
admin, but also by player himself (to leave the game).</p>
<p>:param player: Player who invokes action.
:param target: Player, targeted by action.
:return: Boolean, indicating whether privileged action is allowed.</p></div>
</dd>
<dt id="mk2lib.game.MachiKoroGame.is_player_eligible_for_loan_office"><code class="name flex">
<span>def <span class="ident">is_player_eligible_for_loan_office</span></span>(<span>self, player:Â Player) â>Â bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_player_eligible_for_loan_office(self, player: Player) -&gt; bool:
    &#34;&#34;&#34;
    Check if player can buy loan office. He must be only one without landmarks.

    :param player: Player, for whom condition is checked.
    :return: Whether player is only one without landmarks &amp; can build loan office.
    &#34;&#34;&#34;
    for plr in self.players:
        if plr is player and plr.landmarks:
            # Player already has landmarks - cannot buy loan office.
            # Should not really happen, because if player has landmarks - build
            # wouldn&#39;t list Loan Office, as it has undefined 2nd and 3rd landmark
            # price.
            return False  # pragma: no cover
        if plr is not player and not plr.landmarks:
            # Another player doesn&#39;t have landmarks - cannot buy loan office.
            return False
    return True</code></pre>
</details>
<div class="desc"><p>Check if player can buy loan office. He must be only one without landmarks.</p>
<p>:param player: Player, for whom condition is checked.
:return: Whether player is only one without landmarks &amp; can build loan office.</p></div>
</dd>
<dt id="mk2lib.game.MachiKoroGame.join"><code class="name flex">
<span>def <span class="ident">join</span></span>(<span>self, player_id:Â int) â>Â bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def join(self, player_id: int) -&gt; bool:
    &#34;&#34;&#34;
    Join this game.

    Game can be only joined while it&#39;s in not started state.
    If player is already in game - error event is raised and nothing happens.
    If there&#39;s already 5 players in a lobby - joining will fail.

    :param player_id: Unique ID of player who joins the game.
    :return: Boolean, indicating whether player has successfully joined game.
    &#34;&#34;&#34;
    if self._expect_state(GameState.NOT_STARTED):
        if len(self.players) &gt;= 5:
            self.emit_event(RoomIsFull(player_id=player_id))
            return False
        if player_id in self.player_map:
            self.emit_event(AlreadyInGame(self.player_map[player_id]))
            return False
        player_obj = Player(player_id)
        self.players.append(player_obj)
        self.player_map[player_id] = player_obj
        self.emit_event(PlayerJoined(player=player_obj))
        return True
    self.emit_event(GameInProgress(player_id=player_id))

    return False</code></pre>
</details>
<div class="desc"><p>Join this game.</p>
<p>Game can be only joined while it's in not started state.
If player is already in game - error event is raised and nothing happens.
If there's already 5 players in a lobby - joining will fail.</p>
<p>:param player_id: Unique ID of player who joins the game.
:return: Boolean, indicating whether player has successfully joined game.</p></div>
</dd>
<dt id="mk2lib.game.MachiKoroGame.kick"><code class="name flex">
<span>def <span class="ident">kick</span></span>(<span>self, player:Â PlayerType, target:Â PlayerType) â>Â bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def kick(self, player: PlayerType, target: PlayerType) -&gt; bool:
    &#34;&#34;&#34;
    Kick the player from game.

    Normally kicking could only be done by owner, or if player targets self
    (leaves voluntarily).

    Kick logic in the lobby:
    -If owner leaves the lobby - game is cancelled.
    -If owner kicks someone - they leave lobby. Owner can kick anyone at any time.
    -Players can leave lobby anytime. Normally, players can only target themselves.
    -If inactivity timeout is hit - players gain ability to kick the owner.

    Kick logic in the game:
    -If owner is kicked or voluntarily leaves - current player becomes a new owner.
    -Owner can still kick anyone at any time. Kicked player immediately leaves game.
    -Players can leave game anytime. Normally, players can only target themselves.
    -If current player is kicked - their turn is skipped &amp; next player begins turn.
    -If inactivity timeout is hit - players gain ability to kick current player.
    -If player count drops below 2 - game is cancelled and final scores emitted.

    :param player: Player, who invokes the kick.
    :param target: Player, who is targeted by kick.
    :return: Whether kick was successful.
    &#34;&#34;&#34;
    if not (player := self._get_player_object(player)):
        return False
    if not (target := self._get_player_object(target)):
        return False

    if not self.is_owner_self_or_timeout(player, target):
        return False

    owner = self._get_owner()

    if self.state.is_game_ended:  # No kicking if game ended.
        self.emit_event(NoGameInProgress(player))
        return False

    if player is not owner and target is not player:
        # If player is in lobby and timeout has hit - he can kick owner.
        if self.state.is_in_lobby:
            if target is not owner:
                self.emit_event(
                    OnlyOwnerOperation(
                        owner=owner,
                        user=player,
                        inactivity_remains=0,
                    )
                )
                return False
        # If player is in game and timeout has hit - he can kick current player.
        elif self.state.is_game_active:
            if target is not self._get_current_player():
                self.emit_event(
                    OnlyOwnerOperation(
                        owner=owner,
                        user=player,
                        inactivity_remains=0,
                    )
                )
                return False

    self._remove_player(initiator=player, target=target)
    return True</code></pre>
</details>
<div class="desc"><p>Kick the player from game.</p>
<p>Normally kicking could only be done by owner, or if player targets self
(leaves voluntarily).</p>
<p>Kick logic in the lobby:
-If owner leaves the lobby - game is cancelled.
-If owner kicks someone - they leave lobby. Owner can kick anyone at any time.
-Players can leave lobby anytime. Normally, players can only target themselves.
-If inactivity timeout is hit - players gain ability to kick the owner.</p>
<p>Kick logic in the game:
-If owner is kicked or voluntarily leaves - current player becomes a new owner.
-Owner can still kick anyone at any time. Kicked player immediately leaves game.
-Players can leave game anytime. Normally, players can only target themselves.
-If current player is kicked - their turn is skipped &amp; next player begins turn.
-If inactivity timeout is hit - players gain ability to kick current player.
-If player count drops below 2 - game is cancelled and final scores emitted.</p>
<p>:param player: Player, who invokes the kick.
:param target: Player, who is targeted by kick.
:return: Whether kick was successful.</p></div>
</dd>
<dt id="mk2lib.game.MachiKoroGame.leave"><code class="name flex">
<span>def <span class="ident">leave</span></span>(<span>self, player:Â PlayerType) â>Â bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def leave(self, player: PlayerType) -&gt; bool:
    &#34;&#34;&#34;
    Leave the game, this is essentially a self-kick.

    :param player: Player, who wants to leave game.
    :return: Whether player has left the game.
    &#34;&#34;&#34;
    return self.kick(player, player)</code></pre>
</details>
<div class="desc"><p>Leave the game, this is essentially a self-kick.</p>
<p>:param player: Player, who wants to leave game.
:return: Whether player has left the game.</p></div>
</dd>
<dt id="mk2lib.game.MachiKoroGame.roll_dice"><code class="name flex">
<span>def <span class="ident">roll_dice</span></span>(<span>self, dual:Â boolÂ =Â False, player:Â PlayerTypeÂ =Â None) â>Â bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def roll_dice(self, dual: bool = False, player: PlayerType = None) -&gt; bool:
    &#34;&#34;&#34;
    Roll dice and activate establishments.

    Covers turn phase 1 and mostly 2 (but can be interrupted by establishment or
    landmark effect that requires player action).

    :param dual: Whether to roll two dice.
    :param player: Player object, integer ID or None (implies current).
    :return: Boolean, indicating whether move is legal &amp; was successfully performed.
    &#34;&#34;&#34;
    if not (player := self._get_player_object(player)):
        return False

    if self._expect_state_and_player(player, GameState.ON_ROLL):
        self.dice = Dice.roll(dual)
        self.emit_event(DiceRolled(player, self.dice))
        self._activate_establishments(self.dice.sum)
        if player.exchange_establishments:
            if any(
                (
                    p.establishments
                    for p in self.traverse_forward_players(skipcurrent=True)
                )
            ):
                self._switch_state(GameState.ON_ESTABLISHMENT_EXCHANGE)
                return True
        if self._activate_landmarks(player):
            return True
        self._enter_build_phase(player)
        return True

    return False</code></pre>
</details>
<div class="desc"><p>Roll dice and activate establishments.</p>
<p>Covers turn phase 1 and mostly 2 (but can be interrupted by establishment or
landmark effect that requires player action).</p>
<p>:param dual: Whether to roll two dice.
:param player: Player object, integer ID or None (implies current).
:return: Boolean, indicating whether move is legal &amp; was successfully performed.</p></div>
</dd>
<dt id="mk2lib.game.MachiKoroGame.serialize"><code class="name flex">
<span>def <span class="ident">serialize</span></span>(<span>self) â>Â dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialize(self) -&gt; dict:
    &#34;&#34;&#34;
    Serialize game into a save dict.

    Warning: Serialization doesn&#39;t preserve event bus state! All outstanding events
    would be lost upon save-load cycle. Since moves are atomic, you&#39;re expected to
    consume all events upon committing move, and call serialize() with empty queue.

    :return: JSON-friendly savegame.
    &#34;&#34;&#34;
    return {
        &#34;players&#34;: [p.serialize() for p in self.players],
        # Player map is reconstructed procedurally
        &#34;current_player&#34;: self.current_player,
        &#34;state&#34;: int(self.state),
        &#34;market&#34;: None if self.market is None else self.market.serialize(),
        &#34;owner_id&#34;: self.owner_id,
        &#34;turn&#34;: self.turn,
        &#34;round&#34;: self.round,
        &#34;use_promo&#34;: self.use_promo,
        &#34;randomize_players&#34;: self.randomize_players,
        &#34;dice&#34;: None if self.dice is None else self.dice.serialize(),
        &#34;last_op&#34;: self.last_op,
        # Event bus state is not captured
        &#34;active_effects&#34;: {str(k): v.name for k, v in self.active_effects.items()},
    }</code></pre>
</details>
<div class="desc"><p>Serialize game into a save dict.</p>
<p>Warning: Serialization doesn't preserve event bus state! All outstanding events
would be lost upon save-load cycle. Since moves are atomic, you're expected to
consume all events upon committing move, and call serialize() with empty queue.</p>
<p>:return: JSON-friendly savegame.</p></div>
</dd>
<dt id="mk2lib.game.MachiKoroGame.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self, player:Â PlayerType, use_promo:Â boolÂ =Â True, randomize_players:Â boolÂ =Â True) â>Â bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(
    self, player: PlayerType, use_promo: bool = True, randomize_players: bool = True
) -&gt; bool:
    &#34;&#34;&#34;
    Start game when lobby is ready.

    Only game&#39;s owner (player, who created game) can start it, unless inactivity
    timeout has been hit.

    :param player: Player object, integer ID or None (implies current).
    :param use_promo: Use Promo Landmark addon with three new cards.
    :param randomize_players: Shuffle players (rather than keeping join order).
    :return: Boolean, indicating, whether the game was successfully started.
    &#34;&#34;&#34;
    if not (player := self._get_player_object(player)):
        return False
    if not self.is_owner_or_timeout(player):
        return False

    if self._expect_state(GameState.NOT_STARTED):
        if len(self.players) &lt; 2:
            self.emit_event(NotEnoughPlayers(player=player))
            return False
        self.use_promo = use_promo
        self.randomize_players = randomize_players
        if randomize_players:
            random.shuffle(self.players)
        self.emit_event(
            GameStarted(
                owner=self._get_owner(),
                turn_order=self.players,
                use_promo=use_promo,
                randomize_players=randomize_players,
            )
        )
        self.market = Market(self, use_promo=use_promo)
        self._switch_turn(no_advance=True)
        return True

    return False</code></pre>
</details>
<div class="desc"><p>Start game when lobby is ready.</p>
<p>Only game's owner (player, who created game) can start it, unless inactivity
timeout has been hit.</p>
<p>:param player: Player object, integer ID or None (implies current).
:param use_promo: Use Promo Landmark addon with three new cards.
:param randomize_players: Shuffle players (rather than keeping join order).
:return: Boolean, indicating, whether the game was successfully started.</p></div>
</dd>
<dt id="mk2lib.game.MachiKoroGame.traverse_forward_players"><code class="name flex">
<span>def <span class="ident">traverse_forward_players</span></span>(<span>self, skipcurrent=False) â>Â Iterator[<a title="mk2lib.player.Player" href="player.html#mk2lib.player.Player">Player</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def traverse_forward_players(self, skipcurrent=False) -&gt; Iterator[Player]:
    &#34;&#34;&#34;
    Go through players one by one, starting with current or next player.

    :param skipcurrent: Don&#39;t include current player in iteration.
    :return: Next player.
    &#34;&#34;&#34;
    for offset in range(len(self.players) - (1 if skipcurrent else 0)):
        idx = (self.current_player + offset + (1 if skipcurrent else 0)) % len(
            self.players
        )
        yield self.players[idx]</code></pre>
</details>
<div class="desc"><p>Go through players one by one, starting with current or next player.</p>
<p>:param skipcurrent: Don't include current player in iteration.
:return: Next player.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="mk2lib" href="index.html">mk2lib</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="mk2lib.game.MachiKoroGame" href="#mk2lib.game.MachiKoroGame">MachiKoroGame</a></code></h4>
<ul class="">
<li><code><a title="mk2lib.game.MachiKoroGame.build_card" href="#mk2lib.game.MachiKoroGame.build_card">build_card</a></code></li>
<li><code><a title="mk2lib.game.MachiKoroGame.cancel" href="#mk2lib.game.MachiKoroGame.cancel">cancel</a></code></li>
<li><code><a title="mk2lib.game.MachiKoroGame.deserialize" href="#mk2lib.game.MachiKoroGame.deserialize">deserialize</a></code></li>
<li><code><a title="mk2lib.game.MachiKoroGame.dont_exchange_establishments" href="#mk2lib.game.MachiKoroGame.dont_exchange_establishments">dont_exchange_establishments</a></code></li>
<li><code><a title="mk2lib.game.MachiKoroGame.emit_event" href="#mk2lib.game.MachiKoroGame.emit_event">emit_event</a></code></li>
<li><code><a title="mk2lib.game.MachiKoroGame.exchange_establishments" href="#mk2lib.game.MachiKoroGame.exchange_establishments">exchange_establishments</a></code></li>
<li><code><a title="mk2lib.game.MachiKoroGame.get_gain_modifier" href="#mk2lib.game.MachiKoroGame.get_gain_modifier">get_gain_modifier</a></code></li>
<li><code><a title="mk2lib.game.MachiKoroGame.get_scores" href="#mk2lib.game.MachiKoroGame.get_scores">get_scores</a></code></li>
<li><code><a title="mk2lib.game.MachiKoroGame.give_establishment" href="#mk2lib.game.MachiKoroGame.give_establishment">give_establishment</a></code></li>
<li><code><a title="mk2lib.game.MachiKoroGame.is_owner_or_timeout" href="#mk2lib.game.MachiKoroGame.is_owner_or_timeout">is_owner_or_timeout</a></code></li>
<li><code><a title="mk2lib.game.MachiKoroGame.is_owner_self_or_timeout" href="#mk2lib.game.MachiKoroGame.is_owner_self_or_timeout">is_owner_self_or_timeout</a></code></li>
<li><code><a title="mk2lib.game.MachiKoroGame.is_player_eligible_for_loan_office" href="#mk2lib.game.MachiKoroGame.is_player_eligible_for_loan_office">is_player_eligible_for_loan_office</a></code></li>
<li><code><a title="mk2lib.game.MachiKoroGame.join" href="#mk2lib.game.MachiKoroGame.join">join</a></code></li>
<li><code><a title="mk2lib.game.MachiKoroGame.kick" href="#mk2lib.game.MachiKoroGame.kick">kick</a></code></li>
<li><code><a title="mk2lib.game.MachiKoroGame.leave" href="#mk2lib.game.MachiKoroGame.leave">leave</a></code></li>
<li><code><a title="mk2lib.game.MachiKoroGame.roll_dice" href="#mk2lib.game.MachiKoroGame.roll_dice">roll_dice</a></code></li>
<li><code><a title="mk2lib.game.MachiKoroGame.serialize" href="#mk2lib.game.MachiKoroGame.serialize">serialize</a></code></li>
<li><code><a title="mk2lib.game.MachiKoroGame.start" href="#mk2lib.game.MachiKoroGame.start">start</a></code></li>
<li><code><a title="mk2lib.game.MachiKoroGame.traverse_forward_players" href="#mk2lib.game.MachiKoroGame.traverse_forward_players">traverse_forward_players</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>

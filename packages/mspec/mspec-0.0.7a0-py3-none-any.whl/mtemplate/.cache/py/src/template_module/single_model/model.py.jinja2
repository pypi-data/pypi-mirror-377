from dataclasses import asdict, dataclass
from datetime import datetime
from typing import Optional

from core.types import *
from core.util import *


__all__ = [
    '{{ model.name.pascal_case }}'
]


{{ macro.py_enum_definitions(model.fields) }}



field_list = [
{{ macro.py_field_list(model.fields) }}
]

longest_field_name_length = max([len(name) for name in field_list])

@dataclass
class {{ model.name.pascal_case }}:

{{ macro.py_field_definitions(model.fields) }}
    id: Optional[str] = None

    def convert_types(self) -> '{{ model.name.pascal_case }}':
{{ macro.py_convert_types(model.fields) }}
        return self

    def validate(self) -> '{{ model.name.pascal_case }}':
        
        if not isinstance(self.id, str) and self.id is not None:
            raise TypeError('invalid type for id')

{{ macro.py_verify_fields(model.fields) }}


        return self

    def to_dict(self) -> dict:
        data = asdict(self)
        if self.id is None:
            del data['id']
        return data
    
    def to_json(self) -> str:
        return to_json(self.to_dict())

    @classmethod
    def example(cls) -> '{{ model.name.pascal_case }}':
        return cls(
{{ macro.py_example_fields(model.fields) }}
        ) 

    @classmethod
    def random(cls) -> '{{ model.name.pascal_case }}':
        return cls(
{{ macro.py_random_fields(model.fields) }}
        )
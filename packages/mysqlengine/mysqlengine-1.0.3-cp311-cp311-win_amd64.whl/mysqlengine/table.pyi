import datetime
from typing_extensions import Self
from typing import Any, Iterator, Literal
from cytimes.pydt import Pydt
from sqlcycli.charset import Charset
from sqlcycli.sqlfunc import SQLFunction
from sqlcycli.aio.pool import Pool, PoolConnection, PoolSyncConnection
from mysqlengine.index import Indexes
from mysqlengine.constraint import Constraints
from mysqlengine.column import Column, Columns
from mysqlengine.partition import Partition, Partitioning
from mysqlengine.element import Element, Elements, Metadata, Logs
from mysqlengine.dml import SelectDML, InsertDML, ReplaceDML, UpdateDML, DeleteDML

# BaseTable --------------------------------------------------------------------------------------------------
class BaseTable(Element):
    def __init__(
        self,
        engine: Literal["InnoDB", "MyISAM", "MEMORY"] | None = None,
        charset: str | Charset | None = None,
        collate: str | None = None,
        comment: str | None = None,
        encryption: bool | None = None,
        row_format: (
            Literal["COMPACT", "COMPRESSED", "DYNAMIC", "FIXED", "REDUNDANT", "PAGED"]
            | None
        ) = None,
    ): ...
    # Property
    @property
    def db_name(self) -> str: ...
    @property
    def tb_name(self) -> str: ...
    @property
    def tb_qualified_name(self) -> str: ...
    @property
    def columns(self) -> Columns: ...
    @property
    def indexes(self) -> Indexes: ...
    @property
    def constraints(self) -> Constraints: ...
    @property
    def engine(self) -> str | None: ...
    @property
    def comment(self) -> str | None: ...
    @property
    def row_format(self) -> str | None: ...
    # DML
    def Select(
        self,
        *expressions: str | SQLFunction | Column,
        partition: str | Partition | list | tuple = None,
        distinct: bool = False,
        high_priority: bool = False,
        straight_join: bool = False,
        sql_buffer_result: bool = False,
        alias: str | None = None,
    ) -> SelectDML: ...
    def Insert(
        self,
        partition: str | Partition | list | tuple = None,
        ignore: bool = False,
        priority: Literal["LOW_PRIORITY", "HIGH_PRIORITY"] | None = None,
    ) -> InsertDML: ...
    def Replace(
        self,
        partition: str | Partition | list | tuple = None,
        low_priority: bool = False,
    ) -> ReplaceDML: ...
    def Update(
        self,
        partition: str | Partition | list | tuple = None,
        ignore: bool = False,
        low_priority: bool = False,
        alias: str | None = None,
    ) -> UpdateDML: ...
    def Delete(
        self,
        partition: str | Partition | list | tuple = None,
        ignore: bool = False,
        low_priority: bool = False,
        quick: bool = False,
        alias: str | None = None,
        multi_tables: str | list | tuple | None = None,
    ) -> DeleteDML: ...
    # Setter
    def setup(
        self,
        db_name: str,
        charset: str | Charset,
        collate: str | None,
        pool: Pool,
    ) -> bool: ...
    def set_name(self, name: str): ...
    # Copy
    def copy(self) -> Self: ...
    # Special Methods
    def __getitem__(self, col: str | Column) -> Column: ...
    def __contains__(self, col: str | Column) -> bool: ...
    def __iter__(self) -> Iterator[Column]: ...

# Table ------------------------------------------------------------------------------------------------------
class Table(BaseTable):
    # Property
    @property
    def partitioning(self) -> Partitioning | None: ...
    @property
    def partitioned(self) -> bool | None: ...
    @property
    def encryption(self) -> bool | None: ...
    # Sync
    def Initialize(self, force: bool = False) -> Logs: ...
    def Create(self, if_not_exists: bool = False) -> Logs: ...
    def Exists(self) -> bool: ...
    def Truncate(self) -> Logs: ...
    def Drop(self, if_exists: bool = False) -> Logs: ...
    def Empty(self) -> bool: ...
    def Alter(
        self,
        engine: Literal["InnoDB", "MyISAM", "MEMORY"] | None = None,
        charset: str | Charset | None = None,
        collate: str | None = None,
        comment: str | None = None,
        encryption: bool | None = None,
        row_format: (
            Literal["COMPACT", "COMPRESSED", "DYNAMIC", "FIXED", "REDUNDANT", "PAGED"]
            | None
        ) = None,
    ) -> Logs: ...
    def ShowMetadata(self) -> TableMetadata: ...
    def ShowColumnNames(self) -> tuple[str]: ...
    def ShowIndexNames(self) -> tuple[str]: ...
    def ShowConstraintSymbols(self) -> tuple[str]: ...
    def Lock(
        self,
        conn: PoolSyncConnection,
        lock_for_read: bool = True,
    ) -> PoolSyncConnection: ...
    def Analyze(self, write_to_binlog: bool = True) -> tuple[dict]: ...
    def Check(
        self,
        *options: Literal[
            "FOR UPGRADE", "QUICK", "FAST", "MEDIUM", "EXTENDED", "CHANGED"
        ],
    ) -> tuple[dict]: ...
    def Optimize(self, write_to_binlog: bool = True) -> tuple[dict]: ...
    def Repair(
        self,
        write_to_binlog: bool = True,
        option: Literal["QUICK", "EXTENDED", "USE_FRM"] | None = None,
    ) -> tuple[dict]: ...
    def SyncFromRemote(self, thorough: bool = False) -> Logs: ...
    def SyncToRemote(self) -> Logs: ...
    # ASync
    async def aioInitialize(self, force: bool = False) -> Logs: ...
    async def aioCreate(self, if_not_exists: bool = False) -> Logs: ...
    async def aioExists(self) -> bool: ...
    async def aioTruncate(self) -> Logs: ...
    async def aioDrop(self, if_exists: bool = False) -> Logs: ...
    async def aioEmpty(self) -> bool: ...
    async def aioAlter(
        self,
        engine: Literal["InnoDB", "MyISAM", "MEMORY"] | None = None,
        charset: str | Charset | None = None,
        collate: str | None = None,
        comment: str | None = None,
        encryption: bool | None = None,
        row_format: (
            Literal["COMPACT", "COMPRESSED", "DYNAMIC", "FIXED", "REDUNDANT", "PAGED"]
            | None
        ) = None,
    ) -> Logs: ...
    async def aioShowMetadata(self) -> TableMetadata: ...
    async def aioShowColumnNames(self) -> tuple[str]: ...
    async def aioShowIndexNames(self) -> tuple[str]: ...
    async def aioShowConstraintSymbols(self) -> tuple[str]: ...
    async def aioLock(
        self,
        conn: PoolSyncConnection,
        lock_for_read: bool = True,
    ) -> PoolSyncConnection: ...
    async def aioAnalyze(self, write_to_binlog: bool = True) -> tuple[dict]: ...
    async def aioCheck(
        self,
        *options: Literal[
            "FOR UPGRADE", "QUICK", "FAST", "MEDIUM", "EXTENDED", "CHANGED"
        ],
    ) -> tuple[dict]: ...
    async def aioOptimize(self, write_to_binlog: bool = True) -> tuple[dict]: ...
    async def aioRepair(
        self,
        write_to_binlog: bool = True,
        option: Literal["QUICK", "EXTENDED", "USE_FRM"] | None = None,
    ) -> tuple[dict]: ...
    async def aioSyncFromRemote(self, thorough: bool = False) -> Logs: ...
    async def aioSyncToRemote(self) -> Logs: ...

# Time Table --------------------------------------------------------------------------------------------------
class TimeTable(Table):
    def __init__(
        self,
        time_column: str,
        time_unit: Literal[
            "YEAR", "QUARTER", "MONTH", "WEEK", "DAY", "HOUR", "MINUTE", "SECOND"
        ],
        start_from: str | datetime.date | datetime.datetime,
        end_with: str | datetime.date | datetime.datetime | None = None,
        charset: str | Charset | None = None,
        collate: str | None = None,
        comment: str | None = None,
        encryption: bool | None = None,
        row_format: (
            Literal["COMPACT", "COMPRESSED", "DYNAMIC", "FIXED", "REDUNDANT", "PAGED"]
            | None
        ) = None,
    ): ...
    # Property
    @property
    def time_column(self) -> Column: ...
    @property
    def time_unit(self) -> str: ...
    # Sync
    def ExtendToTime(
        self,
        *,
        start_from: str | datetime.date | datetime.datetime | None = None,
        end_with: str | datetime.date | datetime.datetime | None = None,
    ) -> Logs: ...
    def CoalesceToTime(
        self,
        *,
        start_from: str | datetime.date | datetime.datetime | None = None,
        end_with: str | datetime.date | datetime.datetime | None = None,
    ) -> Logs: ...
    def DropToTime(
        self,
        *,
        start_from: str | datetime.date | datetime.datetime | None = None,
        end_with: str | datetime.date | datetime.datetime | None = None,
    ) -> Logs: ...
    def ReorganizeOverflow(
        self,
        catcher: Literal["future", "past", "both"] = "future",
    ) -> Logs: ...
    def ShowPartitionNames(self) -> tuple[str]: ...
    def ShowPartitionRows(self) -> dict[str, int]: ...
    def GetBoundaryPartitionTime(self, future: bool = True) -> Pydt: ...
    # Async
    async def aioExtendToTime(
        self,
        *,
        start_from: str | datetime.date | datetime.datetime | None = None,
        end_with: str | datetime.date | datetime.datetime | None = None,
    ) -> Logs: ...
    async def aioCoalesceToTime(
        self,
        *,
        start_from: str | datetime.date | datetime.datetime | None = None,
        end_with: str | datetime.date | datetime.datetime | None = None,
    ) -> Logs: ...
    async def aioDropToTime(
        self,
        *,
        start_from: str | datetime.date | datetime.datetime | None = None,
        end_with: str | datetime.date | datetime.datetime | None = None,
    ) -> Logs: ...
    async def aioReorganizeOverflow(
        self,
        catcher: Literal["future", "past", "both"] = "future",
    ) -> Logs: ...
    async def aioShowPartitionNames(self) -> tuple[str]: ...
    async def aioShowPartitionRows(self) -> dict[str, int]: ...
    async def aioGetBoundaryPartitionTime(self, future: bool = True) -> Pydt: ...
    # Setter
    def setup(
        self,
        db_name: str,
        charset: str | Charset,
        collate: str | None,
        pool: Pool,
    ) -> bool: ...

# Temporary Table --------------------------------------------------------------------------------------------
class TempTable(BaseTable):
    def __init__(
        self,
        engine: Literal["InnoDB", "MyISAM", "MEMORY"] | None = None,
        charset: str | Charset | None = None,
        collate: str | None = None,
        comment: str | None = None,
        row_format: (
            Literal["COMPACT", "COMPRESSED", "DYNAMIC", "FIXED", "REDUNDANT", "PAGED"]
            | None
        ) = None,
    ): ...
    # Sync
    def Create(self, if_not_exists: bool = False) -> Logs: ...
    def Drop(self, if_exists: bool = False) -> Logs: ...
    def Empty(self) -> bool: ...
    # Async
    async def aioCreate(self, if_not_exists: bool = False) -> Logs: ...
    async def aioDrop(self, if_exists: bool = False) -> Logs: ...
    async def aioEmpty(self) -> bool: ...

class TempTableManager:
    def __init__(
        self,
        temp_table: TempTable,
        conn: PoolConnection | PoolSyncConnection,
    ): ...
    # Sync
    def __enter__(self) -> TempTable: ...
    def __exit__(self, exc_type, exc_val, exc_tb): ...
    # Async
    async def __aenter__(self) -> TempTable: ...
    async def __aexit__(self, exc_type, exc_val, exc_tb): ...

# Tables -----------------------------------------------------------------------------------------------------
class Tables(Elements):
    def __init__(self, *tables: Table): ...
    # Property
    @property
    def qualified_names(self) -> tuple[str]: ...
    @property
    def elements(self) -> tuple[Table]: ...
    # Collection
    def search_name(
        self,
        *names: str | Table,
        exact: bool = True,
    ) -> Tables: ...
    def search_type(
        self,
        *types: str | type | Table,
        exact: bool = True,
    ) -> Tables: ...
    def filter(self, *elements: str | Table | Tables) -> Tables: ...
    def issubset(self, *elements: str | Table | Tables) -> bool: ...
    def add(self, element: Table) -> bool: ...
    def remove(self, element: str | Table) -> bool: ...
    # Setter
    def setup(
        self,
        db_name: str,
        charset: str | Charset,
        collate: str | None,
        pool: Pool,
    ) -> bool: ...
    # Accessors
    def values(self) -> tuple[Table]: ...
    def items(self) -> tuple[tuple[str, Table]]: ...
    def get(self, key: str | Table, default: Any = None) -> Table | Any: ...
    # Copy
    def copy(self) -> Self: ...
    # Special Methods
    def __getitem__(self, key: str | Table) -> Table: ...
    def __contains__(self, key: str | Table) -> bool: ...
    def __iter__(self) -> Iterator[Table]: ...

# Metadata ---------------------------------------------------------------------------------------------------
class TableMetadata(Metadata):
    def __init__(self, meta: dict): ...
    # Property
    @property
    def catelog_name(self) -> str: ...
    @property
    def db_name(self) -> str: ...
    @property
    def tb_name(self) -> str: ...
    @property
    def tb_type(self) -> str: ...
    @property
    def engine(self) -> str: ...
    @property
    def version(self) -> int: ...
    @property
    def row_format(self) -> str | None: ...
    @property
    def table_rows(self) -> int: ...
    @property
    def avg_row_length(self) -> int: ...
    @property
    def data_length(self) -> int: ...
    @property
    def max_data_length(self) -> int | None: ...
    @property
    def index_length(self) -> int: ...
    @property
    def data_free(self) -> int: ...
    @property
    def auto_increment(self) -> int | None: ...
    @property
    def create_time(self) -> datetime.datetime: ...
    @property
    def update_time(self) -> datetime.datetime | None: ...
    @property
    def check_time(self) -> datetime.datetime | None: ...
    @property
    def charset(self) -> Charset: ...
    @property
    def check_sum(self) -> int | None: ...
    @property
    def options(self) -> str: ...
    @property
    def comment(self) -> str: ...
    @property
    def engine_attribute(self) -> str | None: ...
    @property
    def secondary_engine_attribute(self) -> str | None: ...
    @property
    def encryption(self) -> bool: ...
    @property
    def partitioned(self) -> bool: ...

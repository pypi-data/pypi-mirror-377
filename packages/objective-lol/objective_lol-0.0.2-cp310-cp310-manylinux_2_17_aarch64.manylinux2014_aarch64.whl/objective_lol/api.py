
# python wrapper for package github.com/bjia56/objective-lol/pkg/api within overall package api
# This is what you import to use the package.
# File is generated by gopy. Do not edit.
# gopy build -no-make -dynamic-link=True -symbols=False -output /project/python/build/lib.linux-aarch64-cpython-310/objective_lol --vm /project/python/.toolchain/python/python-3.10.18/bin/python3 .

# the following is required to enable dlopen to open the _go.so file
import os,sys,inspect,collections
try:
	import collections.abc as _collections_abc
except ImportError:
	_collections_abc = collections

cwd = os.getcwd()
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
os.chdir(currentdir)
from . import _api
from . import go

os.chdir(cwd)

# to use this code in your end-user python file, import it as follows:
# from api import api
# and then refer to everything using api. prefix
# packages imported by this package listed below:




# ---- Types ---

# Python type for slice []api.GoValue
class Slice_api_GoValue(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_api.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_api.IncRef(self.handle)
		else:
			self.handle = _api.Slice_api_GoValue_CTor()
			_api.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_api_GoValue.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_api.DecRef(self.handle)
	def __str__(self):
		s = 'api.Slice_api_GoValue len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'api.Slice_api_GoValue([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _api.Slice_api_GoValue_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _api.Slice_api_GoValue_len(self.handle)
				return Slice_api_GoValue(handle=_api.Slice_api_GoValue_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return GoValue(handle=_api.Slice_api_GoValue_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_api.Slice_api_GoValue_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_api_GoValue.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = GoValue(handle=_api.Slice_api_GoValue_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_api.Slice_api_GoValue_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []environment.Parameter
class Slice_environment_Parameter(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_api.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_api.IncRef(self.handle)
		else:
			self.handle = _api.Slice_environment_Parameter_CTor()
			_api.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_environment_Parameter.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_api.DecRef(self.handle)
	def __str__(self):
		s = 'api.Slice_environment_Parameter len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'api.Slice_environment_Parameter([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _api.Slice_environment_Parameter_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _api.Slice_environment_Parameter_len(self.handle)
				return Slice_environment_Parameter(handle=_api.Slice_environment_Parameter_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.environment_Parameter(handle=_api.Slice_environment_Parameter_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_api.Slice_environment_Parameter_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_environment_Parameter.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.environment_Parameter(handle=_api.Slice_environment_Parameter_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_api.Slice_environment_Parameter_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []environment.Value
class Slice_environment_Value(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_api.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_api.IncRef(self.handle)
		else:
			self.handle = _api.Slice_environment_Value_CTor()
			_api.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_environment_Value.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_api.DecRef(self.handle)
	def __str__(self):
		s = 'api.Slice_environment_Value len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'api.Slice_environment_Value([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _api.Slice_environment_Value_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _api.Slice_environment_Value_len(self.handle)
				return Slice_environment_Value(handle=_api.Slice_environment_Value_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.environment_Value(handle=_api.Slice_environment_Value_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_api.Slice_environment_Value_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_environment_Value.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.environment_Value(handle=_api.Slice_environment_Value_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_api.Slice_environment_Value_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for map map[string]*api.ClassMethod
class Map_string_Ptr_api_ClassMethod(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_api.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_api.IncRef(self.handle)
		else:
			self.handle = _api.Map_string_Ptr_api_ClassMethod_CTor()
			_api.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_Ptr_api_ClassMethod.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_api.Map_string_Ptr_api_ClassMethod_set(self.handle, k, v)
	def __del__(self):
		_api.DecRef(self.handle)
	def __str__(self):
		s = 'api.Map_string_Ptr_api_ClassMethod len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'api.Map_string_Ptr_api_ClassMethod({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _api.Map_string_Ptr_api_ClassMethod_len(self.handle)
	def __getitem__(self, key):
		return ClassMethod(handle=_api.Map_string_Ptr_api_ClassMethod_elem(self.handle, key))
	def __setitem__(self, key, value):
		_api.Map_string_Ptr_api_ClassMethod_set(self.handle, key, value.handle)
	def __delitem__(self, key):
		return _api.Map_string_Ptr_api_ClassMethod_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_api.Map_string_Ptr_api_ClassMethod_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _api.Map_string_Ptr_api_ClassMethod_contains(self.handle, key)

# Python type for map map[string]*api.ClassVariable
class Map_string_Ptr_api_ClassVariable(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_api.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_api.IncRef(self.handle)
		else:
			self.handle = _api.Map_string_Ptr_api_ClassVariable_CTor()
			_api.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_Ptr_api_ClassVariable.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_api.Map_string_Ptr_api_ClassVariable_set(self.handle, k, v)
	def __del__(self):
		_api.DecRef(self.handle)
	def __str__(self):
		s = 'api.Map_string_Ptr_api_ClassVariable len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'api.Map_string_Ptr_api_ClassVariable({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _api.Map_string_Ptr_api_ClassVariable_len(self.handle)
	def __getitem__(self, key):
		return ClassVariable(handle=_api.Map_string_Ptr_api_ClassVariable_elem(self.handle, key))
	def __setitem__(self, key, value):
		_api.Map_string_Ptr_api_ClassVariable_set(self.handle, key, value.handle)
	def __delitem__(self, key):
		return _api.Map_string_Ptr_api_ClassVariable_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_api.Map_string_Ptr_api_ClassVariable_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _api.Map_string_Ptr_api_ClassVariable_contains(self.handle, key)

# Python type for map map[string]*environment.Class
class Map_string_Ptr_environment_Class(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_api.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_api.IncRef(self.handle)
		else:
			self.handle = _api.Map_string_Ptr_environment_Class_CTor()
			_api.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_Ptr_environment_Class.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_api.Map_string_Ptr_environment_Class_set(self.handle, k, v)
	def __del__(self):
		_api.DecRef(self.handle)
	def __str__(self):
		s = 'api.Map_string_Ptr_environment_Class len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'api.Map_string_Ptr_environment_Class({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _api.Map_string_Ptr_environment_Class_len(self.handle)
	def __getitem__(self, key):
		return go.Ptr_environment_Class(handle=_api.Map_string_Ptr_environment_Class_elem(self.handle, key))
	def __setitem__(self, key, value):
		_api.Map_string_Ptr_environment_Class_set(self.handle, key, value.handle)
	def __delitem__(self, key):
		return _api.Map_string_Ptr_environment_Class_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_api.Map_string_Ptr_environment_Class_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _api.Map_string_Ptr_environment_Class_contains(self.handle, key)

# Python type for map map[string]*environment.Function
class Map_string_Ptr_environment_Function(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_api.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_api.IncRef(self.handle)
		else:
			self.handle = _api.Map_string_Ptr_environment_Function_CTor()
			_api.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_Ptr_environment_Function.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_api.Map_string_Ptr_environment_Function_set(self.handle, k, v)
	def __del__(self):
		_api.DecRef(self.handle)
	def __str__(self):
		s = 'api.Map_string_Ptr_environment_Function len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'api.Map_string_Ptr_environment_Function({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _api.Map_string_Ptr_environment_Function_len(self.handle)
	def __getitem__(self, key):
		return go.Ptr_environment_Function(handle=_api.Map_string_Ptr_environment_Function_elem(self.handle, key))
	def __setitem__(self, key, value):
		_api.Map_string_Ptr_environment_Function_set(self.handle, key, value.handle)
	def __delitem__(self, key):
		return _api.Map_string_Ptr_environment_Function_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_api.Map_string_Ptr_environment_Function_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _api.Map_string_Ptr_environment_Function_contains(self.handle, key)

# Python type for map map[string]*environment.MemberVariable
class Map_string_Ptr_environment_MemberVariable(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_api.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_api.IncRef(self.handle)
		else:
			self.handle = _api.Map_string_Ptr_environment_MemberVariable_CTor()
			_api.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_Ptr_environment_MemberVariable.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_api.Map_string_Ptr_environment_MemberVariable_set(self.handle, k, v)
	def __del__(self):
		_api.DecRef(self.handle)
	def __str__(self):
		s = 'api.Map_string_Ptr_environment_MemberVariable len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'api.Map_string_Ptr_environment_MemberVariable({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _api.Map_string_Ptr_environment_MemberVariable_len(self.handle)
	def __getitem__(self, key):
		return go.Ptr_environment_MemberVariable(handle=_api.Map_string_Ptr_environment_MemberVariable_elem(self.handle, key))
	def __setitem__(self, key, value):
		_api.Map_string_Ptr_environment_MemberVariable_set(self.handle, key, value.handle)
	def __delitem__(self, key):
		return _api.Map_string_Ptr_environment_MemberVariable_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_api.Map_string_Ptr_environment_MemberVariable_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _api.Map_string_Ptr_environment_MemberVariable_contains(self.handle, key)

# Python type for map map[string]*environment.Variable
class Map_string_Ptr_environment_Variable(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_api.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_api.IncRef(self.handle)
		else:
			self.handle = _api.Map_string_Ptr_environment_Variable_CTor()
			_api.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_Ptr_environment_Variable.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_api.Map_string_Ptr_environment_Variable_set(self.handle, k, v)
	def __del__(self):
		_api.DecRef(self.handle)
	def __str__(self):
		s = 'api.Map_string_Ptr_environment_Variable len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'api.Map_string_Ptr_environment_Variable({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _api.Map_string_Ptr_environment_Variable_len(self.handle)
	def __getitem__(self, key):
		return go.Ptr_environment_Variable(handle=_api.Map_string_Ptr_environment_Variable_elem(self.handle, key))
	def __setitem__(self, key, value):
		_api.Map_string_Ptr_environment_Variable_set(self.handle, key, value.handle)
	def __delitem__(self, key):
		return _api.Map_string_Ptr_environment_Variable_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_api.Map_string_Ptr_environment_Variable_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _api.Map_string_Ptr_environment_Variable_contains(self.handle, key)

# Python type for map map[string]api.GoValue
class Map_string_api_GoValue(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_api.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_api.IncRef(self.handle)
		else:
			self.handle = _api.Map_string_api_GoValue_CTor()
			_api.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_api_GoValue.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_api.Map_string_api_GoValue_set(self.handle, k, v)
	def __del__(self):
		_api.DecRef(self.handle)
	def __str__(self):
		s = 'api.Map_string_api_GoValue len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'api.Map_string_api_GoValue({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _api.Map_string_api_GoValue_len(self.handle)
	def __getitem__(self, key):
		return GoValue(handle=_api.Map_string_api_GoValue_elem(self.handle, key))
	def __setitem__(self, key, value):
		_api.Map_string_api_GoValue_set(self.handle, key, value.handle)
	def __delitem__(self, key):
		return _api.Map_string_api_GoValue_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_api.Map_string_api_GoValue_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _api.Map_string_api_GoValue_contains(self.handle, key)


#---- Enums from Go (collections of consts with same type) ---


#---- Constants from Go: Python can only ask that you please don't change these! ---
CompileErrorType = "compile"
ConfigErrorType = "config"
ConversionErrorType = "conversion"
ForeignModuleNamespace = "foreign:anonymous"
GoValueIDKey = "__GoValue_id"
RuntimeErrorType = "runtime"
TimeoutErrorType = "timeout"


# ---- Global Variables: can only use functions to access ---


# ---- Interfaces ---


# ---- Structs ---

# Python type for struct api.VM
class VM(go.GoClass):
	"""VM represents an Objective-LOL virtual machine instance\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_api.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_api.IncRef(self.handle)
		else:
			self.handle = _api.api_VM_CTor()
			_api.IncRef(self.handle)
	def __del__(self):
		_api.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'api.VM{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'api.VM ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def GetCompatibilityShim(self):
		"""GetCompatibilityShim() object
		
		GetCompatibilityShim returns a compatibility shim for the VM
		"""
		return VMCompatibilityShim(handle=_api.api_VM_GetCompatibilityShim(self.handle))
	def Execute(self, code):
		"""Execute(str code) object, str
		
		Execute executes Objective-LOL code from a string
		"""
		return ExecutionResult(handle=_api.api_VM_Execute(self.handle, code))
	def ExecuteWithContext(self, ctx, code):
		"""ExecuteWithContext(object ctx, str code) object, str
		
		ExecuteWithContext executes code with a context for cancellation/timeout
		"""
		return ExecutionResult(handle=_api.api_VM_ExecuteWithContext(self.handle, ctx.handle, code))
	def NewObjectInstance(self, className):
		"""NewObjectInstance(str className) object, str"""
		return GoValue(handle=_api.api_VM_NewObjectInstance(self.handle, className))
	def Call(self, functionName, args):
		"""Call(str functionName, []object args) object, str
		
		Call calls an Objective-LOL function with the given arguments
		"""
		return GoValue(handle=_api.api_VM_Call(self.handle, functionName, args.handle))
	def CallMethod(self, object, methodName, args):
		"""CallMethod(object object, str methodName, []object args) object, str
		
		CallMethod calls a method on an Objective-LOL object
		"""
		return GoValue(handle=_api.api_VM_CallMethod(self.handle, object.handle, methodName, args.handle))
	def DefineVariable(self, name, value, constant):
		"""DefineVariable(str name, object value, bool constant) str
		
		DefineVariable defines a global variable in the VM
		"""
		return _api.api_VM_DefineVariable(self.handle, name, value.handle, constant)
	def SetVariable(self, variableName, value):
		"""SetVariable(str variableName, object value) str
		
		SetVariable sets a variable in the global environment
		"""
		return _api.api_VM_SetVariable(self.handle, variableName, value.handle)
	def GetVariable(self, variableName):
		"""GetVariable(str variableName) object, str
		
		Get gets a variable from the global environment
		"""
		return GoValue(handle=_api.api_VM_GetVariable(self.handle, variableName))
	def DefineClass(self, classDef):
		"""DefineClass(object classDef) str"""
		return _api.api_VM_DefineClass(self.handle, classDef.handle)

# Python type for struct api.VMCompatibilityShim
class VMCompatibilityShim(go.GoClass):
	"""VMCompatibilityShim is a shim to provide compatibility for external\nlanguages that cannot interact with the standard VM interface through\nGo types. Message passing is done through JSON strings.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_api.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_api.IncRef(self.handle)
		else:
			self.handle = _api.api_VMCompatibilityShim_CTor()
			_api.IncRef(self.handle)
	def __del__(self):
		_api.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'api.VMCompatibilityShim{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'api.VMCompatibilityShim ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def DefineFunction(self, id, name, argc, function):
		"""DefineFunction(str id, str name, int argc, callable function) str
		
		DefineFunction defines a global function with maximum compatibility,
		wrapping arguments and return values as JSON strings.
		An optional id cookie is passed back to the function to identify it.
		jsonArgs is a JSON array string of the arguments.
		The function should return a JSON object string with "result" and "error" fields.
		"""
		return _api.api_VMCompatibilityShim_DefineFunction(self.handle, id, name, argc, function)
	def BuildNewClassVariableWithGetter(self, variable, getterID, getter):
		"""BuildNewClassVariableWithGetter(object variable, str getterID, callable getter) object"""
		return ClassVariable(handle=_api.api_VMCompatibilityShim_BuildNewClassVariableWithGetter(self.handle, variable.handle, getterID, getter))
	def BuildNewClassVariableWithSetter(self, variable, setterID, setter):
		"""BuildNewClassVariableWithSetter(object variable, str setterID, callable setter) object"""
		return ClassVariable(handle=_api.api_VMCompatibilityShim_BuildNewClassVariableWithSetter(self.handle, variable.handle, setterID, setter))
	def BuildNewClassMethod(self, method, id, function):
		"""BuildNewClassMethod(object method, str id, callable function) object"""
		return ClassMethod(handle=_api.api_VMCompatibilityShim_BuildNewClassMethod(self.handle, method.handle, id, function))
	def BuildNewUnknownFunctionHandler(self, id, function):
		"""BuildNewUnknownFunctionHandler(str id, callable function) object"""
		return UnknownFunctionHandler(handle=_api.api_VMCompatibilityShim_BuildNewUnknownFunctionHandler(self.handle, id, function))
	def IsClassDefined(self, name):
		"""IsClassDefined(str name) bool"""
		return _api.api_VMCompatibilityShim_IsClassDefined(self.handle, name)
	def LookupObject(self, id):
		"""LookupObject(str id) object, str"""
		return GoValue(handle=_api.api_VMCompatibilityShim_LookupObject(self.handle, id))
	def GetObjectMRO(self, id):
		"""GetObjectMRO(str id) []str, str"""
		return go.Slice_string(handle=_api.api_VMCompatibilityShim_GetObjectMRO(self.handle, id))
	def GetObjectImmediateFunctions(self, id):
		"""GetObjectImmediateFunctions(str id) []str, str"""
		return go.Slice_string(handle=_api.api_VMCompatibilityShim_GetObjectImmediateFunctions(self.handle, id))
	def GetObjectImmediateVariables(self, id):
		"""GetObjectImmediateVariables(str id) []str, str"""
		return go.Slice_string(handle=_api.api_VMCompatibilityShim_GetObjectImmediateVariables(self.handle, id))
	def AddVariableToObject(self, id, variable):
		"""AddVariableToObject(str id, object variable) str"""
		return _api.api_VMCompatibilityShim_AddVariableToObject(self.handle, id, variable.handle)

# Python type for struct api.VMError
class VMError(go.GoClass):
	"""VMError represents errors that can occur in the VM API\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_api.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_api.IncRef(self.handle)
		else:
			self.handle = _api.api_VMError_CTor()
			_api.IncRef(self.handle)
			if  0 < len(args):
				self.Type = args[0]
			if "Type" in kwargs:
				self.Type = kwargs["Type"]
			if  1 < len(args):
				self.Message = args[1]
			if "Message" in kwargs:
				self.Message = kwargs["Message"]
			if  2 < len(args):
				self.Source = args[2]
			if "Source" in kwargs:
				self.Source = kwargs["Source"]
			if  4 < len(args):
				self.Duration = args[4]
			if "Duration" in kwargs:
				self.Duration = kwargs["Duration"]
	def __del__(self):
		_api.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'api.VMError{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'api.VMError ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Type(self):
		return _api.api_VMError_Type_Get(self.handle)
	@Type.setter
	def Type(self, value):
		if isinstance(value, go.GoClass):
			_api.api_VMError_Type_Set(self.handle, value.handle)
		else:
			_api.api_VMError_Type_Set(self.handle, value)
	@property
	def Message(self):
		return _api.api_VMError_Message_Get(self.handle)
	@Message.setter
	def Message(self, value):
		if isinstance(value, go.GoClass):
			_api.api_VMError_Message_Set(self.handle, value.handle)
		else:
			_api.api_VMError_Message_Set(self.handle, value)
	@property
	def Source(self):
		return SourceLocation(handle=_api.api_VMError_Source_Get(self.handle))
	@Source.setter
	def Source(self, value):
		if isinstance(value, go.GoClass):
			_api.api_VMError_Source_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Duration(self):
		return _api.api_VMError_Duration_Get(self.handle)
	@Duration.setter
	def Duration(self, value):
		if isinstance(value, go.GoClass):
			_api.api_VMError_Duration_Set(self.handle, value.handle)
		else:
			_api.api_VMError_Duration_Set(self.handle, value)
	def Error(self):
		"""Error() str"""
		return _api.api_VMError_Error(self.handle)
	def Unwrap(self):
		"""Unwrap() str"""
		return _api.api_VMError_Unwrap(self.handle)
	def IsCompileError(self):
		"""IsCompileError() bool
		
		IsCompileError returns true if the error is a compilation error
		"""
		return _api.api_VMError_IsCompileError(self.handle)
	def IsRuntimeError(self):
		"""IsRuntimeError() bool
		
		IsRuntimeError returns true if the error is a runtime error
		"""
		return _api.api_VMError_IsRuntimeError(self.handle)
	def IsTimeoutError(self):
		"""IsTimeoutError() bool
		
		IsTimeoutError returns true if the error is a timeout error
		"""
		return _api.api_VMError_IsTimeoutError(self.handle)
	def IsConversionError(self):
		"""IsConversionError() bool
		
		IsConversionError returns true if the error is a type conversion error
		"""
		return _api.api_VMError_IsConversionError(self.handle)
	def IsConfigError(self):
		"""IsConfigError() bool
		
		IsConfigError returns true if the error is a configuration error
		"""
		return _api.api_VMError_IsConfigError(self.handle)

# Python type for struct api.ClassDefinition
class ClassDefinition(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_api.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_api.IncRef(self.handle)
		else:
			self.handle = _api.api_ClassDefinition_CTor()
			_api.IncRef(self.handle)
			if  0 < len(args):
				self.Name = args[0]
			if "Name" in kwargs:
				self.Name = kwargs["Name"]
			if  1 < len(args):
				self.PublicVariables = args[1]
			if "PublicVariables" in kwargs:
				self.PublicVariables = kwargs["PublicVariables"]
			if  2 < len(args):
				self.PrivateVariables = args[2]
			if "PrivateVariables" in kwargs:
				self.PrivateVariables = kwargs["PrivateVariables"]
			if  3 < len(args):
				self.SharedVariables = args[3]
			if "SharedVariables" in kwargs:
				self.SharedVariables = kwargs["SharedVariables"]
			if  4 < len(args):
				self.PublicMethods = args[4]
			if "PublicMethods" in kwargs:
				self.PublicMethods = kwargs["PublicMethods"]
			if  5 < len(args):
				self.PrivateMethods = args[5]
			if "PrivateMethods" in kwargs:
				self.PrivateMethods = kwargs["PrivateMethods"]
			if  6 < len(args):
				self.UnknownFunctionHandler = args[6]
			if "UnknownFunctionHandler" in kwargs:
				self.UnknownFunctionHandler = kwargs["UnknownFunctionHandler"]
	def __del__(self):
		_api.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'api.ClassDefinition{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'api.ClassDefinition ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Name(self):
		return _api.api_ClassDefinition_Name_Get(self.handle)
	@Name.setter
	def Name(self, value):
		if isinstance(value, go.GoClass):
			_api.api_ClassDefinition_Name_Set(self.handle, value.handle)
		else:
			_api.api_ClassDefinition_Name_Set(self.handle, value)
	@property
	def PublicVariables(self):
		return Map_string_Ptr_api_ClassVariable(handle=_api.api_ClassDefinition_PublicVariables_Get(self.handle))
	@PublicVariables.setter
	def PublicVariables(self, value):
		if isinstance(value, go.GoClass):
			_api.api_ClassDefinition_PublicVariables_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def PrivateVariables(self):
		return Map_string_Ptr_api_ClassVariable(handle=_api.api_ClassDefinition_PrivateVariables_Get(self.handle))
	@PrivateVariables.setter
	def PrivateVariables(self, value):
		if isinstance(value, go.GoClass):
			_api.api_ClassDefinition_PrivateVariables_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def SharedVariables(self):
		return Map_string_Ptr_api_ClassVariable(handle=_api.api_ClassDefinition_SharedVariables_Get(self.handle))
	@SharedVariables.setter
	def SharedVariables(self, value):
		if isinstance(value, go.GoClass):
			_api.api_ClassDefinition_SharedVariables_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def PublicMethods(self):
		return Map_string_Ptr_api_ClassMethod(handle=_api.api_ClassDefinition_PublicMethods_Get(self.handle))
	@PublicMethods.setter
	def PublicMethods(self, value):
		if isinstance(value, go.GoClass):
			_api.api_ClassDefinition_PublicMethods_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def PrivateMethods(self):
		return Map_string_Ptr_api_ClassMethod(handle=_api.api_ClassDefinition_PrivateMethods_Get(self.handle))
	@PrivateMethods.setter
	def PrivateMethods(self, value):
		if isinstance(value, go.GoClass):
			_api.api_ClassDefinition_PrivateMethods_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def UnknownFunctionHandler(self):
		return UnknownFunctionHandler(handle=_api.api_ClassDefinition_UnknownFunctionHandler_Get(self.handle))
	@UnknownFunctionHandler.setter
	def UnknownFunctionHandler(self, value):
		if isinstance(value, go.GoClass):
			_api.api_ClassDefinition_UnknownFunctionHandler_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct api.ClassMethod
class ClassMethod(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_api.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_api.IncRef(self.handle)
		else:
			self.handle = _api.api_ClassMethod_CTor()
			_api.IncRef(self.handle)
			if  0 < len(args):
				self.Name = args[0]
			if "Name" in kwargs:
				self.Name = kwargs["Name"]
			if  1 < len(args):
				self.Argc = args[1]
			if "Argc" in kwargs:
				self.Argc = kwargs["Argc"]
	def __del__(self):
		_api.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'api.ClassMethod{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'api.ClassMethod ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Name(self):
		return _api.api_ClassMethod_Name_Get(self.handle)
	@Name.setter
	def Name(self, value):
		if isinstance(value, go.GoClass):
			_api.api_ClassMethod_Name_Set(self.handle, value.handle)
		else:
			_api.api_ClassMethod_Name_Set(self.handle, value)
	@property
	def Argc(self):
		return _api.api_ClassMethod_Argc_Get(self.handle)
	@Argc.setter
	def Argc(self, value):
		if isinstance(value, go.GoClass):
			_api.api_ClassMethod_Argc_Set(self.handle, value.handle)
		else:
			_api.api_ClassMethod_Argc_Set(self.handle, value)

# Python type for struct api.ClassVariable
class ClassVariable(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_api.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_api.IncRef(self.handle)
		else:
			self.handle = _api.api_ClassVariable_CTor()
			_api.IncRef(self.handle)
			if  0 < len(args):
				self.Name = args[0]
			if "Name" in kwargs:
				self.Name = kwargs["Name"]
			if  1 < len(args):
				self.Value = args[1]
			if "Value" in kwargs:
				self.Value = kwargs["Value"]
			if  2 < len(args):
				self.Locked = args[2]
			if "Locked" in kwargs:
				self.Locked = kwargs["Locked"]
	def __del__(self):
		_api.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'api.ClassVariable{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'api.ClassVariable ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Name(self):
		return _api.api_ClassVariable_Name_Get(self.handle)
	@Name.setter
	def Name(self, value):
		if isinstance(value, go.GoClass):
			_api.api_ClassVariable_Name_Set(self.handle, value.handle)
		else:
			_api.api_ClassVariable_Name_Set(self.handle, value)
	@property
	def Value(self):
		return GoValue(handle=_api.api_ClassVariable_Value_Get(self.handle))
	@Value.setter
	def Value(self, value):
		if isinstance(value, go.GoClass):
			_api.api_ClassVariable_Value_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Locked(self):
		return _api.api_ClassVariable_Locked_Get(self.handle)
	@Locked.setter
	def Locked(self, value):
		if isinstance(value, go.GoClass):
			_api.api_ClassVariable_Locked_Set(self.handle, value.handle)
		else:
			_api.api_ClassVariable_Locked_Set(self.handle, value)

# Python type for struct api.ExecutionResult
class ExecutionResult(go.GoClass):
	"""ExecutionResult represents the result of executing Objective-LOL code\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_api.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_api.IncRef(self.handle)
		else:
			self.handle = _api.api_ExecutionResult_CTor()
			_api.IncRef(self.handle)
			if  0 < len(args):
				self.Value = args[0]
			if "Value" in kwargs:
				self.Value = kwargs["Value"]
			if  1 < len(args):
				self.RawValue = args[1]
			if "RawValue" in kwargs:
				self.RawValue = kwargs["RawValue"]
			if  2 < len(args):
				self.Output = args[2]
			if "Output" in kwargs:
				self.Output = kwargs["Output"]
	def __del__(self):
		_api.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'api.ExecutionResult{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'api.ExecutionResult ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Value(self):
		"""Return value from the execution (e.g., from MAIN function)
		"""
		return GoValue(handle=_api.api_ExecutionResult_Value_Get(self.handle))
	@Value.setter
	def Value(self, value):
		if isinstance(value, go.GoClass):
			_api.api_ExecutionResult_Value_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def RawValue(self):
		"""Raw Objective-LOL value (for advanced use)
		"""
		return go.environment_Value(handle=_api.api_ExecutionResult_RawValue_Get(self.handle))
	@RawValue.setter
	def RawValue(self, value):
		if isinstance(value, go.GoClass):
			_api.api_ExecutionResult_RawValue_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Output(self):
		"""Output captured during execution (if configured)
		"""
		return _api.api_ExecutionResult_Output_Get(self.handle)
	@Output.setter
	def Output(self, value):
		if isinstance(value, go.GoClass):
			_api.api_ExecutionResult_Output_Set(self.handle, value.handle)
		else:
			_api.api_ExecutionResult_Output_Set(self.handle, value)

# Python type for struct api.GoValue
class GoValue(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_api.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_api.IncRef(self.handle)
		else:
			self.handle = _api.api_GoValue_CTor()
			_api.IncRef(self.handle)
	def __del__(self):
		_api.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'api.GoValue{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'api.GoValue ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def ID(self):
		"""ID() str"""
		return _api.api_GoValue_ID(self.handle)
	def MarshalJSON(self):
		"""MarshalJSON() []int, str"""
		return go.Slice_byte(handle=_api.api_GoValue_MarshalJSON(self.handle))
	def Type(self):
		"""Type() str"""
		return _api.api_GoValue_Type(self.handle)
	def Int(self):
		"""Int() long, str"""
		return _api.api_GoValue_Int(self.handle)
	def Float(self):
		"""Float() float, str"""
		return _api.api_GoValue_Float(self.handle)
	def String(self):
		"""String() str, str"""
		return _api.api_GoValue_String(self.handle)
	def Bool(self):
		"""Bool() bool, str"""
		return _api.api_GoValue_Bool(self.handle)
	def Slice(self):
		"""Slice() []object, str"""
		return Slice_api_GoValue(handle=_api.api_GoValue_Slice(self.handle))
	def Map(self):
		"""Map() object, str"""
		return Map_string_api_GoValue(handle=_api.api_GoValue_Map(self.handle))
	def Object(self):
		"""Object() object, str"""
		return go.Ptr_environment_ObjectInstance(handle=_api.api_GoValue_Object(self.handle))

# Python type for struct api.SourceLocation
class SourceLocation(go.GoClass):
	"""SourceLocation represents a location in source code\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_api.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_api.IncRef(self.handle)
		else:
			self.handle = _api.api_SourceLocation_CTor()
			_api.IncRef(self.handle)
			if  0 < len(args):
				self.Filename = args[0]
			if "Filename" in kwargs:
				self.Filename = kwargs["Filename"]
			if  1 < len(args):
				self.Line = args[1]
			if "Line" in kwargs:
				self.Line = kwargs["Line"]
			if  2 < len(args):
				self.Column = args[2]
			if "Column" in kwargs:
				self.Column = kwargs["Column"]
	def __del__(self):
		_api.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'api.SourceLocation{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'api.SourceLocation ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Filename(self):
		return _api.api_SourceLocation_Filename_Get(self.handle)
	@Filename.setter
	def Filename(self, value):
		if isinstance(value, go.GoClass):
			_api.api_SourceLocation_Filename_Set(self.handle, value.handle)
		else:
			_api.api_SourceLocation_Filename_Set(self.handle, value)
	@property
	def Line(self):
		return _api.api_SourceLocation_Line_Get(self.handle)
	@Line.setter
	def Line(self, value):
		if isinstance(value, go.GoClass):
			_api.api_SourceLocation_Line_Set(self.handle, value.handle)
		else:
			_api.api_SourceLocation_Line_Set(self.handle, value)
	@property
	def Column(self):
		return _api.api_SourceLocation_Column_Get(self.handle)
	@Column.setter
	def Column(self, value):
		if isinstance(value, go.GoClass):
			_api.api_SourceLocation_Column_Set(self.handle, value.handle)
		else:
			_api.api_SourceLocation_Column_Set(self.handle, value)

# Python type for struct api.UnknownFunctionHandler
class UnknownFunctionHandler(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_api.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_api.IncRef(self.handle)
		else:
			self.handle = _api.api_UnknownFunctionHandler_CTor()
			_api.IncRef(self.handle)
	def __del__(self):
		_api.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'api.UnknownFunctionHandler{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'api.UnknownFunctionHandler ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'

# Python type for struct api.VMConfig
class VMConfig(go.GoClass):
	"""VMConfig holds configuration options for the VM\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_api.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_api.IncRef(self.handle)
		else:
			self.handle = _api.api_VMConfig_CTor()
			_api.IncRef(self.handle)
			if  0 < len(args):
				self.Stdout = args[0]
			if "Stdout" in kwargs:
				self.Stdout = kwargs["Stdout"]
			if  1 < len(args):
				self.Stdin = args[1]
			if "Stdin" in kwargs:
				self.Stdin = kwargs["Stdin"]
			if  2 < len(args):
				self.Timeout = args[2]
			if "Timeout" in kwargs:
				self.Timeout = kwargs["Timeout"]
			if  3 < len(args):
				self.WorkingDirectory = args[3]
			if "WorkingDirectory" in kwargs:
				self.WorkingDirectory = kwargs["WorkingDirectory"]
	def __del__(self):
		_api.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'api.VMConfig{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'api.VMConfig ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Stdout(self):
		"""I/O configuration
		"""
		return go.io_Writer(handle=_api.api_VMConfig_Stdout_Get(self.handle))
	@Stdout.setter
	def Stdout(self, value):
		if isinstance(value, go.GoClass):
			_api.api_VMConfig_Stdout_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Stdin(self):
		return go.io_Reader(handle=_api.api_VMConfig_Stdin_Get(self.handle))
	@Stdin.setter
	def Stdin(self, value):
		if isinstance(value, go.GoClass):
			_api.api_VMConfig_Stdin_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Timeout(self):
		"""Execution configuration
		"""
		return _api.api_VMConfig_Timeout_Get(self.handle)
	@Timeout.setter
	def Timeout(self, value):
		if isinstance(value, go.GoClass):
			_api.api_VMConfig_Timeout_Set(self.handle, value.handle)
		else:
			_api.api_VMConfig_Timeout_Set(self.handle, value)
	@property
	def WorkingDirectory(self):
		return _api.api_VMConfig_WorkingDirectory_Get(self.handle)
	@WorkingDirectory.setter
	def WorkingDirectory(self, value):
		if isinstance(value, go.GoClass):
			_api.api_VMConfig_WorkingDirectory_Set(self.handle, value.handle)
		else:
			_api.api_VMConfig_WorkingDirectory_Set(self.handle, value)
	def Validate(self):
		"""Validate() str
		
		Validate checks if the configuration is valid
		"""
		return _api.api_VMConfig_Validate(self.handle)


# ---- Slices ---


# ---- Maps ---


# ---- Constructors ---
def NewVM(config):
	"""NewVM(object config) object, str
	
	NewVM creates a new VM instance with the given config
	"""
	return VM(handle=_api.api_NewVM(config.handle))
def NewConversionError(message, wrapped):
	"""NewConversionError(str message, str wrapped) object
	
	NewConversionError creates a new type conversion error
	"""
	return VMError(handle=_api.api_NewConversionError(message, wrapped))
def NewConfigError(message, wrapped):
	"""NewConfigError(str message, str wrapped) object
	
	NewConfigError creates a new configuration error
	"""
	return VMError(handle=_api.api_NewConfigError(message, wrapped))
def NewCompileError(message, source):
	"""NewCompileError(str message, object source) object
	
	NewCompileError creates a new compile error
	"""
	return VMError(handle=_api.api_NewCompileError(message, source.handle))
def NewRuntimeError(message, source):
	"""NewRuntimeError(str message, object source) object
	
	NewRuntimeError creates a new runtime error
	"""
	return VMError(handle=_api.api_NewRuntimeError(message, source.handle))
def NewTimeoutError(duration):
	"""NewTimeoutError(long duration) object
	
	NewTimeoutError creates a new timeout error
	"""
	return VMError(handle=_api.api_NewTimeoutError(duration))
def NewClassDefinition():
	"""NewClassDefinition() object"""
	return ClassDefinition(handle=_api.api_NewClassDefinition())
def WrapAny(value):
	"""WrapAny(str value) object"""
	return GoValue(handle=_api.api_WrapAny(value))
def ToGoValue(val):
	"""ToGoValue(object val) object, str
	
	ToGoValue converts an Objective-LOL value to a Go value
	"""
	return GoValue(handle=_api.api_ToGoValue(val.handle))
def WrapFloat(value):
	"""WrapFloat(float value) object"""
	return GoValue(handle=_api.api_WrapFloat(value))
def WrapObject(value):
	"""WrapObject(object value) object"""
	return GoValue(handle=_api.api_WrapObject(value.handle))
def WrapString(value):
	"""WrapString(str value) object"""
	return GoValue(handle=_api.api_WrapString(value))
def WrapBool(value):
	"""WrapBool(bool value) object"""
	return GoValue(handle=_api.api_WrapBool(value))
def WrapInt(value):
	"""WrapInt(long value) object"""
	return GoValue(handle=_api.api_WrapInt(value))
def DefaultConfig():
	"""DefaultConfig() object
	
	DefaultConfig returns a default configuration
	"""
	return VMConfig(handle=_api.api_DefaultConfig())


# ---- Functions ---
def FromGoValue(val):
	"""FromGoValue(object val) object, str
	
	FromGoValue converts a Go value to an Objective-LOL value
	"""
	return go.environment_Value(handle=_api.api_FromGoValue(val.handle))
def ConvertArguments(args):
	"""ConvertArguments([]object args) []object, str
	
	ConvertArguments converts a slice of Go values to Objective-LOL values
	"""
	return Slice_environment_Value(handle=_api.api_ConvertArguments(args.handle))
def LookupObject(id):
	"""LookupObject(str id) object, str"""
	return go.Ptr_environment_ObjectInstance(handle=_api.api_LookupObject(id))



/*
cgo stubs for package api.
File is generated by gopy. Do not edit.
gopy build -no-make -dynamic-link=True -symbols=False -output /project/python/build/lib.linux-x86_64-cpython-311/objective_lol --vm /project/python/.toolchain/python/python-3.11.13/bin/python3 .
*/

package main

/*

#cgo CFLAGS: "-I/project/python/.toolchain/python/python-3.11.13/include/python3.11" -Wno-error -Wno-implicit-function-declaration -Wno-int-conversion
#cgo LDFLAGS:  -pthread -shared

// #define Py_LIMITED_API // need full API for PyRun*
#include <Python.h>
typedef uint8_t bool;
// static inline is trick for avoiding need for extra .c file
// the following are used for build value -- switch on reflect.Kind
// or the types equivalent
static inline PyObject* gopy_build_bool(uint8_t val) {
	return Py_BuildValue("b", val);
}
static inline PyObject* gopy_build_int64(int64_t val) {
	return Py_BuildValue("k", val);
}
static inline PyObject* gopy_build_uint64(uint64_t val) {
	return Py_BuildValue("K", val);
}
static inline PyObject* gopy_build_float64(double val) {
	return Py_BuildValue("d", val);
}
static inline PyObject* gopy_build_string(const char* val) {
	return Py_BuildValue("s", val);
}
static inline void gopy_decref(PyObject* obj) { // macro
	Py_XDECREF(obj);
}
static inline void gopy_incref(PyObject* obj) { // macro
	Py_XINCREF(obj);
}
static inline int gopy_method_check(PyObject* obj) { // macro
	return PyMethod_Check(obj);
}
static inline void gopy_err_handle() {
	if(PyErr_Occurred() != NULL) {
		PyErr_Print();
	}
}

*/
import "C"
import (
	"errors"
	"reflect"
	"unsafe"

	"github.com/go-python/gopy/gopyh" // handler

	"context"
	"io"
	"time"

	"github.com/bjia56/objective-lol/pkg/api"
	"github.com/bjia56/objective-lol/pkg/environment"
)

// main doesn't do anything in lib / pkg mode, but is essential for exe mode
func main() {

}

// initialization functions -- can be called from python after library is loaded
// GoPyInitRunFile runs a separate python file -- call in GoPyInit if it
// steals the main thread e.g., for GUI event loop, as in GoGi startup.

//export GoPyInit
func GoPyInit() {

}

// type for the handle -- int64 for speed (can switch to string)
type GoHandle int64
type CGoHandle C.longlong

// DecRef decrements the reference count for the specified handle
// and deletes it it goes to zero.
//
//export DecRef
func DecRef(handle CGoHandle) {
	gopyh.DecRef(gopyh.CGoHandle(handle))
}

// IncRef increments the reference count for the specified handle.
//
//export IncRef
func IncRef(handle CGoHandle) {
	gopyh.IncRef(gopyh.CGoHandle(handle))
}

// NumHandles returns the number of handles currently in use.
//
//export NumHandles
func NumHandles() int {
	return gopyh.NumHandles()
}

// boolGoToPy converts a Go bool to python-compatible C.char
func boolGoToPy(b bool) C.char {
	if b {
		return 1
	}
	return 0
}

// boolPyToGo converts a python-compatible C.Char to Go bool
func boolPyToGo(b C.char) bool {
	if b != 0 {
		return true
	}
	return false
}

func complex64GoToPy(c complex64) *C.PyObject {
	return C.PyComplex_FromDoubles(C.double(real(c)), C.double(imag(c)))
}

func complex64PyToGo(o *C.PyObject) complex64 {
	v := C.PyComplex_AsCComplex(o)
	return complex(float32(v.real), float32(v.imag))
}

func complex128GoToPy(c complex128) *C.PyObject {
	return C.PyComplex_FromDoubles(C.double(real(c)), C.double(imag(c)))
}

func complex128PyToGo(o *C.PyObject) complex128 {
	v := C.PyComplex_AsCComplex(o)
	return complex(float64(v.real), float64(v.imag))
}

// errorGoToPy converts a Go error to python-compatible C.CString
func errorGoToPy(e error) *C.char {
	if e != nil {
		return C.CString(e.Error())
	}
	return C.CString("")
}

// --- generated code for package: api below: ---

// ---- External Types Outside of Targeted Packages ---

// Converters for pointer handles for type: *environment.Class
func ptrFromHandle_Ptr_environment_Class(h CGoHandle) *environment.Class {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*environment.Class")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(environment.Class{})).(*environment.Class)
}
func handleFromPtr_Ptr_environment_Class(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*environment.Class", p))
}

// Converters for pointer handles for type: *environment.Environment
func ptrFromHandle_Ptr_environment_Environment(h CGoHandle) *environment.Environment {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*environment.Environment")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(environment.Environment{})).(*environment.Environment)
}
func handleFromPtr_Ptr_environment_Environment(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*environment.Environment", p))
}

// Converters for pointer handles for type: *environment.Function
func ptrFromHandle_Ptr_environment_Function(h CGoHandle) *environment.Function {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*environment.Function")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(environment.Function{})).(*environment.Function)
}
func handleFromPtr_Ptr_environment_Function(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*environment.Function", p))
}

// Converters for pointer handles for type: *environment.MemberVariable
func ptrFromHandle_Ptr_environment_MemberVariable(h CGoHandle) *environment.MemberVariable {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*environment.MemberVariable")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(environment.MemberVariable{})).(*environment.MemberVariable)
}
func handleFromPtr_Ptr_environment_MemberVariable(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*environment.MemberVariable", p))
}

// Converters for pointer handles for type: *environment.ObjectInstance
func ptrFromHandle_Ptr_environment_ObjectInstance(h CGoHandle) *environment.ObjectInstance {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*environment.ObjectInstance")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(environment.ObjectInstance{})).(*environment.ObjectInstance)
}
func handleFromPtr_Ptr_environment_ObjectInstance(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*environment.ObjectInstance", p))
}

// Converters for pointer handles for type: *environment.Variable
func ptrFromHandle_Ptr_environment_Variable(h CGoHandle) *environment.Variable {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*environment.Variable")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(environment.Variable{})).(*environment.Variable)
}
func handleFromPtr_Ptr_environment_Variable(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*environment.Variable", p))
}

// Converters for pointer handles for type: context.Context
func ptrFromHandle_context_Context(h CGoHandle) context.Context {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "context.Context")
	if p == nil {
		return nil
	}
	return p.(context.Context)
}
func handleFromPtr_context_Context(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("context.Context", p))
}

// Converters for non-pointer handles for type: environment.Class
func ptrFromHandle_environment_Class(h CGoHandle) *environment.Class {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "environment.Class")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(environment.Class{})).(*environment.Class)
}
func handleFromPtr_environment_Class(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("environment.Class", p))
}

// Converters for non-pointer handles for type: environment.Environment
func ptrFromHandle_environment_Environment(h CGoHandle) *environment.Environment {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "environment.Environment")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(environment.Environment{})).(*environment.Environment)
}
func handleFromPtr_environment_Environment(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("environment.Environment", p))
}

// Converters for non-pointer handles for type: environment.Function
func ptrFromHandle_environment_Function(h CGoHandle) *environment.Function {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "environment.Function")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(environment.Function{})).(*environment.Function)
}
func handleFromPtr_environment_Function(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("environment.Function", p))
}

// Converters for non-pointer handles for type: environment.MemberVariable
func ptrFromHandle_environment_MemberVariable(h CGoHandle) *environment.MemberVariable {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "environment.MemberVariable")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(environment.MemberVariable{})).(*environment.MemberVariable)
}
func handleFromPtr_environment_MemberVariable(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("environment.MemberVariable", p))
}

// Converters for non-pointer handles for type: environment.ObjectInstance
func ptrFromHandle_environment_ObjectInstance(h CGoHandle) *environment.ObjectInstance {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "environment.ObjectInstance")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(environment.ObjectInstance{})).(*environment.ObjectInstance)
}
func handleFromPtr_environment_ObjectInstance(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("environment.ObjectInstance", p))
}

// Converters for non-pointer handles for type: environment.Parameter
func ptrFromHandle_environment_Parameter(h CGoHandle) *environment.Parameter {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "environment.Parameter")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(environment.Parameter{})).(*environment.Parameter)
}
func handleFromPtr_environment_Parameter(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("environment.Parameter", p))
}

// Converters for pointer handles for type: environment.Value
func ptrFromHandle_environment_Value(h CGoHandle) environment.Value {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "environment.Value")
	if p == nil {
		return nil
	}
	return p.(environment.Value)
}
func handleFromPtr_environment_Value(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("environment.Value", p))
}

// Converters for non-pointer handles for type: environment.Variable
func ptrFromHandle_environment_Variable(h CGoHandle) *environment.Variable {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "environment.Variable")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(environment.Variable{})).(*environment.Variable)
}
func handleFromPtr_environment_Variable(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("environment.Variable", p))
}

// Converters for pointer handles for type: io.Reader
func ptrFromHandle_io_Reader(h CGoHandle) io.Reader {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "io.Reader")
	if p == nil {
		return nil
	}
	return p.(io.Reader)
}
func handleFromPtr_io_Reader(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("io.Reader", p))
}

// Converters for pointer handles for type: io.Writer
func ptrFromHandle_io_Writer(h CGoHandle) io.Writer {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "io.Writer")
	if p == nil {
		return nil
	}
	return p.(io.Writer)
}
func handleFromPtr_io_Writer(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("io.Writer", p))
}

// ---- Package: go ---

// ---- Types ---

// Converters for implicit pointer handles for type: []bool
func ptrFromHandle_Slice_bool(h CGoHandle) *[]bool {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]bool")
	if p == nil {
		return nil
	}
	return p.(*[]bool)
}
func deptrFromHandle_Slice_bool(h CGoHandle) []bool {
	p := ptrFromHandle_Slice_bool(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_bool(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]bool", p))
}

// --- wrapping slice: []bool ---
//
//export Slice_bool_CTor
func Slice_bool_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_bool(&[]bool{}))
}

//export Slice_bool_len
func Slice_bool_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_bool(handle))
}

//export Slice_bool_elem
func Slice_bool_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_bool(handle)
	return boolGoToPy(s[_idx])
}

//export Slice_bool_subslice
func Slice_bool_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_bool(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_bool(&ss))
}

//export Slice_bool_set
func Slice_bool_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_bool(handle)
	s[_idx] = boolPyToGo(_vl)
}

//export Slice_bool_append
func Slice_bool_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_bool(handle)
	*s = append(*s, boolPyToGo(_vl))
}

// Converters for implicit pointer handles for type: []byte
func ptrFromHandle_Slice_byte(h CGoHandle) *[]byte {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]byte")
	if p == nil {
		return nil
	}
	return p.(*[]byte)
}
func deptrFromHandle_Slice_byte(h CGoHandle) []byte {
	p := ptrFromHandle_Slice_byte(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_byte(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]byte", p))
}

// --- wrapping slice: []byte ---
//
//export Slice_byte_CTor
func Slice_byte_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_byte(&[]byte{}))
}

//export Slice_byte_len
func Slice_byte_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_byte(handle))
}

//export Slice_byte_elem
func Slice_byte_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_byte(handle)
	return C.char(s[_idx])
}

//export Slice_byte_subslice
func Slice_byte_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_byte(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_byte(&ss))
}

//export Slice_byte_set
func Slice_byte_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_byte(handle)
	s[_idx] = byte(_vl)
}

//export Slice_byte_append
func Slice_byte_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_byte(handle)
	*s = append(*s, byte(_vl))
}

//export Slice_byte_from_bytes
func Slice_byte_from_bytes(o *C.PyObject) CGoHandle {
	size := C.PyBytes_Size(o)
	ptr := unsafe.Pointer(C.PyBytes_AsString(o))
	data := make([]byte, size)
	tmp := unsafe.Slice((*byte)(ptr), size)
	copy(data, tmp)
	return handleFromPtr_Slice_byte(&data)
}

//export Slice_byte_to_bytes
func Slice_byte_to_bytes(handle CGoHandle) *C.PyObject {
	s := deptrFromHandle_Slice_byte(handle)
	ptr := unsafe.Pointer(&s[0])
	size := len(s)
	return C.PyBytes_FromStringAndSize((*C.char)(ptr), C.long(size))
}

// Converters for implicit pointer handles for type: []error
func ptrFromHandle_Slice_error(h CGoHandle) *[]error {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]error")
	if p == nil {
		return nil
	}
	return p.(*[]error)
}
func deptrFromHandle_Slice_error(h CGoHandle) []error {
	p := ptrFromHandle_Slice_error(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_error(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]error", p))
}

// --- wrapping slice: []error ---
//
//export Slice_error_CTor
func Slice_error_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_error(&[]error{}))
}

//export Slice_error_len
func Slice_error_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_error(handle))
}

//export Slice_error_elem
func Slice_error_elem(handle CGoHandle, _idx int) *C.char {
	s := deptrFromHandle_Slice_error(handle)
	return errorGoToPy(s[_idx])
}

//export Slice_error_subslice
func Slice_error_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_error(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_error(&ss))
}

//export Slice_error_set
func Slice_error_set(handle CGoHandle, _idx int, _vl *C.char) {
	s := deptrFromHandle_Slice_error(handle)
	s[_idx] = errors.New(C.GoString(_vl))
}

//export Slice_error_append
func Slice_error_append(handle CGoHandle, _vl *C.char) {
	s := ptrFromHandle_Slice_error(handle)
	*s = append(*s, errors.New(C.GoString(_vl)))
}

// Converters for implicit pointer handles for type: []float32
func ptrFromHandle_Slice_float32(h CGoHandle) *[]float32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]float32")
	if p == nil {
		return nil
	}
	return p.(*[]float32)
}
func deptrFromHandle_Slice_float32(h CGoHandle) []float32 {
	p := ptrFromHandle_Slice_float32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_float32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]float32", p))
}

// --- wrapping slice: []float32 ---
//
//export Slice_float32_CTor
func Slice_float32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_float32(&[]float32{}))
}

//export Slice_float32_len
func Slice_float32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_float32(handle))
}

//export Slice_float32_elem
func Slice_float32_elem(handle CGoHandle, _idx int) C.float {
	s := deptrFromHandle_Slice_float32(handle)
	return C.float(s[_idx])
}

//export Slice_float32_subslice
func Slice_float32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_float32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_float32(&ss))
}

//export Slice_float32_set
func Slice_float32_set(handle CGoHandle, _idx int, _vl C.float) {
	s := deptrFromHandle_Slice_float32(handle)
	s[_idx] = float32(_vl)
}

//export Slice_float32_append
func Slice_float32_append(handle CGoHandle, _vl C.float) {
	s := ptrFromHandle_Slice_float32(handle)
	*s = append(*s, float32(_vl))
}

// Converters for implicit pointer handles for type: []float64
func ptrFromHandle_Slice_float64(h CGoHandle) *[]float64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]float64")
	if p == nil {
		return nil
	}
	return p.(*[]float64)
}
func deptrFromHandle_Slice_float64(h CGoHandle) []float64 {
	p := ptrFromHandle_Slice_float64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_float64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]float64", p))
}

// --- wrapping slice: []float64 ---
//
//export Slice_float64_CTor
func Slice_float64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_float64(&[]float64{}))
}

//export Slice_float64_len
func Slice_float64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_float64(handle))
}

//export Slice_float64_elem
func Slice_float64_elem(handle CGoHandle, _idx int) C.double {
	s := deptrFromHandle_Slice_float64(handle)
	return C.double(s[_idx])
}

//export Slice_float64_subslice
func Slice_float64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_float64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_float64(&ss))
}

//export Slice_float64_set
func Slice_float64_set(handle CGoHandle, _idx int, _vl C.double) {
	s := deptrFromHandle_Slice_float64(handle)
	s[_idx] = float64(_vl)
}

//export Slice_float64_append
func Slice_float64_append(handle CGoHandle, _vl C.double) {
	s := ptrFromHandle_Slice_float64(handle)
	*s = append(*s, float64(_vl))
}

// Converters for implicit pointer handles for type: []int
func ptrFromHandle_Slice_int(h CGoHandle) *[]int {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int")
	if p == nil {
		return nil
	}
	return p.(*[]int)
}
func deptrFromHandle_Slice_int(h CGoHandle) []int {
	p := ptrFromHandle_Slice_int(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int", p))
}

// --- wrapping slice: []int ---
//
//export Slice_int_CTor
func Slice_int_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int(&[]int{}))
}

//export Slice_int_len
func Slice_int_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int(handle))
}

//export Slice_int_elem
func Slice_int_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_Slice_int(handle)
	return C.longlong(s[_idx])
}

//export Slice_int_subslice
func Slice_int_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int(&ss))
}

//export Slice_int_set
func Slice_int_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_Slice_int(handle)
	s[_idx] = int(_vl)
}

//export Slice_int_append
func Slice_int_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_Slice_int(handle)
	*s = append(*s, int(_vl))
}

// Converters for implicit pointer handles for type: []int16
func ptrFromHandle_Slice_int16(h CGoHandle) *[]int16 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int16")
	if p == nil {
		return nil
	}
	return p.(*[]int16)
}
func deptrFromHandle_Slice_int16(h CGoHandle) []int16 {
	p := ptrFromHandle_Slice_int16(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int16(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int16", p))
}

// --- wrapping slice: []int16 ---
//
//export Slice_int16_CTor
func Slice_int16_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int16(&[]int16{}))
}

//export Slice_int16_len
func Slice_int16_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int16(handle))
}

//export Slice_int16_elem
func Slice_int16_elem(handle CGoHandle, _idx int) C.short {
	s := deptrFromHandle_Slice_int16(handle)
	return C.short(s[_idx])
}

//export Slice_int16_subslice
func Slice_int16_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int16(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int16(&ss))
}

//export Slice_int16_set
func Slice_int16_set(handle CGoHandle, _idx int, _vl C.short) {
	s := deptrFromHandle_Slice_int16(handle)
	s[_idx] = int16(_vl)
}

//export Slice_int16_append
func Slice_int16_append(handle CGoHandle, _vl C.short) {
	s := ptrFromHandle_Slice_int16(handle)
	*s = append(*s, int16(_vl))
}

// Converters for implicit pointer handles for type: []int32
func ptrFromHandle_Slice_int32(h CGoHandle) *[]int32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int32")
	if p == nil {
		return nil
	}
	return p.(*[]int32)
}
func deptrFromHandle_Slice_int32(h CGoHandle) []int32 {
	p := ptrFromHandle_Slice_int32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int32", p))
}

// --- wrapping slice: []int32 ---
//
//export Slice_int32_CTor
func Slice_int32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int32(&[]int32{}))
}

//export Slice_int32_len
func Slice_int32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int32(handle))
}

//export Slice_int32_elem
func Slice_int32_elem(handle CGoHandle, _idx int) C.long {
	s := deptrFromHandle_Slice_int32(handle)
	return C.long(s[_idx])
}

//export Slice_int32_subslice
func Slice_int32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int32(&ss))
}

//export Slice_int32_set
func Slice_int32_set(handle CGoHandle, _idx int, _vl C.long) {
	s := deptrFromHandle_Slice_int32(handle)
	s[_idx] = int32(_vl)
}

//export Slice_int32_append
func Slice_int32_append(handle CGoHandle, _vl C.long) {
	s := ptrFromHandle_Slice_int32(handle)
	*s = append(*s, int32(_vl))
}

// Converters for implicit pointer handles for type: []int64
func ptrFromHandle_Slice_int64(h CGoHandle) *[]int64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int64")
	if p == nil {
		return nil
	}
	return p.(*[]int64)
}
func deptrFromHandle_Slice_int64(h CGoHandle) []int64 {
	p := ptrFromHandle_Slice_int64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int64", p))
}

// --- wrapping slice: []int64 ---
//
//export Slice_int64_CTor
func Slice_int64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int64(&[]int64{}))
}

//export Slice_int64_len
func Slice_int64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int64(handle))
}

//export Slice_int64_elem
func Slice_int64_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_Slice_int64(handle)
	return C.longlong(s[_idx])
}

//export Slice_int64_subslice
func Slice_int64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int64(&ss))
}

//export Slice_int64_set
func Slice_int64_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_Slice_int64(handle)
	s[_idx] = int64(_vl)
}

//export Slice_int64_append
func Slice_int64_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_Slice_int64(handle)
	*s = append(*s, int64(_vl))
}

// Converters for implicit pointer handles for type: []int8
func ptrFromHandle_Slice_int8(h CGoHandle) *[]int8 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int8")
	if p == nil {
		return nil
	}
	return p.(*[]int8)
}
func deptrFromHandle_Slice_int8(h CGoHandle) []int8 {
	p := ptrFromHandle_Slice_int8(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int8(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int8", p))
}

// --- wrapping slice: []int8 ---
//
//export Slice_int8_CTor
func Slice_int8_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int8(&[]int8{}))
}

//export Slice_int8_len
func Slice_int8_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int8(handle))
}

//export Slice_int8_elem
func Slice_int8_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_int8(handle)
	return C.char(s[_idx])
}

//export Slice_int8_subslice
func Slice_int8_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int8(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int8(&ss))
}

//export Slice_int8_set
func Slice_int8_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_int8(handle)
	s[_idx] = int8(_vl)
}

//export Slice_int8_append
func Slice_int8_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_int8(handle)
	*s = append(*s, int8(_vl))
}

// Converters for implicit pointer handles for type: []rune
func ptrFromHandle_Slice_rune(h CGoHandle) *[]rune {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]rune")
	if p == nil {
		return nil
	}
	return p.(*[]rune)
}
func deptrFromHandle_Slice_rune(h CGoHandle) []rune {
	p := ptrFromHandle_Slice_rune(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_rune(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]rune", p))
}

// --- wrapping slice: []rune ---
//
//export Slice_rune_CTor
func Slice_rune_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_rune(&[]rune{}))
}

//export Slice_rune_len
func Slice_rune_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_rune(handle))
}

//export Slice_rune_elem
func Slice_rune_elem(handle CGoHandle, _idx int) C.long {
	s := deptrFromHandle_Slice_rune(handle)
	return C.long(s[_idx])
}

//export Slice_rune_subslice
func Slice_rune_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_rune(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_rune(&ss))
}

//export Slice_rune_set
func Slice_rune_set(handle CGoHandle, _idx int, _vl C.long) {
	s := deptrFromHandle_Slice_rune(handle)
	s[_idx] = rune(_vl)
}

//export Slice_rune_append
func Slice_rune_append(handle CGoHandle, _vl C.long) {
	s := ptrFromHandle_Slice_rune(handle)
	*s = append(*s, rune(_vl))
}

// Converters for implicit pointer handles for type: []string
func ptrFromHandle_Slice_string(h CGoHandle) *[]string {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]string")
	if p == nil {
		return nil
	}
	return p.(*[]string)
}
func deptrFromHandle_Slice_string(h CGoHandle) []string {
	p := ptrFromHandle_Slice_string(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_string(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]string", p))
}

// --- wrapping slice: []string ---
//
//export Slice_string_CTor
func Slice_string_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_string(&[]string{}))
}

//export Slice_string_len
func Slice_string_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_string(handle))
}

//export Slice_string_elem
func Slice_string_elem(handle CGoHandle, _idx int) *C.char {
	s := deptrFromHandle_Slice_string(handle)
	return C.CString(s[_idx])
}

//export Slice_string_subslice
func Slice_string_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_string(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_string(&ss))
}

//export Slice_string_set
func Slice_string_set(handle CGoHandle, _idx int, _vl *C.char) {
	s := deptrFromHandle_Slice_string(handle)
	s[_idx] = C.GoString(_vl)
}

//export Slice_string_append
func Slice_string_append(handle CGoHandle, _vl *C.char) {
	s := ptrFromHandle_Slice_string(handle)
	*s = append(*s, C.GoString(_vl))
}

// Converters for implicit pointer handles for type: []uint
func ptrFromHandle_Slice_uint(h CGoHandle) *[]uint {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint")
	if p == nil {
		return nil
	}
	return p.(*[]uint)
}
func deptrFromHandle_Slice_uint(h CGoHandle) []uint {
	p := ptrFromHandle_Slice_uint(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint", p))
}

// --- wrapping slice: []uint ---
//
//export Slice_uint_CTor
func Slice_uint_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint(&[]uint{}))
}

//export Slice_uint_len
func Slice_uint_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint(handle))
}

//export Slice_uint_elem
func Slice_uint_elem(handle CGoHandle, _idx int) C.ulonglong {
	s := deptrFromHandle_Slice_uint(handle)
	return C.ulonglong(s[_idx])
}

//export Slice_uint_subslice
func Slice_uint_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint(&ss))
}

//export Slice_uint_set
func Slice_uint_set(handle CGoHandle, _idx int, _vl C.ulonglong) {
	s := deptrFromHandle_Slice_uint(handle)
	s[_idx] = uint(_vl)
}

//export Slice_uint_append
func Slice_uint_append(handle CGoHandle, _vl C.ulonglong) {
	s := ptrFromHandle_Slice_uint(handle)
	*s = append(*s, uint(_vl))
}

// Converters for implicit pointer handles for type: []uint16
func ptrFromHandle_Slice_uint16(h CGoHandle) *[]uint16 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint16")
	if p == nil {
		return nil
	}
	return p.(*[]uint16)
}
func deptrFromHandle_Slice_uint16(h CGoHandle) []uint16 {
	p := ptrFromHandle_Slice_uint16(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint16(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint16", p))
}

// --- wrapping slice: []uint16 ---
//
//export Slice_uint16_CTor
func Slice_uint16_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint16(&[]uint16{}))
}

//export Slice_uint16_len
func Slice_uint16_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint16(handle))
}

//export Slice_uint16_elem
func Slice_uint16_elem(handle CGoHandle, _idx int) C.ushort {
	s := deptrFromHandle_Slice_uint16(handle)
	return C.ushort(s[_idx])
}

//export Slice_uint16_subslice
func Slice_uint16_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint16(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint16(&ss))
}

//export Slice_uint16_set
func Slice_uint16_set(handle CGoHandle, _idx int, _vl C.ushort) {
	s := deptrFromHandle_Slice_uint16(handle)
	s[_idx] = uint16(_vl)
}

//export Slice_uint16_append
func Slice_uint16_append(handle CGoHandle, _vl C.ushort) {
	s := ptrFromHandle_Slice_uint16(handle)
	*s = append(*s, uint16(_vl))
}

// Converters for implicit pointer handles for type: []uint32
func ptrFromHandle_Slice_uint32(h CGoHandle) *[]uint32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint32")
	if p == nil {
		return nil
	}
	return p.(*[]uint32)
}
func deptrFromHandle_Slice_uint32(h CGoHandle) []uint32 {
	p := ptrFromHandle_Slice_uint32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint32", p))
}

// --- wrapping slice: []uint32 ---
//
//export Slice_uint32_CTor
func Slice_uint32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint32(&[]uint32{}))
}

//export Slice_uint32_len
func Slice_uint32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint32(handle))
}

//export Slice_uint32_elem
func Slice_uint32_elem(handle CGoHandle, _idx int) C.ulong {
	s := deptrFromHandle_Slice_uint32(handle)
	return C.ulong(s[_idx])
}

//export Slice_uint32_subslice
func Slice_uint32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint32(&ss))
}

//export Slice_uint32_set
func Slice_uint32_set(handle CGoHandle, _idx int, _vl C.ulong) {
	s := deptrFromHandle_Slice_uint32(handle)
	s[_idx] = uint32(_vl)
}

//export Slice_uint32_append
func Slice_uint32_append(handle CGoHandle, _vl C.ulong) {
	s := ptrFromHandle_Slice_uint32(handle)
	*s = append(*s, uint32(_vl))
}

// Converters for implicit pointer handles for type: []uint64
func ptrFromHandle_Slice_uint64(h CGoHandle) *[]uint64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint64")
	if p == nil {
		return nil
	}
	return p.(*[]uint64)
}
func deptrFromHandle_Slice_uint64(h CGoHandle) []uint64 {
	p := ptrFromHandle_Slice_uint64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint64", p))
}

// --- wrapping slice: []uint64 ---
//
//export Slice_uint64_CTor
func Slice_uint64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint64(&[]uint64{}))
}

//export Slice_uint64_len
func Slice_uint64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint64(handle))
}

//export Slice_uint64_elem
func Slice_uint64_elem(handle CGoHandle, _idx int) C.ulonglong {
	s := deptrFromHandle_Slice_uint64(handle)
	return C.ulonglong(s[_idx])
}

//export Slice_uint64_subslice
func Slice_uint64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint64(&ss))
}

//export Slice_uint64_set
func Slice_uint64_set(handle CGoHandle, _idx int, _vl C.ulonglong) {
	s := deptrFromHandle_Slice_uint64(handle)
	s[_idx] = uint64(_vl)
}

//export Slice_uint64_append
func Slice_uint64_append(handle CGoHandle, _vl C.ulonglong) {
	s := ptrFromHandle_Slice_uint64(handle)
	*s = append(*s, uint64(_vl))
}

// Converters for implicit pointer handles for type: []uint8
func ptrFromHandle_Slice_uint8(h CGoHandle) *[]uint8 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint8")
	if p == nil {
		return nil
	}
	return p.(*[]uint8)
}
func deptrFromHandle_Slice_uint8(h CGoHandle) []uint8 {
	p := ptrFromHandle_Slice_uint8(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint8(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint8", p))
}

// --- wrapping slice: []uint8 ---
//
//export Slice_uint8_CTor
func Slice_uint8_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint8(&[]uint8{}))
}

//export Slice_uint8_len
func Slice_uint8_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint8(handle))
}

//export Slice_uint8_elem
func Slice_uint8_elem(handle CGoHandle, _idx int) C.uchar {
	s := deptrFromHandle_Slice_uint8(handle)
	return C.uchar(s[_idx])
}

//export Slice_uint8_subslice
func Slice_uint8_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint8(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint8(&ss))
}

//export Slice_uint8_set
func Slice_uint8_set(handle CGoHandle, _idx int, _vl C.uchar) {
	s := deptrFromHandle_Slice_uint8(handle)
	s[_idx] = uint8(_vl)
}

//export Slice_uint8_append
func Slice_uint8_append(handle CGoHandle, _vl C.uchar) {
	s := ptrFromHandle_Slice_uint8(handle)
	*s = append(*s, uint8(_vl))
}

// ---- Package: api ---

// ---- Types ---

// Converters for pointer handles for type: *api.ClassDefinition
func ptrFromHandle_Ptr_api_ClassDefinition(h CGoHandle) *api.ClassDefinition {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*api.ClassDefinition")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(api.ClassDefinition{})).(*api.ClassDefinition)
}
func handleFromPtr_Ptr_api_ClassDefinition(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*api.ClassDefinition", p))
}

// Converters for pointer handles for type: *api.ClassMethod
func ptrFromHandle_Ptr_api_ClassMethod(h CGoHandle) *api.ClassMethod {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*api.ClassMethod")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(api.ClassMethod{})).(*api.ClassMethod)
}
func handleFromPtr_Ptr_api_ClassMethod(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*api.ClassMethod", p))
}

// Converters for pointer handles for type: *api.ClassVariable
func ptrFromHandle_Ptr_api_ClassVariable(h CGoHandle) *api.ClassVariable {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*api.ClassVariable")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(api.ClassVariable{})).(*api.ClassVariable)
}
func handleFromPtr_Ptr_api_ClassVariable(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*api.ClassVariable", p))
}

// Converters for pointer handles for type: *api.ExecutionResult
func ptrFromHandle_Ptr_api_ExecutionResult(h CGoHandle) *api.ExecutionResult {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*api.ExecutionResult")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(api.ExecutionResult{})).(*api.ExecutionResult)
}
func handleFromPtr_Ptr_api_ExecutionResult(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*api.ExecutionResult", p))
}

// Converters for pointer handles for type: *api.GoValue
func ptrFromHandle_Ptr_api_GoValue(h CGoHandle) *api.GoValue {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*api.GoValue")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(api.GoValue{})).(*api.GoValue)
}
func handleFromPtr_Ptr_api_GoValue(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*api.GoValue", p))
}

// Converters for pointer handles for type: *api.SourceLocation
func ptrFromHandle_Ptr_api_SourceLocation(h CGoHandle) *api.SourceLocation {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*api.SourceLocation")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(api.SourceLocation{})).(*api.SourceLocation)
}
func handleFromPtr_Ptr_api_SourceLocation(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*api.SourceLocation", p))
}

// Converters for pointer handles for type: *api.UnknownFunctionHandler
func ptrFromHandle_Ptr_api_UnknownFunctionHandler(h CGoHandle) *api.UnknownFunctionHandler {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*api.UnknownFunctionHandler")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(api.UnknownFunctionHandler{})).(*api.UnknownFunctionHandler)
}
func handleFromPtr_Ptr_api_UnknownFunctionHandler(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*api.UnknownFunctionHandler", p))
}

// Converters for pointer handles for type: *api.VM
func ptrFromHandle_Ptr_api_VM(h CGoHandle) *api.VM {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*api.VM")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(api.VM{})).(*api.VM)
}
func handleFromPtr_Ptr_api_VM(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*api.VM", p))
}

// Converters for pointer handles for type: *api.VMCompatibilityShim
func ptrFromHandle_Ptr_api_VMCompatibilityShim(h CGoHandle) *api.VMCompatibilityShim {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*api.VMCompatibilityShim")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(api.VMCompatibilityShim{})).(*api.VMCompatibilityShim)
}
func handleFromPtr_Ptr_api_VMCompatibilityShim(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*api.VMCompatibilityShim", p))
}

// Converters for pointer handles for type: *api.VMConfig
func ptrFromHandle_Ptr_api_VMConfig(h CGoHandle) *api.VMConfig {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*api.VMConfig")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(api.VMConfig{})).(*api.VMConfig)
}
func handleFromPtr_Ptr_api_VMConfig(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*api.VMConfig", p))
}

// Converters for pointer handles for type: *api.VMError
func ptrFromHandle_Ptr_api_VMError(h CGoHandle) *api.VMError {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*api.VMError")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(api.VMError{})).(*api.VMError)
}
func handleFromPtr_Ptr_api_VMError(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*api.VMError", p))
}

// Converters for implicit pointer handles for type: []api.GoValue
func ptrFromHandle_Slice_api_GoValue(h CGoHandle) *[]api.GoValue {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]api.GoValue")
	if p == nil {
		return nil
	}
	return p.(*[]api.GoValue)
}
func deptrFromHandle_Slice_api_GoValue(h CGoHandle) []api.GoValue {
	p := ptrFromHandle_Slice_api_GoValue(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_api_GoValue(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]api.GoValue", p))
}

// --- wrapping slice: []api.GoValue ---
//
//export Slice_api_GoValue_CTor
func Slice_api_GoValue_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_api_GoValue(&[]api.GoValue{}))
}

//export Slice_api_GoValue_len
func Slice_api_GoValue_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_api_GoValue(handle))
}

//export Slice_api_GoValue_elem
func Slice_api_GoValue_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_api_GoValue(handle)
	return handleFromPtr_api_GoValue(&(s[_idx]))
}

//export Slice_api_GoValue_subslice
func Slice_api_GoValue_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_api_GoValue(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_api_GoValue(&ss))
}

//export Slice_api_GoValue_set
func Slice_api_GoValue_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_api_GoValue(handle)
	s[_idx] = *ptrFromHandle_api_GoValue(_vl)
}

//export Slice_api_GoValue_append
func Slice_api_GoValue_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_api_GoValue(handle)
	*s = append(*s, *ptrFromHandle_api_GoValue(_vl))
}

// Converters for implicit pointer handles for type: []environment.Parameter
func ptrFromHandle_Slice_environment_Parameter(h CGoHandle) *[]environment.Parameter {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]environment.Parameter")
	if p == nil {
		return nil
	}
	return p.(*[]environment.Parameter)
}
func deptrFromHandle_Slice_environment_Parameter(h CGoHandle) []environment.Parameter {
	p := ptrFromHandle_Slice_environment_Parameter(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_environment_Parameter(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]environment.Parameter", p))
}

// --- wrapping slice: []environment.Parameter ---
//
//export Slice_environment_Parameter_CTor
func Slice_environment_Parameter_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_environment_Parameter(&[]environment.Parameter{}))
}

//export Slice_environment_Parameter_len
func Slice_environment_Parameter_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_environment_Parameter(handle))
}

//export Slice_environment_Parameter_elem
func Slice_environment_Parameter_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_environment_Parameter(handle)
	return handleFromPtr_environment_Parameter(&(s[_idx]))
}

//export Slice_environment_Parameter_subslice
func Slice_environment_Parameter_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_environment_Parameter(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_environment_Parameter(&ss))
}

//export Slice_environment_Parameter_set
func Slice_environment_Parameter_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_environment_Parameter(handle)
	s[_idx] = *ptrFromHandle_environment_Parameter(_vl)
}

//export Slice_environment_Parameter_append
func Slice_environment_Parameter_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_environment_Parameter(handle)
	*s = append(*s, *ptrFromHandle_environment_Parameter(_vl))
}

// Converters for implicit pointer handles for type: []environment.Value
func ptrFromHandle_Slice_environment_Value(h CGoHandle) *[]environment.Value {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]environment.Value")
	if p == nil {
		return nil
	}
	return p.(*[]environment.Value)
}
func deptrFromHandle_Slice_environment_Value(h CGoHandle) []environment.Value {
	p := ptrFromHandle_Slice_environment_Value(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_environment_Value(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]environment.Value", p))
}

// --- wrapping slice: []environment.Value ---
//
//export Slice_environment_Value_CTor
func Slice_environment_Value_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_environment_Value(&[]environment.Value{}))
}

//export Slice_environment_Value_len
func Slice_environment_Value_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_environment_Value(handle))
}

//export Slice_environment_Value_elem
func Slice_environment_Value_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_environment_Value(handle)
	return handleFromPtr_environment_Value(&(s[_idx]))
}

//export Slice_environment_Value_subslice
func Slice_environment_Value_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_environment_Value(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_environment_Value(&ss))
}

//export Slice_environment_Value_set
func Slice_environment_Value_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_environment_Value(handle)
	s[_idx] = ptrFromHandle_environment_Value(_vl)
}

//export Slice_environment_Value_append
func Slice_environment_Value_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_environment_Value(handle)
	*s = append(*s, ptrFromHandle_environment_Value(_vl))
}

// Converters for pointer handles for type: any
func ptrFromHandle_any(h CGoHandle) any {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "any")
	if p == nil {
		return nil
	}
	return p.(any)
}
func handleFromPtr_any(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("any", p))
}

// Converters for non-pointer handles for type: api.ClassDefinition
func ptrFromHandle_api_ClassDefinition(h CGoHandle) *api.ClassDefinition {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "api.ClassDefinition")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(api.ClassDefinition{})).(*api.ClassDefinition)
}
func handleFromPtr_api_ClassDefinition(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("api.ClassDefinition", p))
}

// Converters for non-pointer handles for type: api.ClassMethod
func ptrFromHandle_api_ClassMethod(h CGoHandle) *api.ClassMethod {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "api.ClassMethod")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(api.ClassMethod{})).(*api.ClassMethod)
}
func handleFromPtr_api_ClassMethod(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("api.ClassMethod", p))
}

// Converters for non-pointer handles for type: api.ClassVariable
func ptrFromHandle_api_ClassVariable(h CGoHandle) *api.ClassVariable {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "api.ClassVariable")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(api.ClassVariable{})).(*api.ClassVariable)
}
func handleFromPtr_api_ClassVariable(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("api.ClassVariable", p))
}

// Converters for non-pointer handles for type: api.ExecutionResult
func ptrFromHandle_api_ExecutionResult(h CGoHandle) *api.ExecutionResult {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "api.ExecutionResult")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(api.ExecutionResult{})).(*api.ExecutionResult)
}
func handleFromPtr_api_ExecutionResult(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("api.ExecutionResult", p))
}

// Converters for non-pointer handles for type: api.GoValue
func ptrFromHandle_api_GoValue(h CGoHandle) *api.GoValue {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "api.GoValue")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(api.GoValue{})).(*api.GoValue)
}
func handleFromPtr_api_GoValue(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("api.GoValue", p))
}

// Converters for non-pointer handles for type: api.SourceLocation
func ptrFromHandle_api_SourceLocation(h CGoHandle) *api.SourceLocation {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "api.SourceLocation")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(api.SourceLocation{})).(*api.SourceLocation)
}
func handleFromPtr_api_SourceLocation(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("api.SourceLocation", p))
}

// Converters for non-pointer handles for type: api.UnknownFunctionHandler
func ptrFromHandle_api_UnknownFunctionHandler(h CGoHandle) *api.UnknownFunctionHandler {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "api.UnknownFunctionHandler")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(api.UnknownFunctionHandler{})).(*api.UnknownFunctionHandler)
}
func handleFromPtr_api_UnknownFunctionHandler(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("api.UnknownFunctionHandler", p))
}

// Converters for non-pointer handles for type: api.VM
func ptrFromHandle_api_VM(h CGoHandle) *api.VM {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "api.VM")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(api.VM{})).(*api.VM)
}
func handleFromPtr_api_VM(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("api.VM", p))
}

// Converters for non-pointer handles for type: api.VMCompatibilityShim
func ptrFromHandle_api_VMCompatibilityShim(h CGoHandle) *api.VMCompatibilityShim {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "api.VMCompatibilityShim")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(api.VMCompatibilityShim{})).(*api.VMCompatibilityShim)
}
func handleFromPtr_api_VMCompatibilityShim(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("api.VMCompatibilityShim", p))
}

// Converters for non-pointer handles for type: api.VMConfig
func ptrFromHandle_api_VMConfig(h CGoHandle) *api.VMConfig {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "api.VMConfig")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(api.VMConfig{})).(*api.VMConfig)
}
func handleFromPtr_api_VMConfig(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("api.VMConfig", p))
}

// Converters for non-pointer handles for type: api.VMError
func ptrFromHandle_api_VMError(h CGoHandle) *api.VMError {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "api.VMError")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(api.VMError{})).(*api.VMError)
}
func handleFromPtr_api_VMError(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("api.VMError", p))
}

// Converters for implicit pointer handles for type: map[string]*api.ClassMethod
func ptrFromHandle_Map_string_Ptr_api_ClassMethod(h CGoHandle) *map[string]*api.ClassMethod {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[string]*api.ClassMethod")
	if p == nil {
		return nil
	}
	return p.(*map[string]*api.ClassMethod)
}
func deptrFromHandle_Map_string_Ptr_api_ClassMethod(h CGoHandle) map[string]*api.ClassMethod {
	p := ptrFromHandle_Map_string_Ptr_api_ClassMethod(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_string_Ptr_api_ClassMethod(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[string]*api.ClassMethod", p))
}

// --- wrapping map: map[string]*api.ClassMethod ---
//
//export Map_string_Ptr_api_ClassMethod_CTor
func Map_string_Ptr_api_ClassMethod_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_string_Ptr_api_ClassMethod(&map[string]*api.ClassMethod{}))
}

//export Map_string_Ptr_api_ClassMethod_len
func Map_string_Ptr_api_ClassMethod_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_string_Ptr_api_ClassMethod(handle))
}

//export Map_string_Ptr_api_ClassMethod_elem
func Map_string_Ptr_api_ClassMethod_elem(handle CGoHandle, _ky *C.char) CGoHandle {
	s := deptrFromHandle_Map_string_Ptr_api_ClassMethod(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_Ptr_api_ClassMethod(&v)
}

//export Map_string_Ptr_api_ClassMethod_contains
func Map_string_Ptr_api_ClassMethod_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_Ptr_api_ClassMethod(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export Map_string_Ptr_api_ClassMethod_set
func Map_string_Ptr_api_ClassMethod_set(handle CGoHandle, _ky *C.char, _vl CGoHandle) {
	s := deptrFromHandle_Map_string_Ptr_api_ClassMethod(handle)
	s[C.GoString(_ky)] = ptrFromHandle_Ptr_api_ClassMethod(_vl)
}

//export Map_string_Ptr_api_ClassMethod_delete
func Map_string_Ptr_api_ClassMethod_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_Map_string_Ptr_api_ClassMethod(handle)
	delete(s, C.GoString(_ky))
}

//export Map_string_Ptr_api_ClassMethod_keys
func Map_string_Ptr_api_ClassMethod_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_string_Ptr_api_ClassMethod(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// Converters for implicit pointer handles for type: map[string]*api.ClassVariable
func ptrFromHandle_Map_string_Ptr_api_ClassVariable(h CGoHandle) *map[string]*api.ClassVariable {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[string]*api.ClassVariable")
	if p == nil {
		return nil
	}
	return p.(*map[string]*api.ClassVariable)
}
func deptrFromHandle_Map_string_Ptr_api_ClassVariable(h CGoHandle) map[string]*api.ClassVariable {
	p := ptrFromHandle_Map_string_Ptr_api_ClassVariable(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_string_Ptr_api_ClassVariable(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[string]*api.ClassVariable", p))
}

// --- wrapping map: map[string]*api.ClassVariable ---
//
//export Map_string_Ptr_api_ClassVariable_CTor
func Map_string_Ptr_api_ClassVariable_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_string_Ptr_api_ClassVariable(&map[string]*api.ClassVariable{}))
}

//export Map_string_Ptr_api_ClassVariable_len
func Map_string_Ptr_api_ClassVariable_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_string_Ptr_api_ClassVariable(handle))
}

//export Map_string_Ptr_api_ClassVariable_elem
func Map_string_Ptr_api_ClassVariable_elem(handle CGoHandle, _ky *C.char) CGoHandle {
	s := deptrFromHandle_Map_string_Ptr_api_ClassVariable(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_Ptr_api_ClassVariable(&v)
}

//export Map_string_Ptr_api_ClassVariable_contains
func Map_string_Ptr_api_ClassVariable_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_Ptr_api_ClassVariable(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export Map_string_Ptr_api_ClassVariable_set
func Map_string_Ptr_api_ClassVariable_set(handle CGoHandle, _ky *C.char, _vl CGoHandle) {
	s := deptrFromHandle_Map_string_Ptr_api_ClassVariable(handle)
	s[C.GoString(_ky)] = ptrFromHandle_Ptr_api_ClassVariable(_vl)
}

//export Map_string_Ptr_api_ClassVariable_delete
func Map_string_Ptr_api_ClassVariable_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_Map_string_Ptr_api_ClassVariable(handle)
	delete(s, C.GoString(_ky))
}

//export Map_string_Ptr_api_ClassVariable_keys
func Map_string_Ptr_api_ClassVariable_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_string_Ptr_api_ClassVariable(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// Converters for implicit pointer handles for type: map[string]*environment.Class
func ptrFromHandle_Map_string_Ptr_environment_Class(h CGoHandle) *map[string]*environment.Class {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[string]*environment.Class")
	if p == nil {
		return nil
	}
	return p.(*map[string]*environment.Class)
}
func deptrFromHandle_Map_string_Ptr_environment_Class(h CGoHandle) map[string]*environment.Class {
	p := ptrFromHandle_Map_string_Ptr_environment_Class(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_string_Ptr_environment_Class(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[string]*environment.Class", p))
}

// --- wrapping map: map[string]*environment.Class ---
//
//export Map_string_Ptr_environment_Class_CTor
func Map_string_Ptr_environment_Class_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_string_Ptr_environment_Class(&map[string]*environment.Class{}))
}

//export Map_string_Ptr_environment_Class_len
func Map_string_Ptr_environment_Class_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_string_Ptr_environment_Class(handle))
}

//export Map_string_Ptr_environment_Class_elem
func Map_string_Ptr_environment_Class_elem(handle CGoHandle, _ky *C.char) CGoHandle {
	s := deptrFromHandle_Map_string_Ptr_environment_Class(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_Ptr_environment_Class(&v)
}

//export Map_string_Ptr_environment_Class_contains
func Map_string_Ptr_environment_Class_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_Ptr_environment_Class(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export Map_string_Ptr_environment_Class_set
func Map_string_Ptr_environment_Class_set(handle CGoHandle, _ky *C.char, _vl CGoHandle) {
	s := deptrFromHandle_Map_string_Ptr_environment_Class(handle)
	s[C.GoString(_ky)] = ptrFromHandle_Ptr_environment_Class(_vl)
}

//export Map_string_Ptr_environment_Class_delete
func Map_string_Ptr_environment_Class_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_Map_string_Ptr_environment_Class(handle)
	delete(s, C.GoString(_ky))
}

//export Map_string_Ptr_environment_Class_keys
func Map_string_Ptr_environment_Class_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_string_Ptr_environment_Class(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// Converters for implicit pointer handles for type: map[string]*environment.Function
func ptrFromHandle_Map_string_Ptr_environment_Function(h CGoHandle) *map[string]*environment.Function {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[string]*environment.Function")
	if p == nil {
		return nil
	}
	return p.(*map[string]*environment.Function)
}
func deptrFromHandle_Map_string_Ptr_environment_Function(h CGoHandle) map[string]*environment.Function {
	p := ptrFromHandle_Map_string_Ptr_environment_Function(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_string_Ptr_environment_Function(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[string]*environment.Function", p))
}

// --- wrapping map: map[string]*environment.Function ---
//
//export Map_string_Ptr_environment_Function_CTor
func Map_string_Ptr_environment_Function_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_string_Ptr_environment_Function(&map[string]*environment.Function{}))
}

//export Map_string_Ptr_environment_Function_len
func Map_string_Ptr_environment_Function_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_string_Ptr_environment_Function(handle))
}

//export Map_string_Ptr_environment_Function_elem
func Map_string_Ptr_environment_Function_elem(handle CGoHandle, _ky *C.char) CGoHandle {
	s := deptrFromHandle_Map_string_Ptr_environment_Function(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_Ptr_environment_Function(&v)
}

//export Map_string_Ptr_environment_Function_contains
func Map_string_Ptr_environment_Function_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_Ptr_environment_Function(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export Map_string_Ptr_environment_Function_set
func Map_string_Ptr_environment_Function_set(handle CGoHandle, _ky *C.char, _vl CGoHandle) {
	s := deptrFromHandle_Map_string_Ptr_environment_Function(handle)
	s[C.GoString(_ky)] = ptrFromHandle_Ptr_environment_Function(_vl)
}

//export Map_string_Ptr_environment_Function_delete
func Map_string_Ptr_environment_Function_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_Map_string_Ptr_environment_Function(handle)
	delete(s, C.GoString(_ky))
}

//export Map_string_Ptr_environment_Function_keys
func Map_string_Ptr_environment_Function_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_string_Ptr_environment_Function(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// Converters for implicit pointer handles for type: map[string]*environment.MemberVariable
func ptrFromHandle_Map_string_Ptr_environment_MemberVariable(h CGoHandle) *map[string]*environment.MemberVariable {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[string]*environment.MemberVariable")
	if p == nil {
		return nil
	}
	return p.(*map[string]*environment.MemberVariable)
}
func deptrFromHandle_Map_string_Ptr_environment_MemberVariable(h CGoHandle) map[string]*environment.MemberVariable {
	p := ptrFromHandle_Map_string_Ptr_environment_MemberVariable(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_string_Ptr_environment_MemberVariable(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[string]*environment.MemberVariable", p))
}

// --- wrapping map: map[string]*environment.MemberVariable ---
//
//export Map_string_Ptr_environment_MemberVariable_CTor
func Map_string_Ptr_environment_MemberVariable_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_string_Ptr_environment_MemberVariable(&map[string]*environment.MemberVariable{}))
}

//export Map_string_Ptr_environment_MemberVariable_len
func Map_string_Ptr_environment_MemberVariable_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_string_Ptr_environment_MemberVariable(handle))
}

//export Map_string_Ptr_environment_MemberVariable_elem
func Map_string_Ptr_environment_MemberVariable_elem(handle CGoHandle, _ky *C.char) CGoHandle {
	s := deptrFromHandle_Map_string_Ptr_environment_MemberVariable(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_Ptr_environment_MemberVariable(&v)
}

//export Map_string_Ptr_environment_MemberVariable_contains
func Map_string_Ptr_environment_MemberVariable_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_Ptr_environment_MemberVariable(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export Map_string_Ptr_environment_MemberVariable_set
func Map_string_Ptr_environment_MemberVariable_set(handle CGoHandle, _ky *C.char, _vl CGoHandle) {
	s := deptrFromHandle_Map_string_Ptr_environment_MemberVariable(handle)
	s[C.GoString(_ky)] = ptrFromHandle_Ptr_environment_MemberVariable(_vl)
}

//export Map_string_Ptr_environment_MemberVariable_delete
func Map_string_Ptr_environment_MemberVariable_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_Map_string_Ptr_environment_MemberVariable(handle)
	delete(s, C.GoString(_ky))
}

//export Map_string_Ptr_environment_MemberVariable_keys
func Map_string_Ptr_environment_MemberVariable_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_string_Ptr_environment_MemberVariable(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// Converters for implicit pointer handles for type: map[string]*environment.Variable
func ptrFromHandle_Map_string_Ptr_environment_Variable(h CGoHandle) *map[string]*environment.Variable {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[string]*environment.Variable")
	if p == nil {
		return nil
	}
	return p.(*map[string]*environment.Variable)
}
func deptrFromHandle_Map_string_Ptr_environment_Variable(h CGoHandle) map[string]*environment.Variable {
	p := ptrFromHandle_Map_string_Ptr_environment_Variable(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_string_Ptr_environment_Variable(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[string]*environment.Variable", p))
}

// --- wrapping map: map[string]*environment.Variable ---
//
//export Map_string_Ptr_environment_Variable_CTor
func Map_string_Ptr_environment_Variable_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_string_Ptr_environment_Variable(&map[string]*environment.Variable{}))
}

//export Map_string_Ptr_environment_Variable_len
func Map_string_Ptr_environment_Variable_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_string_Ptr_environment_Variable(handle))
}

//export Map_string_Ptr_environment_Variable_elem
func Map_string_Ptr_environment_Variable_elem(handle CGoHandle, _ky *C.char) CGoHandle {
	s := deptrFromHandle_Map_string_Ptr_environment_Variable(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_Ptr_environment_Variable(&v)
}

//export Map_string_Ptr_environment_Variable_contains
func Map_string_Ptr_environment_Variable_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_Ptr_environment_Variable(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export Map_string_Ptr_environment_Variable_set
func Map_string_Ptr_environment_Variable_set(handle CGoHandle, _ky *C.char, _vl CGoHandle) {
	s := deptrFromHandle_Map_string_Ptr_environment_Variable(handle)
	s[C.GoString(_ky)] = ptrFromHandle_Ptr_environment_Variable(_vl)
}

//export Map_string_Ptr_environment_Variable_delete
func Map_string_Ptr_environment_Variable_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_Map_string_Ptr_environment_Variable(handle)
	delete(s, C.GoString(_ky))
}

//export Map_string_Ptr_environment_Variable_keys
func Map_string_Ptr_environment_Variable_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_string_Ptr_environment_Variable(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// Converters for implicit pointer handles for type: map[string]api.GoValue
func ptrFromHandle_Map_string_api_GoValue(h CGoHandle) *map[string]api.GoValue {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[string]api.GoValue")
	if p == nil {
		return nil
	}
	return p.(*map[string]api.GoValue)
}
func deptrFromHandle_Map_string_api_GoValue(h CGoHandle) map[string]api.GoValue {
	p := ptrFromHandle_Map_string_api_GoValue(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_string_api_GoValue(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[string]api.GoValue", p))
}

// --- wrapping map: map[string]api.GoValue ---
//
//export Map_string_api_GoValue_CTor
func Map_string_api_GoValue_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_string_api_GoValue(&map[string]api.GoValue{}))
}

//export Map_string_api_GoValue_len
func Map_string_api_GoValue_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_string_api_GoValue(handle))
}

//export Map_string_api_GoValue_elem
func Map_string_api_GoValue_elem(handle CGoHandle, _ky *C.char) CGoHandle {
	s := deptrFromHandle_Map_string_api_GoValue(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_api_GoValue(&v)
}

//export Map_string_api_GoValue_contains
func Map_string_api_GoValue_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_api_GoValue(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export Map_string_api_GoValue_set
func Map_string_api_GoValue_set(handle CGoHandle, _ky *C.char, _vl CGoHandle) {
	s := deptrFromHandle_Map_string_api_GoValue(handle)
	s[C.GoString(_ky)] = *ptrFromHandle_api_GoValue(_vl)
}

//export Map_string_api_GoValue_delete
func Map_string_api_GoValue_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_Map_string_api_GoValue(handle)
	delete(s, C.GoString(_ky))
}

//export Map_string_api_GoValue_keys
func Map_string_api_GoValue_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_string_api_GoValue(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

// ---- Structs ---

// --- wrapping struct: api.VM ---
//
//export api_VM_CTor
func api_VM_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_api_VM(&api.VM{}))
}

//export api_VM_GetCompatibilityShim
func api_VM_GetCompatibilityShim(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*api.VM")
	if __err != nil {
		return handleFromPtr_Ptr_api_VMCompatibilityShim(nil)
	}
	return handleFromPtr_Ptr_api_VMCompatibilityShim(gopyh.Embed(vifc, reflect.TypeOf(api.VM{})).(*api.VM).GetCompatibilityShim())

}

//export api_VM_Execute
func api_VM_Execute(_handle CGoHandle, code *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*api.VM")
	if __err != nil {
		return handleFromPtr_Ptr_api_ExecutionResult(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(api.VM{})).(*api.VM).Execute(C.GoString(code))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_api_ExecutionResult(nil)
	}
	return handleFromPtr_Ptr_api_ExecutionResult(cret)
}

//export api_VM_ExecuteWithContext
func api_VM_ExecuteWithContext(_handle CGoHandle, ctx CGoHandle, code *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*api.VM")
	if __err != nil {
		return handleFromPtr_Ptr_api_ExecutionResult(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(api.VM{})).(*api.VM).ExecuteWithContext(ptrFromHandle_context_Context(ctx), C.GoString(code))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_api_ExecutionResult(nil)
	}
	return handleFromPtr_Ptr_api_ExecutionResult(cret)
}

//export api_VM_NewObjectInstance
func api_VM_NewObjectInstance(_handle CGoHandle, className *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*api.VM")
	if __err != nil {
		return handleFromPtr_api_GoValue(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(api.VM{})).(*api.VM).NewObjectInstance(C.GoString(className))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_api_GoValue(nil)
	}
	return handleFromPtr_api_GoValue(&cret)
}

//export api_VM_Call
func api_VM_Call(_handle CGoHandle, functionName *C.char, args CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*api.VM")
	if __err != nil {
		return handleFromPtr_api_GoValue(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(api.VM{})).(*api.VM).Call(C.GoString(functionName), deptrFromHandle_Slice_api_GoValue(args))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_api_GoValue(nil)
	}
	return handleFromPtr_api_GoValue(&cret)
}

//export api_VM_CallMethod
func api_VM_CallMethod(_handle CGoHandle, object CGoHandle, methodName *C.char, args CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*api.VM")
	if __err != nil {
		return handleFromPtr_api_GoValue(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(api.VM{})).(*api.VM).CallMethod(*ptrFromHandle_api_GoValue(object), C.GoString(methodName), deptrFromHandle_Slice_api_GoValue(args))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_api_GoValue(nil)
	}
	return handleFromPtr_api_GoValue(&cret)
}

//export api_VM_DefineVariable
func api_VM_DefineVariable(_handle CGoHandle, name *C.char, value CGoHandle, constant C.char) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*api.VM")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(api.VM{})).(*api.VM).DefineVariable(C.GoString(name), *ptrFromHandle_api_GoValue(value), boolPyToGo(constant))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export api_VM_SetVariable
func api_VM_SetVariable(_handle CGoHandle, variableName *C.char, value CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*api.VM")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(api.VM{})).(*api.VM).SetVariable(C.GoString(variableName), *ptrFromHandle_api_GoValue(value))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export api_VM_GetVariable
func api_VM_GetVariable(_handle CGoHandle, variableName *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*api.VM")
	if __err != nil {
		return handleFromPtr_api_GoValue(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(api.VM{})).(*api.VM).GetVariable(C.GoString(variableName))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_api_GoValue(nil)
	}
	return handleFromPtr_api_GoValue(&cret)
}

//export api_VM_DefineClass
func api_VM_DefineClass(_handle CGoHandle, classDef CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*api.VM")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(api.VM{})).(*api.VM).DefineClass(ptrFromHandle_Ptr_api_ClassDefinition(classDef))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// --- wrapping struct: api.VMError ---
//
//export api_VMError_CTor
func api_VMError_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_api_VMError(&api.VMError{}))
}

//export api_VMError_Type_Get
func api_VMError_Type_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_api_VMError(handle)
	return C.CString(string(op.Type))
}

//export api_VMError_Type_Set
func api_VMError_Type_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_api_VMError(handle)
	op.Type = api.ErrorType(C.GoString(val))
}

//export api_VMError_Message_Get
func api_VMError_Message_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_api_VMError(handle)
	return C.CString(op.Message)
}

//export api_VMError_Message_Set
func api_VMError_Message_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_api_VMError(handle)
	op.Message = C.GoString(val)
}

//export api_VMError_Source_Get
func api_VMError_Source_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_api_VMError(handle)
	return handleFromPtr_Ptr_api_SourceLocation(op.Source)
}

//export api_VMError_Source_Set
func api_VMError_Source_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_api_VMError(handle)
	op.Source = ptrFromHandle_Ptr_api_SourceLocation(val)
}

//export api_VMError_Duration_Get
func api_VMError_Duration_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_api_VMError(handle)
	return C.longlong(int64(op.Duration))
}

//export api_VMError_Duration_Set
func api_VMError_Duration_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_api_VMError(handle)
	op.Duration = time.Duration(int64(val))
}

//export api_VMError_Error
func api_VMError_Error(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*api.VMError")
	if __err != nil {
		return C.CString("")
	}
	return C.CString(gopyh.Embed(vifc, reflect.TypeOf(api.VMError{})).(*api.VMError).Error())

}

//export api_VMError_Unwrap
func api_VMError_Unwrap(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*api.VMError")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(api.VMError{})).(*api.VMError).Unwrap()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export api_VMError_IsCompileError
func api_VMError_IsCompileError(_handle CGoHandle) C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*api.VMError")
	if __err != nil {
		return boolGoToPy(false)
	}
	return boolGoToPy(gopyh.Embed(vifc, reflect.TypeOf(api.VMError{})).(*api.VMError).IsCompileError())

}

//export api_VMError_IsRuntimeError
func api_VMError_IsRuntimeError(_handle CGoHandle) C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*api.VMError")
	if __err != nil {
		return boolGoToPy(false)
	}
	return boolGoToPy(gopyh.Embed(vifc, reflect.TypeOf(api.VMError{})).(*api.VMError).IsRuntimeError())

}

//export api_VMError_IsTimeoutError
func api_VMError_IsTimeoutError(_handle CGoHandle) C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*api.VMError")
	if __err != nil {
		return boolGoToPy(false)
	}
	return boolGoToPy(gopyh.Embed(vifc, reflect.TypeOf(api.VMError{})).(*api.VMError).IsTimeoutError())

}

//export api_VMError_IsConversionError
func api_VMError_IsConversionError(_handle CGoHandle) C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*api.VMError")
	if __err != nil {
		return boolGoToPy(false)
	}
	return boolGoToPy(gopyh.Embed(vifc, reflect.TypeOf(api.VMError{})).(*api.VMError).IsConversionError())

}

//export api_VMError_IsConfigError
func api_VMError_IsConfigError(_handle CGoHandle) C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*api.VMError")
	if __err != nil {
		return boolGoToPy(false)
	}
	return boolGoToPy(gopyh.Embed(vifc, reflect.TypeOf(api.VMError{})).(*api.VMError).IsConfigError())

}

// --- wrapping struct: api.ClassVariable ---
//
//export api_ClassVariable_CTor
func api_ClassVariable_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_api_ClassVariable(&api.ClassVariable{}))
}

//export api_ClassVariable_Name_Get
func api_ClassVariable_Name_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_api_ClassVariable(handle)
	return C.CString(op.Name)
}

//export api_ClassVariable_Name_Set
func api_ClassVariable_Name_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_api_ClassVariable(handle)
	op.Name = C.GoString(val)
}

//export api_ClassVariable_Value_Get
func api_ClassVariable_Value_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_api_ClassVariable(handle)
	return handleFromPtr_api_GoValue(&op.Value)
}

//export api_ClassVariable_Value_Set
func api_ClassVariable_Value_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_api_ClassVariable(handle)
	op.Value = *ptrFromHandle_api_GoValue(val)
}

//export api_ClassVariable_Locked_Get
func api_ClassVariable_Locked_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_api_ClassVariable(handle)
	return boolGoToPy(op.Locked)
}

//export api_ClassVariable_Locked_Set
func api_ClassVariable_Locked_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_api_ClassVariable(handle)
	op.Locked = boolPyToGo(val)
}

// --- wrapping struct: api.GoValue ---
//
//export api_GoValue_CTor
func api_GoValue_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_api_GoValue(&api.GoValue{}))
}

//export api_GoValue_ID
func api_GoValue_ID(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*api.GoValue")
	if __err != nil {
		return C.CString("")
	}
	return C.CString(gopyh.Embed(vifc, reflect.TypeOf(api.GoValue{})).(*api.GoValue).ID())

}

//export api_GoValue_MarshalJSON
func api_GoValue_MarshalJSON(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*api.GoValue")
	if __err != nil {
		return handleFromPtr_Slice_byte(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(api.GoValue{})).(*api.GoValue).MarshalJSON()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_byte(nil)
	}
	return handleFromPtr_Slice_byte(&cret)
}

//export api_GoValue_Type
func api_GoValue_Type(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*api.GoValue")
	if __err != nil {
		return C.CString("")
	}
	return C.CString(gopyh.Embed(vifc, reflect.TypeOf(api.GoValue{})).(*api.GoValue).Type())

}

//export api_GoValue_Int
func api_GoValue_Int(_handle CGoHandle) C.longlong {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*api.GoValue")
	if __err != nil {
		return C.longlong(0)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(api.GoValue{})).(*api.GoValue).Int()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return C.longlong(0)
	}
	return C.longlong(cret)
}

//export api_GoValue_Float
func api_GoValue_Float(_handle CGoHandle) C.double {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*api.GoValue")
	if __err != nil {
		return C.double(0)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(api.GoValue{})).(*api.GoValue).Float()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return C.double(0)
	}
	return C.double(cret)
}

//export api_GoValue_String
func api_GoValue_String(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*api.GoValue")
	if __err != nil {
		return C.CString("")
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(api.GoValue{})).(*api.GoValue).String()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return C.CString("")
	}
	return C.CString(cret)
}

//export api_GoValue_Bool
func api_GoValue_Bool(_handle CGoHandle) C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*api.GoValue")
	if __err != nil {
		return boolGoToPy(false)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(api.GoValue{})).(*api.GoValue).Bool()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return boolGoToPy(false)
	}
	return boolGoToPy(cret)
}

//export api_GoValue_Slice
func api_GoValue_Slice(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*api.GoValue")
	if __err != nil {
		return handleFromPtr_Slice_api_GoValue(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(api.GoValue{})).(*api.GoValue).Slice()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_api_GoValue(nil)
	}
	return handleFromPtr_Slice_api_GoValue(&cret)
}

//export api_GoValue_Map
func api_GoValue_Map(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*api.GoValue")
	if __err != nil {
		return handleFromPtr_Map_string_api_GoValue(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(api.GoValue{})).(*api.GoValue).Map()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Map_string_api_GoValue(nil)
	}
	return handleFromPtr_Map_string_api_GoValue(&cret)
}

//export api_GoValue_Object
func api_GoValue_Object(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*api.GoValue")
	if __err != nil {
		return handleFromPtr_Ptr_environment_ObjectInstance(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(api.GoValue{})).(*api.GoValue).Object()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_environment_ObjectInstance(nil)
	}
	return handleFromPtr_Ptr_environment_ObjectInstance(cret)
}

// --- wrapping struct: api.UnknownFunctionHandler ---
//
//export api_UnknownFunctionHandler_CTor
func api_UnknownFunctionHandler_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_api_UnknownFunctionHandler(&api.UnknownFunctionHandler{}))
}

// --- wrapping struct: api.SourceLocation ---
//
//export api_SourceLocation_CTor
func api_SourceLocation_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_api_SourceLocation(&api.SourceLocation{}))
}

//export api_SourceLocation_Filename_Get
func api_SourceLocation_Filename_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_api_SourceLocation(handle)
	return C.CString(op.Filename)
}

//export api_SourceLocation_Filename_Set
func api_SourceLocation_Filename_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_api_SourceLocation(handle)
	op.Filename = C.GoString(val)
}

//export api_SourceLocation_Line_Get
func api_SourceLocation_Line_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_api_SourceLocation(handle)
	return C.longlong(op.Line)
}

//export api_SourceLocation_Line_Set
func api_SourceLocation_Line_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_api_SourceLocation(handle)
	op.Line = int(val)
}

//export api_SourceLocation_Column_Get
func api_SourceLocation_Column_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_api_SourceLocation(handle)
	return C.longlong(op.Column)
}

//export api_SourceLocation_Column_Set
func api_SourceLocation_Column_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_api_SourceLocation(handle)
	op.Column = int(val)
}

// --- wrapping struct: api.VMCompatibilityShim ---
//
//export api_VMCompatibilityShim_CTor
func api_VMCompatibilityShim_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_api_VMCompatibilityShim(&api.VMCompatibilityShim{}))
}

//export api_VMCompatibilityShim_DefineFunction
func api_VMCompatibilityShim_DefineFunction(_handle CGoHandle, id *C.char, name *C.char, argc C.longlong, function *C.PyObject) *C.char {
	_fun_arg := function
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*api.VMCompatibilityShim")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(api.VMCompatibilityShim{})).(*api.VMCompatibilityShim).DefineFunction(C.GoString(id), C.GoString(name), int(argc), func(id string, jsonArgs string) string {
		if C.PyCallable_Check(_fun_arg) == 0 {
			return C.GoString(nil)
		}
		_gstate := C.PyGILState_Ensure()
		_fcargs := C.PyTuple_New(2)
		C.PyTuple_SetItem(_fcargs, 0, C.gopy_build_string(C.CString(id)))
		C.PyTuple_SetItem(_fcargs, 1, C.gopy_build_string(C.CString(jsonArgs)))
		_fcret := C.PyObject_CallObject(_fun_arg, _fcargs)
		C.gopy_decref(_fcargs)
		C.gopy_err_handle()
		C.PyGILState_Release(_gstate)
		return C.GoString(C.PyBytes_AsString(_fcret))
	})

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export api_VMCompatibilityShim_BuildNewClassVariableWithGetter
func api_VMCompatibilityShim_BuildNewClassVariableWithGetter(_handle CGoHandle, variable CGoHandle, getterID *C.char, getter *C.PyObject) CGoHandle {
	_fun_arg := getter
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*api.VMCompatibilityShim")
	if __err != nil {
		return handleFromPtr_Ptr_api_ClassVariable(nil)
	}
	return handleFromPtr_Ptr_api_ClassVariable(gopyh.Embed(vifc, reflect.TypeOf(api.VMCompatibilityShim{})).(*api.VMCompatibilityShim).BuildNewClassVariableWithGetter(ptrFromHandle_Ptr_api_ClassVariable(variable), C.GoString(getterID), func(id string, jsonArgs string) string {
		if C.PyCallable_Check(_fun_arg) == 0 {
			return C.GoString(nil)
		}
		_gstate := C.PyGILState_Ensure()
		_fcargs := C.PyTuple_New(2)
		C.PyTuple_SetItem(_fcargs, 0, C.gopy_build_string(C.CString(id)))
		C.PyTuple_SetItem(_fcargs, 1, C.gopy_build_string(C.CString(jsonArgs)))
		_fcret := C.PyObject_CallObject(_fun_arg, _fcargs)
		C.gopy_decref(_fcargs)
		C.gopy_err_handle()
		C.PyGILState_Release(_gstate)
		return C.GoString(C.PyBytes_AsString(_fcret))
	}))

}

//export api_VMCompatibilityShim_BuildNewClassVariableWithSetter
func api_VMCompatibilityShim_BuildNewClassVariableWithSetter(_handle CGoHandle, variable CGoHandle, setterID *C.char, setter *C.PyObject) CGoHandle {
	_fun_arg := setter
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*api.VMCompatibilityShim")
	if __err != nil {
		return handleFromPtr_Ptr_api_ClassVariable(nil)
	}
	return handleFromPtr_Ptr_api_ClassVariable(gopyh.Embed(vifc, reflect.TypeOf(api.VMCompatibilityShim{})).(*api.VMCompatibilityShim).BuildNewClassVariableWithSetter(ptrFromHandle_Ptr_api_ClassVariable(variable), C.GoString(setterID), func(id string, jsonArgs string) string {
		if C.PyCallable_Check(_fun_arg) == 0 {
			return C.GoString(nil)
		}
		_gstate := C.PyGILState_Ensure()
		_fcargs := C.PyTuple_New(2)
		C.PyTuple_SetItem(_fcargs, 0, C.gopy_build_string(C.CString(id)))
		C.PyTuple_SetItem(_fcargs, 1, C.gopy_build_string(C.CString(jsonArgs)))
		_fcret := C.PyObject_CallObject(_fun_arg, _fcargs)
		C.gopy_decref(_fcargs)
		C.gopy_err_handle()
		C.PyGILState_Release(_gstate)
		return C.GoString(C.PyBytes_AsString(_fcret))
	}))

}

//export api_VMCompatibilityShim_BuildNewClassMethod
func api_VMCompatibilityShim_BuildNewClassMethod(_handle CGoHandle, method CGoHandle, id *C.char, function *C.PyObject) CGoHandle {
	_fun_arg := function
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*api.VMCompatibilityShim")
	if __err != nil {
		return handleFromPtr_Ptr_api_ClassMethod(nil)
	}
	return handleFromPtr_Ptr_api_ClassMethod(gopyh.Embed(vifc, reflect.TypeOf(api.VMCompatibilityShim{})).(*api.VMCompatibilityShim).BuildNewClassMethod(ptrFromHandle_Ptr_api_ClassMethod(method), C.GoString(id), func(id string, jsonArgs string) string {
		if C.PyCallable_Check(_fun_arg) == 0 {
			return C.GoString(nil)
		}
		_gstate := C.PyGILState_Ensure()
		_fcargs := C.PyTuple_New(2)
		C.PyTuple_SetItem(_fcargs, 0, C.gopy_build_string(C.CString(id)))
		C.PyTuple_SetItem(_fcargs, 1, C.gopy_build_string(C.CString(jsonArgs)))
		_fcret := C.PyObject_CallObject(_fun_arg, _fcargs)
		C.gopy_decref(_fcargs)
		C.gopy_err_handle()
		C.PyGILState_Release(_gstate)
		return C.GoString(C.PyBytes_AsString(_fcret))
	}))

}

//export api_VMCompatibilityShim_BuildNewUnknownFunctionHandler
func api_VMCompatibilityShim_BuildNewUnknownFunctionHandler(_handle CGoHandle, id *C.char, function *C.PyObject) CGoHandle {
	_fun_arg := function
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*api.VMCompatibilityShim")
	if __err != nil {
		return handleFromPtr_api_UnknownFunctionHandler(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(api.VMCompatibilityShim{})).(*api.VMCompatibilityShim).BuildNewUnknownFunctionHandler(C.GoString(id), func(id string, jsonArgs string) string {
		if C.PyCallable_Check(_fun_arg) == 0 {
			return C.GoString(nil)
		}
		_gstate := C.PyGILState_Ensure()
		_fcargs := C.PyTuple_New(2)
		C.PyTuple_SetItem(_fcargs, 0, C.gopy_build_string(C.CString(id)))
		C.PyTuple_SetItem(_fcargs, 1, C.gopy_build_string(C.CString(jsonArgs)))
		_fcret := C.PyObject_CallObject(_fun_arg, _fcargs)
		C.gopy_decref(_fcargs)
		C.gopy_err_handle()
		C.PyGILState_Release(_gstate)
		return C.GoString(C.PyBytes_AsString(_fcret))
	})

	return handleFromPtr_api_UnknownFunctionHandler(&cret)
}

//export api_VMCompatibilityShim_IsClassDefined
func api_VMCompatibilityShim_IsClassDefined(_handle CGoHandle, name *C.char) C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*api.VMCompatibilityShim")
	if __err != nil {
		return boolGoToPy(false)
	}
	return boolGoToPy(gopyh.Embed(vifc, reflect.TypeOf(api.VMCompatibilityShim{})).(*api.VMCompatibilityShim).IsClassDefined(C.GoString(name)))

}

//export api_VMCompatibilityShim_LookupObject
func api_VMCompatibilityShim_LookupObject(_handle CGoHandle, id *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*api.VMCompatibilityShim")
	if __err != nil {
		return handleFromPtr_api_GoValue(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(api.VMCompatibilityShim{})).(*api.VMCompatibilityShim).LookupObject(C.GoString(id))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_api_GoValue(nil)
	}
	return handleFromPtr_api_GoValue(&cret)
}

//export api_VMCompatibilityShim_GetObjectMRO
func api_VMCompatibilityShim_GetObjectMRO(_handle CGoHandle, id *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*api.VMCompatibilityShim")
	if __err != nil {
		return handleFromPtr_Slice_string(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(api.VMCompatibilityShim{})).(*api.VMCompatibilityShim).GetObjectMRO(C.GoString(id))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_string(nil)
	}
	return handleFromPtr_Slice_string(&cret)
}

//export api_VMCompatibilityShim_GetObjectImmediateFunctions
func api_VMCompatibilityShim_GetObjectImmediateFunctions(_handle CGoHandle, id *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*api.VMCompatibilityShim")
	if __err != nil {
		return handleFromPtr_Slice_string(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(api.VMCompatibilityShim{})).(*api.VMCompatibilityShim).GetObjectImmediateFunctions(C.GoString(id))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_string(nil)
	}
	return handleFromPtr_Slice_string(&cret)
}

//export api_VMCompatibilityShim_GetObjectImmediateVariables
func api_VMCompatibilityShim_GetObjectImmediateVariables(_handle CGoHandle, id *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*api.VMCompatibilityShim")
	if __err != nil {
		return handleFromPtr_Slice_string(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(api.VMCompatibilityShim{})).(*api.VMCompatibilityShim).GetObjectImmediateVariables(C.GoString(id))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_string(nil)
	}
	return handleFromPtr_Slice_string(&cret)
}

//export api_VMCompatibilityShim_AddVariableToObject
func api_VMCompatibilityShim_AddVariableToObject(_handle CGoHandle, id *C.char, variable CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*api.VMCompatibilityShim")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(api.VMCompatibilityShim{})).(*api.VMCompatibilityShim).AddVariableToObject(C.GoString(id), ptrFromHandle_Ptr_api_ClassVariable(variable))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// --- wrapping struct: api.VMConfig ---
//
//export api_VMConfig_CTor
func api_VMConfig_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_api_VMConfig(&api.VMConfig{}))
}

//export api_VMConfig_Stdout_Get
func api_VMConfig_Stdout_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_api_VMConfig(handle)
	return handleFromPtr_io_Writer(op.Stdout)
}

//export api_VMConfig_Stdout_Set
func api_VMConfig_Stdout_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_api_VMConfig(handle)
	op.Stdout = ptrFromHandle_io_Writer(val)
}

//export api_VMConfig_Stdin_Get
func api_VMConfig_Stdin_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_api_VMConfig(handle)
	return handleFromPtr_io_Reader(op.Stdin)
}

//export api_VMConfig_Stdin_Set
func api_VMConfig_Stdin_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_api_VMConfig(handle)
	op.Stdin = ptrFromHandle_io_Reader(val)
}

//export api_VMConfig_Timeout_Get
func api_VMConfig_Timeout_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_api_VMConfig(handle)
	return C.longlong(int64(op.Timeout))
}

//export api_VMConfig_Timeout_Set
func api_VMConfig_Timeout_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_api_VMConfig(handle)
	op.Timeout = time.Duration(int64(val))
}

//export api_VMConfig_WorkingDirectory_Get
func api_VMConfig_WorkingDirectory_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_api_VMConfig(handle)
	return C.CString(op.WorkingDirectory)
}

//export api_VMConfig_WorkingDirectory_Set
func api_VMConfig_WorkingDirectory_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_api_VMConfig(handle)
	op.WorkingDirectory = C.GoString(val)
}

//export api_VMConfig_Validate
func api_VMConfig_Validate(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*api.VMConfig")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(api.VMConfig{})).(*api.VMConfig).Validate()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// --- wrapping struct: api.ClassDefinition ---
//
//export api_ClassDefinition_CTor
func api_ClassDefinition_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_api_ClassDefinition(&api.ClassDefinition{}))
}

//export api_ClassDefinition_Name_Get
func api_ClassDefinition_Name_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_api_ClassDefinition(handle)
	return C.CString(op.Name)
}

//export api_ClassDefinition_Name_Set
func api_ClassDefinition_Name_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_api_ClassDefinition(handle)
	op.Name = C.GoString(val)
}

//export api_ClassDefinition_PublicVariables_Get
func api_ClassDefinition_PublicVariables_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_api_ClassDefinition(handle)
	return handleFromPtr_Map_string_Ptr_api_ClassVariable(&op.PublicVariables)
}

//export api_ClassDefinition_PublicVariables_Set
func api_ClassDefinition_PublicVariables_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_api_ClassDefinition(handle)
	op.PublicVariables = deptrFromHandle_Map_string_Ptr_api_ClassVariable(val)
}

//export api_ClassDefinition_PrivateVariables_Get
func api_ClassDefinition_PrivateVariables_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_api_ClassDefinition(handle)
	return handleFromPtr_Map_string_Ptr_api_ClassVariable(&op.PrivateVariables)
}

//export api_ClassDefinition_PrivateVariables_Set
func api_ClassDefinition_PrivateVariables_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_api_ClassDefinition(handle)
	op.PrivateVariables = deptrFromHandle_Map_string_Ptr_api_ClassVariable(val)
}

//export api_ClassDefinition_SharedVariables_Get
func api_ClassDefinition_SharedVariables_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_api_ClassDefinition(handle)
	return handleFromPtr_Map_string_Ptr_api_ClassVariable(&op.SharedVariables)
}

//export api_ClassDefinition_SharedVariables_Set
func api_ClassDefinition_SharedVariables_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_api_ClassDefinition(handle)
	op.SharedVariables = deptrFromHandle_Map_string_Ptr_api_ClassVariable(val)
}

//export api_ClassDefinition_PublicMethods_Get
func api_ClassDefinition_PublicMethods_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_api_ClassDefinition(handle)
	return handleFromPtr_Map_string_Ptr_api_ClassMethod(&op.PublicMethods)
}

//export api_ClassDefinition_PublicMethods_Set
func api_ClassDefinition_PublicMethods_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_api_ClassDefinition(handle)
	op.PublicMethods = deptrFromHandle_Map_string_Ptr_api_ClassMethod(val)
}

//export api_ClassDefinition_PrivateMethods_Get
func api_ClassDefinition_PrivateMethods_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_api_ClassDefinition(handle)
	return handleFromPtr_Map_string_Ptr_api_ClassMethod(&op.PrivateMethods)
}

//export api_ClassDefinition_PrivateMethods_Set
func api_ClassDefinition_PrivateMethods_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_api_ClassDefinition(handle)
	op.PrivateMethods = deptrFromHandle_Map_string_Ptr_api_ClassMethod(val)
}

//export api_ClassDefinition_UnknownFunctionHandler_Get
func api_ClassDefinition_UnknownFunctionHandler_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_api_ClassDefinition(handle)
	return handleFromPtr_Ptr_api_UnknownFunctionHandler(op.UnknownFunctionHandler)
}

//export api_ClassDefinition_UnknownFunctionHandler_Set
func api_ClassDefinition_UnknownFunctionHandler_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_api_ClassDefinition(handle)
	op.UnknownFunctionHandler = ptrFromHandle_Ptr_api_UnknownFunctionHandler(val)
}

// --- wrapping struct: api.ClassMethod ---
//
//export api_ClassMethod_CTor
func api_ClassMethod_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_api_ClassMethod(&api.ClassMethod{}))
}

//export api_ClassMethod_Name_Get
func api_ClassMethod_Name_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_api_ClassMethod(handle)
	return C.CString(op.Name)
}

//export api_ClassMethod_Name_Set
func api_ClassMethod_Name_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_api_ClassMethod(handle)
	op.Name = C.GoString(val)
}

//export api_ClassMethod_Argc_Get
func api_ClassMethod_Argc_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_api_ClassMethod(handle)
	return C.longlong(op.Argc)
}

//export api_ClassMethod_Argc_Set
func api_ClassMethod_Argc_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_api_ClassMethod(handle)
	op.Argc = int(val)
}

// --- wrapping struct: api.ExecutionResult ---
//
//export api_ExecutionResult_CTor
func api_ExecutionResult_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_api_ExecutionResult(&api.ExecutionResult{}))
}

//export api_ExecutionResult_Value_Get
func api_ExecutionResult_Value_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_api_ExecutionResult(handle)
	return handleFromPtr_api_GoValue(&op.Value)
}

//export api_ExecutionResult_Value_Set
func api_ExecutionResult_Value_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_api_ExecutionResult(handle)
	op.Value = *ptrFromHandle_api_GoValue(val)
}

//export api_ExecutionResult_RawValue_Get
func api_ExecutionResult_RawValue_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_api_ExecutionResult(handle)
	return handleFromPtr_environment_Value(op.RawValue)
}

//export api_ExecutionResult_RawValue_Set
func api_ExecutionResult_RawValue_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_api_ExecutionResult(handle)
	op.RawValue = ptrFromHandle_environment_Value(val)
}

//export api_ExecutionResult_Output_Get
func api_ExecutionResult_Output_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_api_ExecutionResult(handle)
	return C.CString(op.Output)
}

//export api_ExecutionResult_Output_Set
func api_ExecutionResult_Output_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_api_ExecutionResult(handle)
	op.Output = C.GoString(val)
}

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

//export api_NewVM
func api_NewVM(config CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := api.NewVM(ptrFromHandle_Ptr_api_VMConfig(config))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_api_VM(nil)
	}
	return handleFromPtr_Ptr_api_VM(cret)
}

//export api_NewCompileError
func api_NewCompileError(message *C.char, source CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_api_VMError(api.NewCompileError(C.GoString(message), ptrFromHandle_Ptr_api_SourceLocation(source)))

}

//export api_NewTimeoutError
func api_NewTimeoutError(duration C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_api_VMError(api.NewTimeoutError(time.Duration(int64(duration))))

}

//export api_NewConfigError
func api_NewConfigError(message *C.char, wrapped *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_api_VMError(api.NewConfigError(C.GoString(message), errors.New(C.GoString(wrapped))))

}

//export api_NewConversionError
func api_NewConversionError(message *C.char, wrapped *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_api_VMError(api.NewConversionError(C.GoString(message), errors.New(C.GoString(wrapped))))

}

//export api_NewRuntimeError
func api_NewRuntimeError(message *C.char, source CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_api_VMError(api.NewRuntimeError(C.GoString(message), ptrFromHandle_Ptr_api_SourceLocation(source)))

}

//export api_WrapString
func api_WrapString(value *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := api.WrapString(C.GoString(value))

	return handleFromPtr_api_GoValue(&cret)
}

//export api_ToGoValue
func api_ToGoValue(val CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := api.ToGoValue(ptrFromHandle_environment_Value(val))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_api_GoValue(nil)
	}
	return handleFromPtr_api_GoValue(&cret)
}

//export api_WrapBool
func api_WrapBool(value C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := api.WrapBool(boolPyToGo(value))

	return handleFromPtr_api_GoValue(&cret)
}

//export api_WrapFloat
func api_WrapFloat(value C.double) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := api.WrapFloat(float64(value))

	return handleFromPtr_api_GoValue(&cret)
}

//export api_WrapAny
func api_WrapAny(value *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := api.WrapAny(C.GoString(value))

	return handleFromPtr_api_GoValue(&cret)
}

//export api_WrapObject
func api_WrapObject(value CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := api.WrapObject(ptrFromHandle_Ptr_environment_ObjectInstance(value))

	return handleFromPtr_api_GoValue(&cret)
}

//export api_WrapInt
func api_WrapInt(value C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := api.WrapInt(int64(value))

	return handleFromPtr_api_GoValue(&cret)
}

//export api_DefaultConfig
func api_DefaultConfig() CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_api_VMConfig(api.DefaultConfig())

}

//export api_NewClassDefinition
func api_NewClassDefinition() CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_api_ClassDefinition(api.NewClassDefinition())

}

// ---- Functions ---

//export api_LookupObject
func api_LookupObject(id *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := api.LookupObject(C.GoString(id))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_environment_ObjectInstance(nil)
	}
	return handleFromPtr_Ptr_environment_ObjectInstance(cret)
}

//export api_ConvertArguments
func api_ConvertArguments(args CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := api.ConvertArguments(deptrFromHandle_Slice_api_GoValue(args))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_environment_Value(nil)
	}
	return handleFromPtr_Slice_environment_Value(&cret)
}

//export api_FromGoValue
func api_FromGoValue(val CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := api.FromGoValue(*ptrFromHandle_api_GoValue(val))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_environment_Value(nil)
	}
	return handleFromPtr_environment_Value(cret)
}

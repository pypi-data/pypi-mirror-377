; This ini file is to use the test sampler to produce
; GI and II Cl power spectra for KiDS-1000 n(z) using the Halo Model

[DEFAULT]
nz_def = 10
nk_def = 300
zmin_def =  0.0
zmax_def = 2.0
nmass_def = 200
logmassmin_def = 9.0
logmassmax_def = 16.0
#beta_nl = True  #The Beta_nl correction is slow => 60 seconds for one test sampler :(
beta_nl = False  #The Beta_nl correction is slow => 60 seconds for one test sampler :(
RUN_NAME = HM_IA
MY_PATH = /Users/cheymans/CosmoSIS/
CSL_PATH = %(MY_PATH)s/cosmosis-standard-library
pipeline_path = %(MY_PATH)s/halomodel_for_cosmosis
# Using the KiDS-1000 n(z) from this file within the cosmosis standard library
DATAFILE=%(CSL_PATH)s/likelihood/des-y3_and_kids-1000/DES-Y3_xipm_and_KiDS-1000_COSEBIs_2.0_300.0.fits

[pipeline]
timing=T
debug=T
modules =   consistency camb extrapolate halo_model_ingredients
            hod_red red_alignment radial_satellite_alignment_red
            hod_blue blue_alignment radial_satellite_alignment_blue #bnl #bnl_cosmopower
            pk_red pk_blue add_red_and_blue_power
            fits_nz photoz_bias
            pk_to_cl add_intrinsic

values = %(pipeline_path)s/example_ini_files/IA_comparison/values.ini


; Since CosmoSIS v3, the consistency interface allows for sampling over S8
; Here we set up the non-linear power spectrum
[consistency]
file = %(CSL_PATH)s/utility/consistency/consistency_interface.py

[camb]
file = %(CSL_PATH)s/boltzmann/camb/camb_interface.py
mode = all
halofit_version = mead2020_feedback
neutrino_hierarchy = normal
lmax=2500
kmax=100.0
zmid = 2.0
nz_mid = 100
zmax = 6.0
nz = 150
feedback=0

[extrapolate]
file = %(CSL_PATH)s/boltzmann/extrapolate/extrapolate_power.py
kmax = 1e8
nmax = 0 ; 2580

; Now we have a power spectrum, it's time to define the
; dark matter halo mass function, halo bias and mass-concentration relation
[halo_model_ingredients]
file = %(pipeline_path)s/halo_model_ingredients.py
log_mass_min = %(logmassmin_def)s
log_mass_max = %(logmassmax_def)s
nmass = %(nmass_def)s
zmin= %(zmin_def)s
zmax= %(zmax_def)s
nz= %(nz_def)s
nk= %(nk_def)s
#TO DO write out what the options are....
; Options for
; 1) hmf_model (the halo mass function) are defined by the hmf package
; 2) bias_model (the halo bias model) are defined by halomod package
; 3) mdef_model (the halo mass definition) are defined in the hmf and halomod packages
; 4) cm_models (the mass-concentration relation) are defined by the colossus package
hmf_model =  ST ;Tinker10
bias_model =  ST99 ;Tinker10
mdef_model =  SOVirial ;SOMean
overdensity = 200
delta_c = 1.686
cm_model =  bullock01 ;duffy08
; The parameter 'use_mead2020_corrections' specifies which corrections to the Pmm to use:
; options are: 'mead2020', 'mead2020_feedback', 'fit_feedback', for which the first two are the same as used by CAMB,
; and 'fit_feedback' allows one to fit for the feedback using f* derived from HOD and concentration parameters.
; USED by nfw module and pk modules as well!
use_mead2020_corrections = fit_feedback ; mead2020_feedback


; Next we're going to add galaxies using an HOD
[hod_red]
file = %(pipeline_path)s/hod_interface.py
; We have two options about how we want to pass information about the survey flux limit

; Option 1
; Provide a text file with the minimum and maximum luminosity (or stellar mass) per fine zbin
; with the format [z_mid, lum_min(z), lum_max(z)]
; In this mode we calculate only one HOD for the whole sample (e.g hod_red)
; This is useful for our source sample which we'll approximate as having a single HOD
;--------
; observables_file = %(pipeline_path)s/input_files/red_cen_lum_pdf.txt
;--------

; Option 2
; If observables_file is not provided in the ini file, instead
; Provide the minimum and maximum stellar mass (or luminosity) and the broad z-range where this sample is complete
; In this mode an HOD is calculated for each defined sample that is then used in the pk module (e.g hod_red_1, hod_red_2, hod_red_3)
; Importantly the length of obs_min, obs_max, zmin, zmax need to be the same!
; This is useful when we have different lens samples
;--------
; obs_min = 9.0,9.0,10.0
; obs_max = 11.5,11.5,11.5
; zmin = 0.0,0.2,0.5
; zmax = 0.2,0.5,1.7
;--------

; The HOD is only defined over the range zmin to zmax so make sure to provide it with enough information
; to cover the full z-range that you want power spectra calculated for
; The galaxy power will be zero for z>zmax

; In this cosmic shear focused IA example ini we'll the luminosity route noting that this limits us to
; zmax=1.4.  This needs correcting with an extended file in the future
observables_file = %(pipeline_path)s/input_files/red_cen_lum_pdf.txt
#TODO - continue adding info on what these parameters are
nobs = 200
log_mass_min = %(logmassmin_def)s
log_mass_max = %(logmassmax_def)s
nmass = %(nmass_def)s
hod_section_name = hod_red
values_name = hod_parameters_red
observable_section_name = luminosity_function_red
galaxy_bias_section_name = galaxy_bias_blue
output_suffix = red       ; output suffix to the default block name which is also the
                        ; suffix of the default parameter section

[hod_blue]
; For Instructions see above in [hod_red]
file = %(pipeline_path)s/hod_interface.py
observables_file = %(pipeline_path)s/input_files/blue_cen_lum_pdf.txt
nobs = 200
log_mass_min = %(logmassmin_def)s
log_mass_max = %(logmassmax_def)s
nmass = %(nmass_def)s
hod_section_name = hod_blue
values_name = hod_parameters_blue
observable_section_name = luminosity_function_blue
galaxy_bias_section_name = galaxy_bias_blue
output_suffix = blue


# This is an example for the IA model depending on luminosity
# It requires measurements of the average luminosity of the centrals and satellites per z-bin
# see issue https://github.com/KiDS-WL/halomodel_for_cosmosis/issues/13
[red_alignment]
file = %(pipeline_path)s/ia_amplitudes.py
; for centrals, the choices are : 'constant', 'luminosity' or 'halo_mass'
central_IA_depends_on = luminosity
z_loglum_file_centrals = %(pipeline_path)s/input_files/redcen_lum.fits ; a fits file containing the columns 'z' and 'loglum'
; for satellites, the choices are : 'constant', 'luminosity' or 'halo_mass'
satellite_IA_depends_on = luminosity
z_loglum_file_satellites = %(pipeline_path)s/input_files/redsat_lum.fits
zmin= %(zmin_def)s
zmax= %(zmax_def)s
nz = %(nz_def)s
output_suffix = red

[blue_alignment]
file = %(pipeline_path)s/ia_amplitudes.py
central_IA_depends_on = constant
satellite_IA_depends_on = luminosity
z_loglum_file_satellites = %(pipeline_path)s/input_files/bluesat_lum.fits
zmin= %(zmin_def)s
zmax= %(zmax_def)s
nz = %(nz_def)s
output_suffix = blue

# This is where the IA model depends on halo mass
; It currently gives strange results - DO NOT USE
;[red_alignment]
;file = %(pipeline_path)s/ia_amplitudes.py
; the choices are : 'constant', 'luminosity' or 'halo_mass'
;central_IA_depends_on = halo_mass
;satellite_IA_depends_on = halo_mass
;zmin= %(zmin_def)s
;zmax= %(zmax_def)s
;nz = %(nz_def)s
;output_suffix = red

;[blue_alignment]
;file = %(pipeline_path)s/ia_amplitudes.py
;central_IA_depends_on = constant
;satellite_IA_depends_on = halo_mass
;zmin= %(zmin_def)s
;zmax= %(zmax_def)s
;nz = %(nz_def)s
;output_suffix = blue


[radial_satellite_alignment_red]
file = %(pipeline_path)s/ia_radial_interface.py
output_suffix=red
#These are the fast default parameters
#If you want a more accurate model raise the nmass and nk values here
#nmass = 5
#kmin = 0.001
#kmax = 1000.
#nk = 10

[radial_satellite_alignment_blue]
file = %(pipeline_path)s/ia_radial_interface.py
output_suffix=blue


[bnl]
; This is slow but accurate > 60 seconds per sample
; Calculates the non-linear halo bias correction beta_nl using the DarkEmulator
; interpolate_bnl is now set to True always
; update_bnl specifies how often the beta_nl gets recalculated (how many calls to the model in between)
file= %(pipeline_path)s/bnl_interface.py
;log-spaced mass in units of M_sun/h
log_mass_min = %(logmassmin_def)s
log_mass_max = %(logmassmax_def)s
nmass = %(nmass_def)s
zmin = %(zmin_def)s
zmax = %(zmax_def)s
nz = %(nz_def)s
nk = %(nk_def)s
bnl = %(beta_nl)s
interpolate_bnl = True
update_bnl = 10

[bnl_cosmopower]
file= %(pipeline_path)s/bnl_interface_cosmopower.py
;log-spaced mass in units of M_sun/h
log_mass_min = %(logmassmin_def)s
log_mass_max = %(logmassmax_def)s
nmass = %(nmass_def)s
zmin = %(zmin_def)s
zmax = %(zmax_def)s
nz = %(nz_def)s
kmax = 10.0
kmin = 1e-5
nk = %(nk_def)s
use_specific_k_modes = True
path_2_trained_emulator = /path/to/emulator
bnl = %(beta_nl)s
interpolate_bnl = True
update_bnl = 10

[bnl_delete]
file= %(pipeline_path)s/bnl_interface_delete.py
keep_bnl = False

[pk_red]
file= %(pipeline_path)s/pk_interface.py
;log-spaced mass in units of M_sun/h
log_mass_min = %(logmassmin_def)s
log_mass_max = %(logmassmax_def)s
nmass = %(nmass_def)s
zmin = %(zmin_def)s
zmax = %(zmax_def)s
nz = %(nz_def)s
nk = %(nk_def)s
bnl =  %(beta_nl)s
p_mm = False
p_gg = False
p_gm = False
p_gI = False
p_mI = True
p_II = True
two_halo_only = False
hod_section_name = hod_red  ; Input hod section
output_suffix = red         ; Output suffix to the default block name
poisson_type = scalar       ; Specifies the type of the Poisson parameter model
                            ; Can be 'scalar', 'power_law', 'scalar_per_bin'

[pk_blue]
file= %(pipeline_path)s/pk_interface.py
;log-spaced mass in units of M_sun/h
log_mass_min = %(logmassmin_def)s
log_mass_max = %(logmassmax_def)s
nmass = %(nmass_def)s
zmin = %(zmin_def)s
zmax = %(zmax_def)s
nz = %(nz_def)s
nk = %(nk_def)s
bnl =  %(beta_nl)s
p_mm = False
p_gg = False
p_gm = False
p_gI = False
p_mI = True
p_II = True
two_halo_only = False
hod_section_name = hod_blue
output_suffix = blue
poisson_type = scalar

[add_red_and_blue_power]
file = %(pipeline_path)s/add_and_upsample.py
f_red_file = %(pipeline_path)s/input_files/f_red.txt ; two columns: z f_red(z)
; options below are False, extrapolate, add_and_extrapolate
; If option add_and_extrapolate is selected, the f_red_file
; is needed to account for red/blue fraction correctly
; If only extrapolate is used, the red galaxy power spectrum is extrapolated
do_p_mm = False
do_p_gg = False
do_p_gm = False
do_p_gI = False
do_p_mI = add_and_extrapolate
do_p_II = add_and_extrapolate
hod_section_name_extrap = hod_red
hod_section_name_red = hod_red
hod_section_name_blue = hod_blue
input_suffix_extrap = red
input_suffix_red = red
input_suffix_blue = blue

[fits_nz]
file = %(CSL_PATH)s/number_density/load_nz_fits/load_nz_fits.py
nz_file = %(DATAFILE)s
data_sets = source_kids

[photoz_bias]
file = %(CSL_PATH)s/number_density/photoz_bias/photoz_bias.py
mode = additive
sample = nz_source_kids
bias_section = wl_photoz_errors
interpolation = cubic
output_deltaz_section_name = delta_z_out

[pk_to_cl]
file = %(CSL_PATH)s/structure/projection/project_2d.py
ell_min_logspaced = 100.0
ell_max_logspaced = 3000.0
n_ell_logspaced = 100
shear-shear = source_kids-source_kids
shear-intrinsic = source_kids-source_kids
intrinsic-intrinsic = source_kids-source_kids
verbose = F
get_kernel_peaks = F
sig_over_dchi = 20.
shear_kernel_dchi = 10.

[add_intrinsic]
file=%(CSL_PATH)s/shear/add_intrinsic/add_intrinsic.py
shear-shear=T
position-shear=F
perbin=F

[runtime]
sampler = test
verbosity = standard
root = ${COSMOSIS_SRC_DIR}

[test]
save_dir=output/%(RUN_NAME)s
fatal_errors = T

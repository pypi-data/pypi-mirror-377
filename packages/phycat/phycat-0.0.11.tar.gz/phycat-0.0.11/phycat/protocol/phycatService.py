"""
@file phycatService.py
@brief Generated code for phycat packet service
@author Generated by PolyPacket v1.1.36
@date 09/18/25
@hash 87B7E961
"""

from enum import IntEnum, IntFlag
from typing import Optional
from polypacket.polyservice import BasePacket , PolyPacket

# Service hash definition
PC_ICD_VERSION = 0x87B7E961

# Enums

class pcPacketType(IntEnum):
    """Packet types for pc protocol"""
    PING = 0  # This message requests an Ack from a remote device to test connectivity
    ACK = 1  # Acknowledges any packet that does not have an explicit response
    REQUEST = 2  # Request packet
    SYSTEM = 3  # System information packet
    PORT = 4  # Port packet
    STATUS = 5  # Status packet
    I2CCAPABILITIES = 6  # I2C capabilities
    I2CCONFIG = 7  # I2C configuration
    I2CDATA = 8  # I2C data packet
    UARTCAPABILITIES = 9  # UART capabilities
    UARTCONFIG = 10  # UART configuration
    UARTDATA = 11  # UART data packet
    TIMCAPABILITIES = 12  # Defines the capabilities of a timer interface
    TIMCONFIG = 13  # Message to configure a timer interface
    TIMCHANNELCONFIG = 14  # Message to configure a timer channel
    TIMDATA = 15  # Data message to or from a timer channel
    CANCAPABILITIES = 16  # Describes the complete CAN capabilities of a device interface
    CANCONFIG = 17  # Message to configure a CAN interface
    CANDATA = 18  # Message to send data over a CAN interface
    SPICAPABILITIES = 19  # Describes the complete SPI capabilities of a device interface
    SPICONFIG = 20  # Message to configure an SPI interface
    SPIDATA = 21  # Message to send data over an SPI interface
    GPIOCAPABILITIES = 22  # GPIO Port capabilities
    GPIOCONFIG = 23  # GPIO Port
    GPIODATA = 24  # GPIO Port data
    ADDDEVICE = 25  # Add an emulated device to an interface
    ADDMEMORYBANK = 26  # Add an emulated memory bank to an emulated device
    MEMREAD = 27  # Read memory from an  emulated devices memory bank
    MEMWRITE = 28  # Write memory to an emulated devices memory bank
    MEMDATA = 29  # Memory data packet




class handleType(IntEnum):
    """Enums for handleType field"""
    RESERVED = 0  # Reserved handle
    PORT = 1  # Port handle
    I2C = 2  # I2C handle
    SPI = 3  # SPI handle
    UART = 4  # UART handle
    CAN = 5  # CAN handle
    GPIO = 6  # GPIO handle
    TIM = 7  # TIM handle
    DISPLAY = 8  # Display handle

class busRole(IntEnum):
    """Enums for busRole field"""
    MASTER = 0  # Master node on a bus
    SLAVE = 1  # Slave node on a bus
    PASSIVE = 2  # Passive node (just listens and reports traffic)

class requestType(IntEnum):
    """Enums for requestType field"""
    SYSTEM = 0  # Request for system information
    PORT = 1  # Request for ports and port labels
    CAPABILITIES = 2  # Request for capabilities
    RESET = 3  # Request for reset

class status(IntEnum):
    """Enums for status field"""
    OK = 0  # Request was successful
    ERROR = 1  # Request failed
    INVALID_HANDLE = 2  # Invalid handle
    INVALID_INDEX = 3  # Invalid index
    INVALID_CONFIG = 4  # Invalid configuration
    INVALID_REQUEST = 5  # Invalid request
    MISSING_FIELD = 6  # Missing field in request

class i2cOperation(IntEnum):
    """Enums for i2cOperation field"""
    WRITE = 0  # Write operation
    READ = 1  # Read operation
    DATA = 2  # Data packet

class parity(IntEnum):
    """Enums for parity field"""
    NONE = 0  # No parity
    ODD = 1  # Odd parity
    EVEN = 2  # Even parity

class timMode(IntEnum):
    """Enums for timMode field"""
    TIM_MODE_CAPTURE = 0  # Timer capture mode
    TIM_MODE_OUTPUT = 1  # Timer output mode

class timChannelMode(IntEnum):
    """Enums for timChannelMode field"""
    TIM_CH_MODE_PWM_CAPTURE = 0  # PWM capture mode
    TIM_CH_MODE_PPM_CAPTURE = 1  # PPM capture mode
    TIM_CH_MODE_DSHOT_CAPTURE = 2  # DSHOT capture mode
    TIM_CH_MODE_PWM_OUTPUT = 3  # PWM output mode
    TIM_CH_MODE_PPM_OUTPUT = 4  # PPM output mode
    TIM_CH_MODE_DSHOT_OUTPUT = 5  # DSHOT output mode

class frameType(IntEnum):
    """Enums for frameType field"""
    STANDARD = 0  # Standard CAN frame
    EXTENDED = 1  # Extended CAN frame
    FD = 2  # CAN FD frame

class spiMode(IntEnum):
    """Enums for spiMode field"""
    SPI_MODE_0 = 0  # CPOL=0
    SPI_MODE_1 = 1  # CPOL=0
    SPI_MODE_2 = 2  # CPOL=1
    SPI_MODE_3 = 3  # CPOL=1


# Bits/Flags
class i2cFlags(IntFlag):
    """Flags for i2cFlags field"""
    MASTER = 1 << 0  # Interface supports I2C master mode
    SLAVE = 1 << 1  # Interface supports I2C slave mode
    PROMISCUOUS = 1 << 2  # Interface supports I2C promiscuous mode
    CLOCK_STRETCHING = 1 << 3  # Interface supports clock stretching
    PULL_UPS = 1 << 4  # Device has pull-up resistors that can be enabled

class i2cTransactionFlags(IntFlag):
    """Flags for i2cTransactionFlags field"""
    START = 1 << 0  # Send Start condition before operation
    STOP = 1 << 1  # Send Stop condition after operation
    ACK = 1 << 2  # Device acknowledged operation

class uartFlags(IntFlag):
    """Flags for uartFlags field"""
    SINGLE_WIRE = 1 << 0  # Interface supports single wire mode

class timFlags(IntFlag):
    """Flags for timFlags field"""
    SUPPORTS_OUTPUT = 1 << 0  # Interface supports PWM output mode
    SUPPORTS_CAPTURE = 1 << 1  # Interface supports input capture mode
    POLARITY_HIGH = 1 << 2  # Timer channel polarity is active high

class canFlags(IntFlag):
    """Flags for canFlags field"""
    SUPPORTS_STANDARD = 1 << 0  # Supports standard CAN frames
    SUPPORTS_EXTENDED = 1 << 1  # Supports extended CAN frames
    SUPPORTS_FD = 1 << 2  # Supports CAN FD frames
    SUPPORTS_BRS = 1 << 3  # Supports bit rate switching
    SUPPORTS_ESI = 1 << 4  # Supports error state indicator

class spiFlags(IntFlag):
    """Flags for spiFlags field"""
    SUPPORTS_MASTER = 1 << 0  # Interface supports SPI master mode
    SUPPORTS_SLAVE = 1 << 1  # Interface supports SPI slave mode
    SUPPORTS_PROMISCUOUS = 1 << 2  # Interface supports SPI promiscuous mode

class gpioCapFlags(IntFlag):
    """Flags for gpioCapFlags field"""
    INPUT = 1 << 0  # Port supports input
    OUTPUT = 1 << 1  # Port supports output
    INTERRUPT = 1 << 2  # Port supports interrupts
    PULL_UP = 1 << 3  # Port supports pull-up resistors
    PULL_DOWN = 1 << 4  # Port supports pull-down resistors
    OPEN_DRAIN = 1 << 5  # Port supports open-drain configuration

class memFlags(IntFlag):
    """Flags for memFlags field"""
    READ = 1 << 0  # Bank supports read operations
    WRITE = 1 << 1  # Bank supports write operations
    FIFO = 1 << 2  # Bank is a FIFO


# Packet Classes
class Ping(BasePacket):
    """
    This message requests an Ack from a remote device to test connectivity
    """
    def __init__(self):
        super().__init__("pc:Ping")
        self.icd: str | None = None

class Ack(BasePacket):
    """
    Acknowledges any packet that does not have an explicit response
    """
    def __init__(self):
        super().__init__("pc:Ack")
        self.icd: str | None = None

class Request(BasePacket):
    """
    Request packet
    """
    def __init__(self):
        super().__init__("pc:Request")
        self.handle: int | None = None
        self.requestType: int | None = None
        self.index: int | None = None

class System(BasePacket):
    """
    System information packet
    """
    def __init__(self):
        super().__init__("pc:System")
        self.label: str | None = None
        self.clockSpeed: int | None = None
        self.interfaceCount: int | None = None
        self.portCount: int | None = None

class Port(BasePacket):
    """
    Port packet
    """
    def __init__(self):
        super().__init__("pc:Port")
        self.handle: int | None = None
        self.label: str | None = None

class Status(BasePacket):
    """
    Status packet
    """
    def __init__(self):
        super().__init__("pc:Status")
        self.handle: int | None = None
        self.status: int | None = None

class I2cCapabilities(BasePacket):
    """
    I2C capabilities
    """
    def __init__(self):
        super().__init__("pc:I2cCapabilities")
        self.handle: int | None = None
        self.i2cFlags: int | None = None
        self.clockSpeed: int | None = None
        self.max_7bit_addresses: int | None = None
        self.max_10bit_addresses: int | None = None
        self.sda_pin: int | None = None
        self.scl_pin: int | None = None

class I2cConfig(BasePacket):
    """
    I2C configuration
    """
    def __init__(self):
        super().__init__("pc:I2cConfig")
        self.handle: int | None = None
        self.i2cFlags: int | None = None
        self.clockSpeed: int | None = None
        self.addresses_7bit: bytes | None = None
        self.addresses_10bit: list[int] | None = None

class I2cData(BasePacket):
    """
    I2C data packet
    """
    def __init__(self):
        super().__init__("pc:I2cData")
        self.handle: int | None = None
        self.i2cOperation: int | None = None
        self.i2cTransactionFlags: int | None = None
        self.address: int | None = None
        self.memAddr: int | None = None
        self.memAddrSize: int | None = None
        self.data: bytes | None = None
        self.size: int | None = None

class UartCapabilities(BasePacket):
    """
    UART capabilities
    """
    def __init__(self):
        super().__init__("pc:UartCapabilities")
        self.handle: int | None = None
        self.uartFlags: int | None = None
        self.max_baudrate: int | None = None
        self.baudrates: list[int] | None = None
        self.tx_pin: int | None = None
        self.rx_pin: int | None = None

class UartConfig(BasePacket):
    """
    UART configuration
    """
    def __init__(self):
        super().__init__("pc:UartConfig")
        self.handle: int | None = None
        self.uartFlags: int | None = None
        self.idleTime: int | None = None
        self.baudrate: int | None = None
        self.dataBits: int | None = None
        self.stopBits: int | None = None
        self.parity: int | None = None

class UartData(BasePacket):
    """
    UART data packet
    """
    def __init__(self):
        super().__init__("pc:UartData")
        self.handle: int | None = None
        self.data: bytes | None = None

class TimCapabilities(BasePacket):
    """
    Defines the capabilities of a timer interface
    """
    def __init__(self):
        super().__init__("pc:TimCapabilities")
        self.handle: int | None = None
        self.timFlags: int | None = None
        self.channels: list[int] | None = None

class TimConfig(BasePacket):
    """
    Message to configure a timer interface
    """
    def __init__(self):
        super().__init__("pc:TimConfig")
        self.handle: int | None = None
        self.timMode: int | None = None
        self.period: int | None = None

class TimChannelConfig(BasePacket):
    """
    Message to configure a timer channel
    """
    def __init__(self):
        super().__init__("pc:TimChannelConfig")
        self.handle: int | None = None
        self.channel: int | None = None
        self.timChannelMode: int | None = None
        self.period: int | None = None
        self.jitter_us: int | None = None

class TimData(BasePacket):
    """
    Data message to or from a timer channel
    """
    def __init__(self):
        super().__init__("pc:TimData")
        self.handle: int | None = None
        self.channel: int | None = None
        self.dshotData: int | None = None
        self.pulseData: int | None = None
        self.period: int | None = None

class CanCapabilities(BasePacket):
    """
    Describes the complete CAN capabilities of a device interface
    """
    def __init__(self):
        super().__init__("pc:CanCapabilities")
        self.handle: int | None = None
        self.canFlags: int | None = None
        self.max_baudrate: int | None = None
        self.baudrates: list[int] | None = None
        self.max_filters: int | None = None
        self.max_frame_size: int | None = None

class CanConfig(BasePacket):
    """
    Message to configure a CAN interface
    """
    def __init__(self):
        super().__init__("pc:CanConfig")
        self.handle: int | None = None
        self.baudrate: int | None = None
        self.filters: int | None = None

class CanData(BasePacket):
    """
    Message to send data over a CAN interface
    """
    def __init__(self):
        super().__init__("pc:CanData")
        self.handle: int | None = None
        self.id: int | None = None
        self.data: bytes | None = None
        self.frameType: int | None = None

class spiCapabilities(BasePacket):
    """
    Describes the complete SPI capabilities of a device interface
    """
    def __init__(self):
        super().__init__("pc:spiCapabilities")
        self.handle: int | None = None
        self.spiFlags: int | None = None
        self.max_speed: int | None = None
        self.mosi_pin: int | None = None
        self.miso_pin: int | None = None
        self.sclk_pin: int | None = None

class spiConfig(BasePacket):
    """
    Message to configure an SPI interface
    """
    def __init__(self):
        super().__init__("pc:spiConfig")
        self.handle: int | None = None
        self.busRole: int | None = None
        self.speed: int | None = None
        self.spiMode: int | None = None
        self.mosi_pin: int | None = None
        self.miso_pin: int | None = None
        self.sclk_pin: int | None = None
        self.cs_pin: int | None = None

class spiData(BasePacket):
    """
    Message to send data over an SPI interface
    """
    def __init__(self):
        super().__init__("pc:spiData")
        self.handle: int | None = None
        self.mosi_data: bytes | None = None
        self.miso_data: bytes | None = None
        self.token: int | None = None

class GpioCapabilities(BasePacket):
    """
    GPIO Port capabilities
    """
    def __init__(self):
        super().__init__("pc:GpioCapabilities")
        self.handle: int | None = None
        self.gpioCapFlags: int | None = None

class GpioConfig(BasePacket):
    """
    GPIO Port
    """
    def __init__(self):
        super().__init__("pc:GpioConfig")
        self.handle: int | None = None
        self.dir: int | None = None
        self.intFalling: int | None = None
        self.intRising: int | None = None
        self.pullUp: int | None = None
        self.pullDown: int | None = None
        self.openDrain: int | None = None

class GpioData(BasePacket):
    """
    GPIO Port data
    """
    def __init__(self):
        super().__init__("pc:GpioData")
        self.handle: int | None = None
        self.pinMask: int | None = None

class AddDevice(BasePacket):
    """
    Add an emulated device to an interface
    """
    def __init__(self):
        super().__init__("pc:AddDevice")
        self.handle: int | None = None
        self.devHandle: int | None = None
        self.address: int | None = None
        self.cs_pin: int | None = None
        self.memAddrSize: int | None = None

class AddMemoryBank(BasePacket):
    """
    Add an emulated memory bank to an emulated device
    """
    def __init__(self):
        super().__init__("pc:AddMemoryBank")
        self.handle: int | None = None
        self.devHandle: int | None = None
        self.memFlags: int | None = None
        self.memAddr: int | None = None
        self.size: int | None = None

class MemRead(BasePacket):
    """
    Read memory from an  emulated devices memory bank
    """
    def __init__(self):
        super().__init__("pc:MemRead")
        self.handle: int | None = None
        self.devHandle: int | None = None
        self.memAddr: int | None = None
        self.size: int | None = None

class MemWrite(BasePacket):
    """
    Write memory to an emulated devices memory bank
    """
    def __init__(self):
        super().__init__("pc:MemWrite")
        self.handle: int | None = None
        self.devHandle: int | None = None
        self.memAddr: int | None = None
        self.data: bytes | None = None

class MemData(BasePacket):
    """
    Memory data packet
    """
    def __init__(self):
        super().__init__("pc:MemData")
        self.handle: int | None = None
        self.devHandle: int | None = None
        self.memAddr: int | None = None
        self.data: bytes | None = None


# Service Functions
class pcService:
    """Service class for phycat protocol"""
    
    @staticmethod
    def init(interface_count: int, depth: int) -> None:
        """
        Initialize protocol service
        
        Args:
            interface_count: Number of interfaces to use
            depth: Spool size for each interface
        """
        # Implementation here
        pass
    
    @staticmethod
    def process() -> None:
        """Process data in buffers"""
        # Implementation here
        pass
    
    @staticmethod
    def feed(iface: int, data: bytes) -> None:
        """
        Feed bytes to service at given interface for processing
        
        Args:
            iface: Index of interface to send on
            data: Data to be processed
        """
        # Implementation here
        pass
   
def PolyPacketToPhycatPacket(ppPacket: PolyPacket):
    """ Converts a PolyPacket to a pc Packet """
    
    packetType = ppPacket.desc.name.lower()
    retPacket = None 
    if packetType == "ping":
        retPacket = Ping()
    elif packetType == "ack":
        retPacket = Ack()
    elif packetType == "request":
        retPacket = Request()
    elif packetType == "system":
        retPacket = System()
    elif packetType == "port":
        retPacket = Port()
    elif packetType == "status":
        retPacket = Status()
    elif packetType == "i2ccapabilities":
        retPacket = I2cCapabilities()
    elif packetType == "i2cconfig":
        retPacket = I2cConfig()
    elif packetType == "i2cdata":
        retPacket = I2cData()
    elif packetType == "uartcapabilities":
        retPacket = UartCapabilities()
    elif packetType == "uartconfig":
        retPacket = UartConfig()
    elif packetType == "uartdata":
        retPacket = UartData()
    elif packetType == "timcapabilities":
        retPacket = TimCapabilities()
    elif packetType == "timconfig":
        retPacket = TimConfig()
    elif packetType == "timchannelconfig":
        retPacket = TimChannelConfig()
    elif packetType == "timdata":
        retPacket = TimData()
    elif packetType == "cancapabilities":
        retPacket = CanCapabilities()
    elif packetType == "canconfig":
        retPacket = CanConfig()
    elif packetType == "candata":
        retPacket = CanData()
    elif packetType == "spicapabilities":
        retPacket = spiCapabilities()
    elif packetType == "spiconfig":
        retPacket = spiConfig()
    elif packetType == "spidata":
        retPacket = spiData()
    elif packetType == "gpiocapabilities":
        retPacket = GpioCapabilities()
    elif packetType == "gpioconfig":
        retPacket = GpioConfig()
    elif packetType == "gpiodata":
        retPacket = GpioData()
    elif packetType == "adddevice":
        retPacket = AddDevice()
    elif packetType == "addmemorybank":
        retPacket = AddMemoryBank()
    elif packetType == "memread":
        retPacket = MemRead()
    elif packetType == "memwrite":
        retPacket = MemWrite()
    elif packetType == "memdata":
        retPacket = MemData()
    else:   
        return None 

    for field in ppPacket.fields:
        if field.isPresent:
            val = field.get()
            if type(val) == tuple:
                val = list(val)
            setattr(retPacket, field.desc.name, val)
    
    return retPacket        
#!/usr/bin/python3
# Copyright (C) 2023-2025 SIPez LLC.  All rights reserved.

""" Generate doc/README.md for processor plugins """
import os
import typing
import inspect
import pydantic
import importlib
import vcon.pydantic_utils
import py_vcon_server.processor


PYDANTIC_FIELD_ATTRIBUTES = ["name", "type", "title", "description", "example", "examples", "default"]

PROCESSOR_TEMPLATE = """## {class_path}

 - **Name:** {class_name}{class_version}
 - **Summary:** {class_title}

{class_description}
 - **Initialization options Object:** {class_init_options_link}
 - **Processing options Object:** {class_options_link}

Methods:
{class_method_signatures}
"""


FIELD_TEMPLATE = """
##### {name} ({type})
{title}
{description}

example{example}

default: {default}
"""


OPTIONS_TEMPLATE = """## {class_path}

 - **Summary:** {class_title}

{class_description}

### Fields
{class_fields}
"""

TOC_ENTRY = "   * {}\n"

README_TEMPLATE = """
<sub><sup>This document is generated.  Do not edit directly.</sup></sub>
<sub><sup>Copyright (C) 2023-2025 SIPez LLC.  All rights reserved.</sup></sub>
<!--- generated by tests/test_processor_docs.py --->

# vCon Processor Framework and Plugins

## Table of Contents
 + [Introduction](#introduction)
 + [Processor Classes](#processors)
{processor_toc}
 + [Processor Initialization Options Classes](#processor-initialization-options-classes)
{init_options_toc}
 + [Processor Options Classes](#processor-options-classes)
{options_toc}

## Introduction

TBD

# Processor Classes

{processor_text}

# Processor Initialization Options Classes

{init_options_text}

# Processor Options Classes

{options_text}

"""

def sort_types(type_set: typing.Set[typing.Type], head: typing.Type) -> typing.List[typing.Type]:
  sorted_list = sorted(type_set.copy(), key = lambda cls: cls.__name__)
  sorted_list.remove(head)
  sorted_list.insert(0, head)

  return(sorted_list)


def make_section_link(target_title: str, label: str) -> str:
  anchor = "#" + target_title.lower().replace(".", "").replace(" ", "-")
  link = "[{}]({})".format(label, anchor)

  return(link)

def get_annotation_type_module(
    processor_type,
    method_name,
    arg_name,
    arg_annotation,
    expected_arg_base_class
  ):
  if(not hasattr(arg_annotation, "__module__")):
    module_name = processor_type.__module__
    module = globals().get(module_name, None)
    if(module is None):
      # try to load the module
      module = importlib.import_module(module_name)
    processor_type = getattr(module, processor_type)
    # assert(issubclass(option_arg_type, vcon.filter_plugins.FilterPluginInitOptions))
    #arg_type = option_arg_type
  else:
    module_name = arg_annotation.__module__

  # Sometimes arg_annotation is a string containing the name of the type
  if(not hasattr(arg_annotation, "__name__")):
    arg_type = str(arg_annotation)
  # Sometimes arg_annotation is the type
  # Don't ask me why.
  else:
    arg_type = arg_annotation.__name__

  if(expected_arg_base_class and
     not issubclass(arg_annotation, expected_arg_base_class)):
    raise Exception("argument: {} in method: {} of FilterPlugin: {} in module: {} does not derived from: {}".format(
      arg_name,
      method_name,
      processor_type.__name__,
      processor_type.__module__,
      expected_arg_base_class.__name__
      ))

  return(arg_type, module_name)


def collect_processor_data(
    processor_name: str,
    processor_type: typing.Type,
    processor_init_options_type: typing.Type,
    processor_options_type: typing.Type,
    title: str,
    version: str,
    description: str,
    readme_data: typing.Dict[str, str],
  ) -> typing.Dict[str, str]:
  class_data = {}
  class_data["class_name"] = processor_name
  class_data["class_path"] = processor_type.__module__ + "." + processor_type.__name__
  class_data["class_link"] = make_section_link(class_data["class_path"], class_data["class_path"])
  readme_data["processor_toc"] += TOC_ENTRY.format(class_data["class_link"])
  class_data["class_module"] = str(processor_type.__module__)
  class_data["class_title"] = title
  class_data["class_version"] = "\n - **Version:** {}".format(version)
  class_data["class_description"] = description
  class_data["class_options_path"] = class_data["class_module"] + "." + processor_options_type.__name__
  class_data["class_options_link"] = make_section_link(class_data["class_options_path"], class_data["class_options_path"])
  readme_data["options_toc"] += TOC_ENTRY.format(
    class_data["class_options_link"])
  class_data["class_init_options_path"] = class_data["class_module"] + "." + processor_init_options_type.__name__
  class_data["class_init_options_link"] = make_section_link(
    class_data["class_init_options_path"],
    class_data["class_init_options_path"])
  readme_data["init_options_toc"] += TOC_ENTRY.format(
    class_data["class_init_options_link"])
  # TODO collect method interfaces (__init__, process, __del__)
  method_names = ["__init__", "process"]
  method_signatures = ""
  for method_name in method_names:
    if(method_name == "__init__"):
      expected_arg_base_class = py_vcon_server.processor.VconProcessorInitOptions
    elif(method_name == "process"):
      expected_arg_base_class = py_vcon_server.processor.VconProcessorOptions
    method = getattr(processor_type, method_name)
    method_sig = inspect.signature(method)
    print("{} init sig: {}".format(processor_name, method_sig))
    args_doc = ""
    for index, arg_name in enumerate(list(method_sig.parameters)):
      if((processor_type == py_vcon_server.processor.VconProcessor
           and index == 4) or
           (processor_type != py_vcon_server.processor.VconProcessor and
           index == 2)
         ):
        check_arg_type = expected_arg_base_class
      else:
        check_arg_type = None
      arg_annotation = method_sig.parameters[arg_name].annotation
      arg_type_name, module_name = get_annotation_type_module(
          processor_type,
          method_name,
          arg_name,
          arg_annotation,
          check_arg_type
        )
      arg_doc = ""
      if(len(args_doc) > 0):
        arg_doc += ", "
      arg_doc += arg_name
      print("arg type: {}".format(arg_type_name))
      if(len(arg_type_name) > 0 and
         arg_type_name != "_empty"):
        arg_doc += ": {}".format(arg_type_name)
      args_doc += arg_doc

    method_sig_doc = "**{}**({})".format(
        method_name,
        args_doc
      )
    method_signatures += "\n\n" +  method_sig_doc

  class_data["class_method_signatures"] = method_signatures

  return(class_data)


def collect_options_data(
    options_type: typing.Type,
    processor_type: typing.Type
  ) -> typing.Dict[str, str]:

  assert(issubclass(options_type, pydantic.BaseModel))
  print("options {} dir: {}".format(options_type.__name__, dir(options_type)))
  schema = vcon.pydantic_utils.get_model_schema(options_type)
  class_data = {}
  # TODO fix module name (always "abc")
  class_data["class_path"] = processor_type.__module__ + "." + options_type.__name__
  class_data["class_title"] = schema.get("title", "")
  class_data["class_description"] = schema.get("description", None)
  if(class_data["class_description"] is None):
    print("ERROR: class model: {} does not have class documentation".format(class_data["class_path"]))
  assert(class_data["class_description"] is not None)
  class_data["class_fields"] = "TBD"

  field_data_text = ""
  for name, field in vcon.pydantic_utils.get_field_items(options_type):
    assert(isinstance(field, vcon.pydantic_utils.FieldInfo))
    field_data: typing.Dict[str, str] = {}
    for attribute in PYDANTIC_FIELD_ATTRIBUTES:
      if(hasattr(field, attribute)):
        value = getattr(field, attribute)
      elif(hasattr(field, "field_info") and
        hasattr(field.field_info, attribute)):
        value = getattr(field.field_info, attribute)
      elif(attribute == "name"):
        value = name
      else:
        value = None
      if(value is None and
        hasattr(field, "field_info")):
        value = field.field_info.extra.get(attribute, None)
      #if(value is not None):
      field_data[attribute] = value

    if(not hasattr(field.annotation, "__name__")):
      field_type = str(field.annotation)
      print("Field: {} in class: {} module: {} does not have a type hint set. annotation type: {} {}".format(
        field_data["name"],
        options_type.__name__,
        options_type.__module__,
        type(field.annotation),
        field.annotation
        ))
    else:
      field_type = field.annotation.__name__
    field_data["type"] = field_type
    if(field_type == "str" and
      field_data.get("default", None) is not None):
      # put quotes around default if this is type str
      field_data["default"] = '"{}"'.format(field_data["default"])

    # Clean up pydanticism on default
    if(field_data["default"]  == "\"PydanticUndefined\""):
      field_data["default"]  = "None"

    # Tweak examples
    if("examples" in field_data and
      field_data["examples"] is not None and
      field_data["examples"] != ""
      ):
      field_data["example"] = "s: " + str(field_data["examples"])
    elif("example" in field_data and
      field_data["example"] is not None
      ):
      field_data["example"] = ": " + "{}".format(field_data["example"])
    else:
      field_data["example"] = ":"

    field_data_text += FIELD_TEMPLATE.format(**field_data)

  if(len(field_data_text) == 0):
    field_data_text = "none"

  class_data["class_fields"] = field_data_text

  return(class_data)


def build_processors_doc() -> str:
  readme_text = ""
  readme_data: typing.Dict[str, str] = {}
  readme_data["processor_toc"] = ""
  readme_data["init_options_toc"] = ""
  readme_data["options_toc"] = ""
  processors = set()
  processors.add(py_vcon_server.processor.VconProcessor)
  init_options = set()
  init_options.add(py_vcon_server.processor.VconProcessorInitOptions)
  options = set()
  options.add(py_vcon_server.processor.VconProcessorOptions)

  processor_class_data: typing.Dict[typing.Type, typing.Dict[str, str]] = {}
  processor_type = py_vcon_server.processor.VconProcessor
  processor_name = "VconProcessor"
  processor_init_options_type = py_vcon_server.processor.VconProcessorInitOptions
  processor_options_type = py_vcon_server.processor.VconProcessorOptions
  title = "Abstract VconProcessor class"
  version = ""
  description = "{}".format(processor_type.__doc__)
  class_data = collect_processor_data(
      processor_name,
      processor_type,
      processor_init_options_type,
      processor_options_type,
      title,
      version,
      description,
      readme_data
    )
  processor_class_data[processor_type] = class_data

  processor_names = py_vcon_server.processor.VconProcessorRegistry.get_processor_names()
  for processor_name in processor_names:
    processor_inst = py_vcon_server.processor.VconProcessorRegistry.get_processor_instance(
      processor_name)
    processor_type = type(processor_inst)
    processors.add(processor_type)
    processor_init_options_type = type(processor_inst.init_options)
    processor_options_type = processor_inst.processor_options_class()
    title = processor_inst.title()
    version = processor_inst.version()
    description = processor_inst.description()
    class_data = collect_processor_data(
        processor_name,
        processor_type,
        processor_init_options_type,
        processor_options_type,
        title,
        version,
        description,
        readme_data
      )
    print("adding class defs for: {}".format(processor_name))
    processor_class_data[processor_type] = class_data
    options.add(processor_options_type)
    #init_sig = inspect.signature(processor_inst.__init__)
    #print("{} init sig: {}".format(processor_name, init_sig))
    #init_options_arg_name = list(init_sig.parameters)[0]
    #init_options_type = init_sig.parameters[init_options_arg_name].annotation
    #print("{}.__init__({}: {}.{})".format(
    #    processor_name,
    #    init_options_arg_name,
    #    init_options_type.__module__,
    #    init_options_type.__name__
    #  ))
    # TODO: get init_options type from introspection of the plugin __init__ method
    init_options.add(processor_init_options_type)
    print("{} init: {}".format(processor_name, type(processor_inst.init_options)))

  sorted_processors = sort_types(processors, py_vcon_server.processor.VconProcessor)
  sorted_options = sort_types(options, py_vcon_server.processor.VconProcessorOptions)
  sorted_init_options = sort_types(init_options, py_vcon_server.processor.VconProcessorInitOptions)
  #readme_text = "{}".format(sorted_processors)

  readme_data["processor_text"] = ""
  for processor in sorted_processors:
    class_data = processor_class_data[processor]
    proc_class_doc = PROCESSOR_TEMPLATE.format(**class_data)
    readme_data["processor_text"] += proc_class_doc + "\n\n"

  readme_data["init_options_text"] = ""
  for options_index, init in enumerate(sorted_init_options):
    init_data = collect_options_data(init, sorted_processors[options_index])
    init_text = OPTIONS_TEMPLATE.format(**init_data)
    readme_data["init_options_text"] += init_text + "\n"

  readme_data["options_text"] = ""
  for options_index, opt in enumerate(sorted_options):
    opt_data = collect_options_data(opt, sorted_processors[options_index])
    opt_text = OPTIONS_TEMPLATE.format(**opt_data)
    readme_data["options_text"] += opt_text + "\n"

  #print("{}".format(readme_data))
  readme_text = README_TEMPLATE.format(**readme_data)

  return(readme_text)

def main():
  processor_readme_text = build_processors_doc()

  if(not os.path.isdir("py_vcon_server/processor")):
    os.makedirs("py_vcon_server/processor")
  with open("py_vcon_server/processor/README.md", "w") as readme_file:
    readme_file.write(processor_readme_text)


def test_processor_readme_doc():
  main()

if(__name__ == '__main__'):
  main()


#! python
# -*- coding: utf-8 -*-
#
# This file is part of the PyUtilScripts project.
# Copyright (c) 2020-2025 zero <zero.kwok@foxmail.com>
#
# For the full copyright and license information, please view the LICENSE
# file that was distributed with this source code.
#

import os
import re
import sys
import stat
import math
import shlex
import click
import shutil
import difflib
import filecmp
import argparse
import datetime
import traceback
from   typing import Tuple, List
from   pathlib import Path
from   natsort import natsorted
from   datetime import datetime
from   termcolor import cprint

from . import utils

CopyModes = ["update", "overwrite", "rename", "u", "o", "r"]

ListFileHead = """# File list generated by fcopy on {Date}
# One file per line, relative to source directory
# From  : {Source}
# Count : {Count}
"""

ActionFileHead = """# Action plan for file copying (edit this file to change actions)
#
# Actions:
# c - Copy, when target doesn't exist
# u - Update, when target exists with mismatched metadata but source is newer
# o - Overwrite, when target exists, unconditionally copy and overwrite (--mode overwrite)
# r - Rename, when target exists, copy with incremented filename (--mode rename)
# m - Make directory, when target is a directory and doesn't exist
# i - Ignore, when target exists with mismatched metadata but deep comparison shows no difference or source is older
# s - Skip, when target exists and no differences found in shallow or deep comparison
#
# Example:
# c file1.txt                   Copy
# r file3.txt -> file(3).txt    Copy and Rename to file(3).txt
# o file2.txt                   Overwrite
# s file2.txt                   Skipped because the files are the same
#
# Source Directory: {Source}
# Target Directory: {Target}
# Action Count    : {Count}
"""

ActionNames = {'c': 'Copying', 'u': 'Updating', 'o': 'Replacing',
               'r': 'Renaming', 'm': 'MakingDir', 'i': 'Ignored', 's': 'Skipped'}

def output(level, *args, **kwargs):
    """
    Output messages with specified level.
    0 - error (red, stderr)
    1 - warning (yellow, stderr) - can be treated as error in strict mode
    2 - normal output (stdout)
    3 - verbose (stdout, only when verbose enabled)
    """

    # Extract control parameters
    verbose_mode = kwargs.pop('verbose', False)
    strict_mode = kwargs.pop('strict', False)

    # Handle verbose filtering
    if level > 2 and not verbose_mode:
        return

    # Handle strict mode: upgrade warnings to errors
    if level == 1 and strict_mode:
        level = 0

    # Add appropriate prefixes
    if len(args) == 0:
        args = ('',)

    if level == 0:
        args = ('Error: ' + args[0], *args[1:],)
    elif level == 1:
        args = ('Warning: ' + args[0], *args[1:],)

    # Set output destination and color
    if level == 0:
        kwargs.setdefault('file', sys.stderr)
        kwargs.setdefault('color', 'red')
    elif level == 1:
        kwargs.setdefault('file', sys.stderr)
        kwargs.setdefault('color', 'yellow')
    elif level == 2:
        kwargs.setdefault('file', sys.stdout)
    elif level == 3:
        kwargs.setdefault('file', sys.stdout)
        kwargs.setdefault('color', 'blue')  # Optional: different color for verbose

    # Output the message
    cprint(*args, **kwargs)


def read_file_list(filename, comment='#', keep_comments=False):
    """Read the list of files to copy from the manifest file."""
    if filename is None:
        return None
    with open(filename, 'r') as f:
        lines = [line.strip() for line in f.readlines()]

    # Filter out comments and empty lines
    files = []
    for line in lines:
        if not keep_comments:
            if line.startswith(comment) or not line:
                continue
        files.append(line)
    return files


def filter_match(file, patterns):
    if not patterns:
        return False
    return any(p.match(file) for p in patterns)


def read_file_filter(filename, comment='#'):
    patterns = []
    try:
        for line in read_file_list(filename, comment, False) or []:
            patterns.append(re.compile(line))
    except FileNotFoundError:
        pass # ignore missing file
    return patterns


def make_file_list(source, filters=[], verbose=False):
    def handle_files(files, root, names):
        for n in names:
            filename = os.path.join(root, n)
            filename = os.path.relpath(filename, start=source)
            if filter_match(filename, filters):
                output(3, f"Filtered: {filename}", verbose=verbose)
                continue
            files.append(filename)

    dirs = []
    files = []
    for root, _dirs, _files in os.walk(source):
        handle_files(dirs, root, _dirs)
        handle_files(files, root, _files)

    date = datetime.now().isoformat(timespec='seconds')
    info = f'{len(dirs)} directories, {len(files)} files'
    head = ListFileHead.format(Date=date, Source=source, Count=info).splitlines()
    return head + [''] + natsorted(dirs + files)


def update_file_list(args):
    """Update the file list with the current contents of the source directory."""
    new = make_file_list(args.source, args.filter_patterns, args.verbose)
    old = []
    if os.path.exists(args.list):
        with open(args.list, 'r') as f:
            old = [line.strip() for line in f.readlines()]

    # 生成 unified diff
    diff = difflib.unified_diff(
        old,
        new,
        fromfile=args.list + ' (old)',
        tofile=args.list + ' (new)',
        lineterm=''
    )

    # 对 diff 行进行彩色渲染
    print('')
    for line in diff:
        if line.startswith('+'):
            cprint(line, 'green')  # 新增行：绿色
        elif line.startswith('-'):
            cprint(line, 'red')    # 删除行：红色
        elif line.startswith('@@'):
            cprint(line, 'cyan')   # 差异位置标记：青色
        else:
            cprint(line)

    # Ask for confirmation
    cprint(f"\nUpdate {args.list} with these changes? [y/N]", end=" ")
    confirm = input().strip().lower()
    if confirm != 'y':
        output(0, 'User Cancelled')
        return 1

    with open(args.list, 'w') as f:
        f.write('\n'.join(new))
    return 0


def file_cmp(file1, file2, stat1, stat2) -> Tuple[bool, int]:
    """Compare two files and return a tuple of (is_same, meta_cmp)."""
    # 浅比较, 比较文件大小和修改时间
    if stat1.st_size == stat2.st_size and stat1.st_mtime == stat2.st_mtime:
        return True, 0

    # 根据修改时间, 对比谁比较新
    meta_cmp = 1 if stat1.st_mtime >= stat2.st_mtime else -1

    # 深比较
    def _do_cmp(f1, f2):
        bufsize = 8*1024
        with open(f1, 'rb') as fp1, open(f2, 'rb') as fp2:
            while True:
                b1 = fp1.read(bufsize)
                b2 = fp2.read(bufsize)
                if b1 != b2:
                    return False
                if not b1:
                    return True
    if stat1.st_size == stat2.st_size and _do_cmp(file1, file2):
        return True, meta_cmp
    return False, meta_cmp


def increment_filename(directory, filename, rename_list):
    """
    在指定目录中为给定文件名生成不冲突的新文件名（仅文件名部分，不含路径）。
    支持多扩展名（如 .tar.gz）及已有的 (1)、(2) 递增模式。
    """
    directory  = Path(directory)
    filename   = Path(filename)
    components = filename.parent
    filename   = filename.name
    
    stem, *suffixes = filename.split('.')
    suffix = '.' + '.'.join(suffixes) if suffixes else ''

    # 若 stem 形如 "file(1)"，则提取基础名与编号
    match = re.match(r'^(.*?)(\((\d+)\))?$', stem )
    if match:
        stem = match.group(1)
        number = int(match.group(3)) if match.group(3) else 0
    else:
        number = 0

    # 除了判断文件系统中是否存在之外, 还要判断计划中产生的文件是否存在
    def exists(d, c, f):
        if (d / c / f).exists():
            return True
        if rename_list:
            if (c / f) in rename_list:
                return True
        return False

    # 初始候选
    candidate = filename
    while exists(directory, components, candidate):
        number += 1
        candidate = f"{stem}({number}){suffix}"

    return components / candidate 


class Action:
    """Action类用于描述操作行为"""
    def __init__(self, action: str, src: str, dst: str = '', common: str = None):
        self.action = action
        self.src = src
        self.dst = dst
        self.common = common

    def __iter__(self):
        return iter((self.action, self.src, self.dst))

    def natsorted(actions):
        priority = {c: i for i,c in enumerate(['m', 'c', 'u', 'o', 'r', 'i', 's'])}
        return natsorted(actions, key=lambda a: (priority[a.action], a.src, a.dst))


def make_actions(args):
    items: List[Action] = []
    rename_list: List[str] = []

    for file in args.manifest:
        source = os.path.normpath(os.path.join(args.source, file))
        target = os.path.normpath(os.path.join(args.target, file))

        # 过滤掉名单中的文件
        if filter_match(source, args.filter_patterns):
            output(2, f"Filtered: {file}", verbose=args.verbose)
            continue

        try:
            stat1 = os.stat(source)
        except:
            # 源文件不存在则发出警告, 不视为错误
            output(1, f"SourceFileNotFound: {file}", strict=args.strict)
            continue

        try:
            stat2 = os.stat(target)
        except FileNotFoundError:
            if stat.S_ISDIR(stat1.st_mode):
                items.append(Action('m', file))
            else:
                items.append(Action('c', file))
            continue

        if stat.S_ISDIR(stat1.st_mode): # 目录直接跳过, 因为拷贝文件会尝试创建目录
            continue

        if args.mode in ('r', 'rename'):
            file2 = increment_filename(args.target, file, rename_list)
            items.append(Action('c', file, str(file2)))
            rename_list.append(file2)
            continue

        elif args.mode in ('o', 'overwrite'):
            items.append(Action('o', file))
            continue

        # update mode
        is_same, meta_cmp = file_cmp(source, target, stat1, stat2)
        def common():
            if args.verbose > 0:
                return (
                    [
                        f"src: {utils.format_ftime(stat1.st_mtime)}, {utils.format_bytes(stat1.st_size)}",
                        f"dst: {utils.format_ftime(stat2.st_mtime)}, {utils.format_bytes(stat2.st_size)}",
                    ]
                    if meta_cmp != 0
                    else None
                )
            else:
                return {0: None, 1: ["src newer",], -1: ["dst newer",]}[meta_cmp]

        if is_same:
            items.append(Action('s' if meta_cmp == 0 else 'i', file, common=common()))
        else:
            items.append(Action('u' if meta_cmp >= 1 else 'i', file, common=common()))

    return Action.natsorted(items)


def parse_actions(lines, comment='#'):
    files = []
    for row, line in enumerate(lines):
        line = line.strip()
        if not line or line.startswith(comment):
            continue

        # Handle action-prefixed lines (for edit mode)
        if ' ' not in line:
            raise ValueError(f"Invalid line: {row}: {line}")
        fields = shlex.split(line, posix=os.name != 'nt')

        # remove comments fields
        result = []
        for f in fields:
            if f.startswith(comment):
                break
            result.append(f)
        fields = result

        if len(fields) == 2: 
            action, file1, file2 = fields + ['']
        elif len(fields) == 4 and '->' in fields:
            action, file1, _, file2 = fields
        else:
            raise ValueError(f"Invalid line: {row}: {line}, parse as: {fields}")
        files.append(Action(action, file1.strip(' \'"'), file2.strip(' \'"')))

    return files


def read_file_actions(filename, comment='#'):
    return parse_actions(read_file_list(filename, comment, True), comment)


def line_append_space(line, align=16, minLength=32):
    l = len(line)
    n = math.ceil(l / align) * align
    n = max(n, minLength)
    return line + max(n - l, 1) * ' '


def join_actions(actions:list[Action], head:str, args):
    lines = []
    current = ''
    counter = {}
    for item in actions:
        # 统计
        if current != item.action:
            current = item.action
            counter[item.action] = 0
            lines.append('')
            lines.append(f"# {ActionNames[item.action]} Files: {{{item.action}}}")
        counter[item.action] += 1

        line = f'{item.action} "{item.src}"'
        if item.dst:
            line += f' -> "{item.dst}"'
        if item.common and args.verbose <= 0:
            line = line_append_space(line) + f'# {",".join(item.common)}'
        lines.append(line)

        if args.verbose > 0: # 注释以独立的行存在
            for c in item.common or []:
                lines.append(f'   # {c}')
    info = str(counter).replace("'", "")
    head = head.format(Source=args.source, Target=args.target, Count=info)
    body = "\n".join(lines)
    body = body.format(**counter)

    return head.rstrip() + "\n" + body + "\n"


def print_actions(actions:list, head:str, args):
    output(2)
    output(2, f"The following actions will be performed:", "yellow")

    lines = join_actions(actions, head, args)
    for line in lines.splitlines():
        if not line:
            output(2)
            continue

        a = line.strip()[0]
        c = {"#": "dark_grey", "s": "yellow", "o": "green",
             "c": "green", "m": "cyan", " ": "white"}
        f = a if a in c else " "
        output(2, line, c[f])
    output(2)


def get_available_editor(defaults=("micro", "nano", "vim", "vi", "notepad")):
    """检查哪个编辑器可用，返回第一个可用的，否则返回 None"""
    if "EDITOR" in os.environ:
        defaults.insert(0, os.environ["EDITOR"])
        cprint(f'Preferred editor detected: {defaults[0]}', 'yellow')
    for editor in defaults:
        if shutil.which(editor):  # 检查是否在 PATH 里
            return editor
    return None


def edit_actions(actions:list, head:str, args) -> list:
    """
    使用 click.edit() 启动编辑器让用户编辑行动计划。
    返回: None 用户取消编辑或没保存
    """
    content = join_actions(actions, head, args)

    # 打开编辑器让用户编辑内容
    edited = click.edit(content, extension=".actions-todo", editor=get_available_editor())
    if edited is None:
        output(0, "User canceled or didn't save, aborted.")
        raise SystemExit()

    # 解析用户编辑后的结果
    return parse_actions(edited.splitlines(), '#')


def copy_files(args):
    """Copy files from source directory to target directory with specified manifest"""
    args.manifest = read_file_list(args.list)
    if not args.manifest:
        output(0, 'list file is empty or invalid.')
        return 1

    actions = make_actions(args)
    if not actions:
        output(0, "Error: No actions to perform.")
        return 1

    if args.interactive:
        actions = edit_actions(actions, ActionFileHead, args)
    elif args.dry_run or args.verbose > 1:
        print_actions(actions, ActionFileHead, args)

    copied, skipped = 0, 0
    for action, file1, file2 in actions:
        file2 = file2 or file1
        if action in ('s', 'i'):
            skipped += 1
            continue

        source = os.path.normpath(os.path.join(args.source, file1))
        target = os.path.normpath(os.path.join(args.target, file2))

        if action in ('c', 'u', 'o', 'r'):
            if os.path.isdir(source):
                continue

            prefix = ActionNames[action]
            if args.dry_run:
                output(2, f"Dry run: {prefix}: {file1} -> {file2}", "cyan")
            elif args.verbose > 0:
                output(2, f"{prefix} {file1} -> {file2}", 'green')
            else:
                output(2, f"{prefix} {file1}", 'green')

            if not args.dry_run:
                try:
                    os.makedirs(os.path.dirname(target), exist_ok=True)
                    shutil.copy2(source, target)
                except OSError as e:
                    output(0, f"{prefix} {source} to {target}: {e}")
                    if args.strict:
                        return 1
            copied += 1

        elif action == 'm':
            try:
                os.makedirs(target, exist_ok=True)
            except OSError as e:
                output(0, f"{prefix} {source} to {target}: {e}")
                if args.strict:
                    return 1
            copied += 1

    output(2, f"Done. {copied} files copied, {skipped} skipped.")
    return 0


def main():
    try:
        parser = argparse.ArgumentParser(
            description="Copy files from source directory to target directory with flexible copy modes.", 
            formatter_class=argparse.ArgumentDefaultsHelpFormatter)
        parser = argparse.ArgumentParser(description='Copy files from source directory to target directory.')
        parser.add_argument('-l', '--list', default='fcopy.list', help='File containing the list of files to copy.')
        parser.add_argument("-s", "--source", required=True, help="source directory containing files to copy")
        parser.add_argument("-t", "--target", help="target directory where files will be copied")
        parser.add_argument("-m", "--mode", default="update", choices=CopyModes, help="copy mode: u|update, o|overwrite, r|rename")
        parser.add_argument("-i", "--interactive", action="store_true", help="Let the user edit the list of action plans to copy")
        parser.add_argument("-v", "--verbose", action="count", default=0, help="increase verbosity level (use -vv for more detail)")
        parser.add_argument('--filter', help='file containing blacklist regex patterns, one per line.')
        parser.add_argument("--update-list", action="store_true", help="update the --list file with current --source contents (with confirmation)")
        parser.add_argument("--dry-run", action="store_true", help="simulate operations without actually copying files")
        parser.add_argument("--strict", action="store_true", help="treat warnings as errors (exit with non-zero code on warnings)")
        parser.add_argument('--debug', action='store_true', default=False, help=argparse.SUPPRESS)

        try:
            args = parser.parse_args()
        except SystemExit:
            print('\n'.join(parser.format_help().splitlines()[1:]))
            raise

        # argparse 默认会保留字符串中的引号
        for key in args.__dict__:
            if type(args.__dict__[key]) == str:
                args.__dict__[key] = args.__dict__[key].strip(' \'"')

        if args.debug:
            args.verbose = 2
            input('Wait for debugging and press Enter to continue...')

        if not args.list or not args.source:
            output(0, "Please provide the required arguments.")
            parser.print_help()
            return 1

        args.mode = args.mode.lower()
        args.source = os.path.normpath(os.path.abspath(args.source))
        if not os.path.isdir(args.source):
            output(0, f"Source directory '{args.source}' does not exist")
            return 1

        # Read the filter file
        args.filter_patterns = read_file_filter(args.filter)
        if not args.filter_patterns and "_specified" in vars(args) and "filter" in args._specified:
            output(1, f"No valid patterns found in filter file '{args.filter}'.", strict=args.strict)

        # Check if running in the terminal, because editor is only available in terminal
        if args.interactive and not sys.stdout.isatty():
            output(1, "Not running in the terminal (may be a redirect or pipe)", strict=args.strict)

        if args.update_list:
            return update_file_list(args)
        else:
            if args.target is None:
                output(0, "Please provide the target directory.")
                return 1
            args.target = os.path.normpath(os.path.abspath(args.target))
            return copy_files(args)

    except KeyboardInterrupt:
        output(2)
        output(0, "Keyboard Interrupt", end='')
        return 1

if __name__ == "__main__":
    sys.exit(main())

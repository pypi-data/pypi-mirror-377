# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _pylauncher
else:
    import _pylauncher

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pylauncher.delete_SwigPyIterator

    def value(self) -> "PyObject *":
        return _pylauncher.SwigPyIterator_value(self)

    def incr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _pylauncher.SwigPyIterator_incr(self, n)

    def decr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _pylauncher.SwigPyIterator_decr(self, n)

    def distance(self, x: "SwigPyIterator") -> "ptrdiff_t":
        return _pylauncher.SwigPyIterator_distance(self, x)

    def equal(self, x: "SwigPyIterator") -> "bool":
        return _pylauncher.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _pylauncher.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _pylauncher.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _pylauncher.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _pylauncher.SwigPyIterator_previous(self)

    def advance(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _pylauncher.SwigPyIterator_advance(self, n)

    def __eq__(self, x: "SwigPyIterator") -> "bool":
        return _pylauncher.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: "SwigPyIterator") -> "bool":
        return _pylauncher.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _pylauncher.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _pylauncher.SwigPyIterator___isub__(self, n)

    def __add__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _pylauncher.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _pylauncher.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _pylauncher:
_pylauncher.SwigPyIterator_swigregister(SwigPyIterator)

class list_int(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _pylauncher.list_int_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _pylauncher.list_int___nonzero__(self)

    def __bool__(self) -> "bool":
        return _pylauncher.list_int___bool__(self)

    def __len__(self) -> "std::list< int >::size_type":
        return _pylauncher.list_int___len__(self)

    def __getslice__(self, i: "std::list< int >::difference_type", j: "std::list< int >::difference_type") -> "std::list< int,std::allocator< int > > *":
        return _pylauncher.list_int___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _pylauncher.list_int___setslice__(self, *args)

    def __delslice__(self, i: "std::list< int >::difference_type", j: "std::list< int >::difference_type") -> "void":
        return _pylauncher.list_int___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _pylauncher.list_int___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::list< int >::value_type const &":
        return _pylauncher.list_int___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _pylauncher.list_int___setitem__(self, *args)

    def pop(self) -> "std::list< int >::value_type":
        return _pylauncher.list_int_pop(self)

    def append(self, x: "std::list< int >::value_type const &") -> "void":
        return _pylauncher.list_int_append(self, x)

    def empty(self) -> "bool":
        return _pylauncher.list_int_empty(self)

    def size(self) -> "std::list< int >::size_type":
        return _pylauncher.list_int_size(self)

    def swap(self, v: "list_int") -> "void":
        return _pylauncher.list_int_swap(self, v)

    def begin(self) -> "std::list< int >::iterator":
        return _pylauncher.list_int_begin(self)

    def end(self) -> "std::list< int >::iterator":
        return _pylauncher.list_int_end(self)

    def rbegin(self) -> "std::list< int >::reverse_iterator":
        return _pylauncher.list_int_rbegin(self)

    def rend(self) -> "std::list< int >::reverse_iterator":
        return _pylauncher.list_int_rend(self)

    def clear(self) -> "void":
        return _pylauncher.list_int_clear(self)

    def get_allocator(self) -> "std::list< int >::allocator_type":
        return _pylauncher.list_int_get_allocator(self)

    def pop_back(self) -> "void":
        return _pylauncher.list_int_pop_back(self)

    def erase(self, *args) -> "std::list< int >::iterator":
        return _pylauncher.list_int_erase(self, *args)

    def __init__(self, *args):
        _pylauncher.list_int_swiginit(self, _pylauncher.new_list_int(*args))

    def push_back(self, x: "std::list< int >::value_type const &") -> "void":
        return _pylauncher.list_int_push_back(self, x)

    def front(self) -> "std::list< int >::value_type const &":
        return _pylauncher.list_int_front(self)

    def back(self) -> "std::list< int >::value_type const &":
        return _pylauncher.list_int_back(self)

    def assign(self, n: "std::list< int >::size_type", x: "std::list< int >::value_type const &") -> "void":
        return _pylauncher.list_int_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _pylauncher.list_int_resize(self, *args)

    def insert(self, *args) -> "void":
        return _pylauncher.list_int_insert(self, *args)

    def pop_front(self) -> "void":
        return _pylauncher.list_int_pop_front(self)

    def push_front(self, x: "std::list< int >::value_type const &") -> "void":
        return _pylauncher.list_int_push_front(self, x)

    def reverse(self) -> "void":
        return _pylauncher.list_int_reverse(self)
    __swig_destroy__ = _pylauncher.delete_list_int

# Register list_int in _pylauncher:
_pylauncher.list_int_swigregister(list_int)

class list_str(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _pylauncher.list_str_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _pylauncher.list_str___nonzero__(self)

    def __bool__(self) -> "bool":
        return _pylauncher.list_str___bool__(self)

    def __len__(self) -> "std::list< std::string >::size_type":
        return _pylauncher.list_str___len__(self)

    def __getslice__(self, i: "std::list< std::string >::difference_type", j: "std::list< std::string >::difference_type") -> "std::list< std::string,std::allocator< std::string > > *":
        return _pylauncher.list_str___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _pylauncher.list_str___setslice__(self, *args)

    def __delslice__(self, i: "std::list< std::string >::difference_type", j: "std::list< std::string >::difference_type") -> "void":
        return _pylauncher.list_str___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _pylauncher.list_str___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::list< std::string >::value_type const &":
        return _pylauncher.list_str___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _pylauncher.list_str___setitem__(self, *args)

    def pop(self) -> "std::list< std::string >::value_type":
        return _pylauncher.list_str_pop(self)

    def append(self, x: "std::list< std::string >::value_type const &") -> "void":
        return _pylauncher.list_str_append(self, x)

    def empty(self) -> "bool":
        return _pylauncher.list_str_empty(self)

    def size(self) -> "std::list< std::string >::size_type":
        return _pylauncher.list_str_size(self)

    def swap(self, v: "list_str") -> "void":
        return _pylauncher.list_str_swap(self, v)

    def begin(self) -> "std::list< std::string >::iterator":
        return _pylauncher.list_str_begin(self)

    def end(self) -> "std::list< std::string >::iterator":
        return _pylauncher.list_str_end(self)

    def rbegin(self) -> "std::list< std::string >::reverse_iterator":
        return _pylauncher.list_str_rbegin(self)

    def rend(self) -> "std::list< std::string >::reverse_iterator":
        return _pylauncher.list_str_rend(self)

    def clear(self) -> "void":
        return _pylauncher.list_str_clear(self)

    def get_allocator(self) -> "std::list< std::string >::allocator_type":
        return _pylauncher.list_str_get_allocator(self)

    def pop_back(self) -> "void":
        return _pylauncher.list_str_pop_back(self)

    def erase(self, *args) -> "std::list< std::string >::iterator":
        return _pylauncher.list_str_erase(self, *args)

    def __init__(self, *args):
        _pylauncher.list_str_swiginit(self, _pylauncher.new_list_str(*args))

    def push_back(self, x: "std::list< std::string >::value_type const &") -> "void":
        return _pylauncher.list_str_push_back(self, x)

    def front(self) -> "std::list< std::string >::value_type const &":
        return _pylauncher.list_str_front(self)

    def back(self) -> "std::list< std::string >::value_type const &":
        return _pylauncher.list_str_back(self)

    def assign(self, n: "std::list< std::string >::size_type", x: "std::list< std::string >::value_type const &") -> "void":
        return _pylauncher.list_str_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _pylauncher.list_str_resize(self, *args)

    def insert(self, *args) -> "void":
        return _pylauncher.list_str_insert(self, *args)

    def pop_front(self) -> "void":
        return _pylauncher.list_str_pop_front(self)

    def push_front(self, x: "std::list< std::string >::value_type const &") -> "void":
        return _pylauncher.list_str_push_front(self, x)

    def reverse(self) -> "void":
        return _pylauncher.list_str_reverse(self)
    __swig_destroy__ = _pylauncher.delete_list_str

# Register list_str in _pylauncher:
_pylauncher.list_str_swigregister(list_str)

class vector_str(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _pylauncher.vector_str_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _pylauncher.vector_str___nonzero__(self)

    def __bool__(self) -> "bool":
        return _pylauncher.vector_str___bool__(self)

    def __len__(self) -> "std::vector< std::string >::size_type":
        return _pylauncher.vector_str___len__(self)

    def __getslice__(self, i: "std::vector< std::string >::difference_type", j: "std::vector< std::string >::difference_type") -> "std::vector< std::string,std::allocator< std::string > > *":
        return _pylauncher.vector_str___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _pylauncher.vector_str___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::string >::difference_type", j: "std::vector< std::string >::difference_type") -> "void":
        return _pylauncher.vector_str___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _pylauncher.vector_str___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::string >::value_type const &":
        return _pylauncher.vector_str___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _pylauncher.vector_str___setitem__(self, *args)

    def pop(self) -> "std::vector< std::string >::value_type":
        return _pylauncher.vector_str_pop(self)

    def append(self, x: "std::vector< std::string >::value_type const &") -> "void":
        return _pylauncher.vector_str_append(self, x)

    def empty(self) -> "bool":
        return _pylauncher.vector_str_empty(self)

    def size(self) -> "std::vector< std::string >::size_type":
        return _pylauncher.vector_str_size(self)

    def swap(self, v: "vector_str") -> "void":
        return _pylauncher.vector_str_swap(self, v)

    def begin(self) -> "std::vector< std::string >::iterator":
        return _pylauncher.vector_str_begin(self)

    def end(self) -> "std::vector< std::string >::iterator":
        return _pylauncher.vector_str_end(self)

    def rbegin(self) -> "std::vector< std::string >::reverse_iterator":
        return _pylauncher.vector_str_rbegin(self)

    def rend(self) -> "std::vector< std::string >::reverse_iterator":
        return _pylauncher.vector_str_rend(self)

    def clear(self) -> "void":
        return _pylauncher.vector_str_clear(self)

    def get_allocator(self) -> "std::vector< std::string >::allocator_type":
        return _pylauncher.vector_str_get_allocator(self)

    def pop_back(self) -> "void":
        return _pylauncher.vector_str_pop_back(self)

    def erase(self, *args) -> "std::vector< std::string >::iterator":
        return _pylauncher.vector_str_erase(self, *args)

    def __init__(self, *args):
        _pylauncher.vector_str_swiginit(self, _pylauncher.new_vector_str(*args))

    def push_back(self, x: "std::vector< std::string >::value_type const &") -> "void":
        return _pylauncher.vector_str_push_back(self, x)

    def front(self) -> "std::vector< std::string >::value_type const &":
        return _pylauncher.vector_str_front(self)

    def back(self) -> "std::vector< std::string >::value_type const &":
        return _pylauncher.vector_str_back(self)

    def assign(self, n: "std::vector< std::string >::size_type", x: "std::vector< std::string >::value_type const &") -> "void":
        return _pylauncher.vector_str_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _pylauncher.vector_str_resize(self, *args)

    def insert(self, *args) -> "void":
        return _pylauncher.vector_str_insert(self, *args)

    def reserve(self, n: "std::vector< std::string >::size_type") -> "void":
        return _pylauncher.vector_str_reserve(self, n)

    def capacity(self) -> "std::vector< std::string >::size_type":
        return _pylauncher.vector_str_capacity(self)
    __swig_destroy__ = _pylauncher.delete_vector_str

# Register vector_str in _pylauncher:
_pylauncher.vector_str_swigregister(vector_str)

class map_ss(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _pylauncher.map_ss_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _pylauncher.map_ss___nonzero__(self)

    def __bool__(self) -> "bool":
        return _pylauncher.map_ss___bool__(self)

    def __len__(self) -> "std::map< std::string,std::string >::size_type":
        return _pylauncher.map_ss___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "std::map< std::string,std::string >::key_type const &") -> "std::map< std::string,std::string >::mapped_type const &":
        return _pylauncher.map_ss___getitem__(self, key)

    def __delitem__(self, key: "std::map< std::string,std::string >::key_type const &") -> "void":
        return _pylauncher.map_ss___delitem__(self, key)

    def has_key(self, key: "std::map< std::string,std::string >::key_type const &") -> "bool":
        return _pylauncher.map_ss_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _pylauncher.map_ss_keys(self)

    def values(self) -> "PyObject *":
        return _pylauncher.map_ss_values(self)

    def items(self) -> "PyObject *":
        return _pylauncher.map_ss_items(self)

    def __contains__(self, key: "std::map< std::string,std::string >::key_type const &") -> "bool":
        return _pylauncher.map_ss___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _pylauncher.map_ss_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _pylauncher.map_ss_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _pylauncher.map_ss___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _pylauncher.map_ss_asdict(self)

    def __init__(self, *args):
        _pylauncher.map_ss_swiginit(self, _pylauncher.new_map_ss(*args))

    def empty(self) -> "bool":
        return _pylauncher.map_ss_empty(self)

    def size(self) -> "std::map< std::string,std::string >::size_type":
        return _pylauncher.map_ss_size(self)

    def swap(self, v: "map_ss") -> "void":
        return _pylauncher.map_ss_swap(self, v)

    def begin(self) -> "std::map< std::string,std::string >::iterator":
        return _pylauncher.map_ss_begin(self)

    def end(self) -> "std::map< std::string,std::string >::iterator":
        return _pylauncher.map_ss_end(self)

    def rbegin(self) -> "std::map< std::string,std::string >::reverse_iterator":
        return _pylauncher.map_ss_rbegin(self)

    def rend(self) -> "std::map< std::string,std::string >::reverse_iterator":
        return _pylauncher.map_ss_rend(self)

    def clear(self) -> "void":
        return _pylauncher.map_ss_clear(self)

    def get_allocator(self) -> "std::map< std::string,std::string >::allocator_type":
        return _pylauncher.map_ss_get_allocator(self)

    def count(self, x: "std::map< std::string,std::string >::key_type const &") -> "std::map< std::string,std::string >::size_type":
        return _pylauncher.map_ss_count(self, x)

    def erase(self, *args) -> "void":
        return _pylauncher.map_ss_erase(self, *args)

    def find(self, x: "std::map< std::string,std::string >::key_type const &") -> "std::map< std::string,std::string >::iterator":
        return _pylauncher.map_ss_find(self, x)

    def lower_bound(self, x: "std::map< std::string,std::string >::key_type const &") -> "std::map< std::string,std::string >::iterator":
        return _pylauncher.map_ss_lower_bound(self, x)

    def upper_bound(self, x: "std::map< std::string,std::string >::key_type const &") -> "std::map< std::string,std::string >::iterator":
        return _pylauncher.map_ss_upper_bound(self, x)
    __swig_destroy__ = _pylauncher.delete_map_ss

# Register map_ss in _pylauncher:
_pylauncher.map_ss_swigregister(map_ss)

class resourceParams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pylauncher.resourceParams_swiginit(self, _pylauncher.new_resourceParams())
    name = property(_pylauncher.resourceParams_name_get, _pylauncher.resourceParams_name_set)
    hostname = property(_pylauncher.resourceParams_hostname_get, _pylauncher.resourceParams_hostname_set)
    can_launch_batch_jobs = property(_pylauncher.resourceParams_can_launch_batch_jobs_get, _pylauncher.resourceParams_can_launch_batch_jobs_set)
    can_run_containers = property(_pylauncher.resourceParams_can_run_containers_get, _pylauncher.resourceParams_can_run_containers_set)
    OS = property(_pylauncher.resourceParams_OS_get, _pylauncher.resourceParams_OS_set)
    nb_proc = property(_pylauncher.resourceParams_nb_proc_get, _pylauncher.resourceParams_nb_proc_set)
    nb_node = property(_pylauncher.resourceParams_nb_node_get, _pylauncher.resourceParams_nb_node_set)
    nb_proc_per_node = property(_pylauncher.resourceParams_nb_proc_per_node_get, _pylauncher.resourceParams_nb_proc_per_node_set)
    cpu_clock = property(_pylauncher.resourceParams_cpu_clock_get, _pylauncher.resourceParams_cpu_clock_set)
    mem_mb = property(_pylauncher.resourceParams_mem_mb_get, _pylauncher.resourceParams_mem_mb_set)
    componentList = property(_pylauncher.resourceParams_componentList_get, _pylauncher.resourceParams_componentList_set)
    resourceList = property(_pylauncher.resourceParams_resourceList_get, _pylauncher.resourceParams_resourceList_set)
    __swig_destroy__ = _pylauncher.delete_resourceParams

# Register resourceParams in _pylauncher:
_pylauncher.resourceParams_swigregister(resourceParams)

class JobParameters_cpp(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    job_name = property(_pylauncher.JobParameters_cpp_job_name_get, _pylauncher.JobParameters_cpp_job_name_set)
    job_type = property(_pylauncher.JobParameters_cpp_job_type_get, _pylauncher.JobParameters_cpp_job_type_set)
    job_file = property(_pylauncher.JobParameters_cpp_job_file_get, _pylauncher.JobParameters_cpp_job_file_set)
    pre_command = property(_pylauncher.JobParameters_cpp_pre_command_get, _pylauncher.JobParameters_cpp_pre_command_set)
    env_file = property(_pylauncher.JobParameters_cpp_env_file_get, _pylauncher.JobParameters_cpp_env_file_set)
    in_files = property(_pylauncher.JobParameters_cpp_in_files_get, _pylauncher.JobParameters_cpp_in_files_set)
    out_files = property(_pylauncher.JobParameters_cpp_out_files_get, _pylauncher.JobParameters_cpp_out_files_set)
    work_directory = property(_pylauncher.JobParameters_cpp_work_directory_get, _pylauncher.JobParameters_cpp_work_directory_set)
    local_directory = property(_pylauncher.JobParameters_cpp_local_directory_get, _pylauncher.JobParameters_cpp_local_directory_set)
    result_directory = property(_pylauncher.JobParameters_cpp_result_directory_get, _pylauncher.JobParameters_cpp_result_directory_set)
    maximum_duration = property(_pylauncher.JobParameters_cpp_maximum_duration_get, _pylauncher.JobParameters_cpp_maximum_duration_set)
    resource_required = property(_pylauncher.JobParameters_cpp_resource_required_get, _pylauncher.JobParameters_cpp_resource_required_set)
    queue = property(_pylauncher.JobParameters_cpp_queue_get, _pylauncher.JobParameters_cpp_queue_set)
    partition = property(_pylauncher.JobParameters_cpp_partition_get, _pylauncher.JobParameters_cpp_partition_set)
    exclusive = property(_pylauncher.JobParameters_cpp_exclusive_get, _pylauncher.JobParameters_cpp_exclusive_set)
    mem_per_cpu = property(_pylauncher.JobParameters_cpp_mem_per_cpu_get, _pylauncher.JobParameters_cpp_mem_per_cpu_set)
    wckey = property(_pylauncher.JobParameters_cpp_wckey_get, _pylauncher.JobParameters_cpp_wckey_set)
    extra_params = property(_pylauncher.JobParameters_cpp_extra_params_get, _pylauncher.JobParameters_cpp_extra_params_set)
    specific_parameters = property(_pylauncher.JobParameters_cpp_specific_parameters_get, _pylauncher.JobParameters_cpp_specific_parameters_set)
    launcher_file = property(_pylauncher.JobParameters_cpp_launcher_file_get, _pylauncher.JobParameters_cpp_launcher_file_set)
    launcher_args = property(_pylauncher.JobParameters_cpp_launcher_args_get, _pylauncher.JobParameters_cpp_launcher_args_set)

    def __init__(self):
        _pylauncher.JobParameters_cpp_swiginit(self, _pylauncher.new_JobParameters_cpp())
    __swig_destroy__ = _pylauncher.delete_JobParameters_cpp

# Register JobParameters_cpp in _pylauncher:
_pylauncher.JobParameters_cpp_swigregister(JobParameters_cpp)

class ResourceDefinition_cpp(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = property(_pylauncher.ResourceDefinition_cpp_name_get, _pylauncher.ResourceDefinition_cpp_name_set)
    hostname = property(_pylauncher.ResourceDefinition_cpp_hostname_get, _pylauncher.ResourceDefinition_cpp_hostname_set)
    type = property(_pylauncher.ResourceDefinition_cpp_type_get, _pylauncher.ResourceDefinition_cpp_type_set)
    protocol = property(_pylauncher.ResourceDefinition_cpp_protocol_get, _pylauncher.ResourceDefinition_cpp_protocol_set)
    username = property(_pylauncher.ResourceDefinition_cpp_username_get, _pylauncher.ResourceDefinition_cpp_username_set)
    applipath = property(_pylauncher.ResourceDefinition_cpp_applipath_get, _pylauncher.ResourceDefinition_cpp_applipath_set)
    OS = property(_pylauncher.ResourceDefinition_cpp_OS_get, _pylauncher.ResourceDefinition_cpp_OS_set)
    mem_mb = property(_pylauncher.ResourceDefinition_cpp_mem_mb_get, _pylauncher.ResourceDefinition_cpp_mem_mb_set)
    cpu_clock = property(_pylauncher.ResourceDefinition_cpp_cpu_clock_get, _pylauncher.ResourceDefinition_cpp_cpu_clock_set)
    nb_node = property(_pylauncher.ResourceDefinition_cpp_nb_node_get, _pylauncher.ResourceDefinition_cpp_nb_node_set)
    nb_proc_per_node = property(_pylauncher.ResourceDefinition_cpp_nb_proc_per_node_get, _pylauncher.ResourceDefinition_cpp_nb_proc_per_node_set)
    batch = property(_pylauncher.ResourceDefinition_cpp_batch_get, _pylauncher.ResourceDefinition_cpp_batch_set)
    mpiImpl = property(_pylauncher.ResourceDefinition_cpp_mpiImpl_get, _pylauncher.ResourceDefinition_cpp_mpiImpl_set)
    iprotocol = property(_pylauncher.ResourceDefinition_cpp_iprotocol_get, _pylauncher.ResourceDefinition_cpp_iprotocol_set)
    can_launch_batch_jobs = property(_pylauncher.ResourceDefinition_cpp_can_launch_batch_jobs_get, _pylauncher.ResourceDefinition_cpp_can_launch_batch_jobs_set)
    can_run_containers = property(_pylauncher.ResourceDefinition_cpp_can_run_containers_get, _pylauncher.ResourceDefinition_cpp_can_run_containers_set)
    working_directory = property(_pylauncher.ResourceDefinition_cpp_working_directory_get, _pylauncher.ResourceDefinition_cpp_working_directory_set)

    def fromPRT(self, other: "ParserResourcesType const &") -> "void":
        return _pylauncher.ResourceDefinition_cpp_fromPRT(self, other)

    def toPRT(self) -> "ParserResourcesType":
        return _pylauncher.ResourceDefinition_cpp_toPRT(self)

    def __init__(self):
        _pylauncher.ResourceDefinition_cpp_swiginit(self, _pylauncher.new_ResourceDefinition_cpp())
    __swig_destroy__ = _pylauncher.delete_ResourceDefinition_cpp

# Register ResourceDefinition_cpp in _pylauncher:
_pylauncher.ResourceDefinition_cpp_swigregister(ResourceDefinition_cpp)

SHARED_PTR_DISOWN = _pylauncher.SHARED_PTR_DISOWN
class ResourcesManager_cpp(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, xmlFilePath: "char const *"):
        _pylauncher.ResourcesManager_cpp_swiginit(self, _pylauncher.new_ResourcesManager_cpp(xmlFilePath))

    def GetFittingResources(self, params: "resourceParams") -> "std::vector< std::string,std::allocator< std::string > >":
        return _pylauncher.ResourcesManager_cpp_GetFittingResources(self, params)

    def WriteInXmlFile(self, xml_file: "std::string") -> "void":
        return _pylauncher.ResourcesManager_cpp_WriteInXmlFile(self, xml_file)

    def DeleteAllResourcesInCatalog(self) -> "void":
        return _pylauncher.ResourcesManager_cpp_DeleteAllResourcesInCatalog(self)

    def GetResourceDefinition(self, name: "std::string const &") -> "ResourceDefinition_cpp":
        return _pylauncher.ResourcesManager_cpp_GetResourceDefinition(self, name)

    def DeleteResourceInCatalog(self, name: "std::string const &") -> "void":
        return _pylauncher.ResourcesManager_cpp_DeleteResourceInCatalog(self, name)

    def AddResourceInCatalog(self, new_resource: "ResourceDefinition_cpp") -> "void":
        return _pylauncher.ResourcesManager_cpp_AddResourceInCatalog(self, new_resource)

    def AddResourceInCatalogNoQuestion(self, new_resource: "ResourceDefinition_cpp") -> "void":
        return _pylauncher.ResourcesManager_cpp_AddResourceInCatalogNoQuestion(self, new_resource)

    def ParseXmlFiles(self) -> "void":
        return _pylauncher.ResourcesManager_cpp_ParseXmlFiles(self)

    def GetListOfEntries(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _pylauncher.ResourcesManager_cpp_GetListOfEntries(self)
    __swig_destroy__ = _pylauncher.delete_ResourcesManager_cpp

# Register ResourcesManager_cpp in _pylauncher:
_pylauncher.ResourcesManager_cpp_swigregister(ResourcesManager_cpp)


def HandleToLocalInstance(ptrInStringFrmt: "std::string const &") -> "std::shared_ptr< ResourcesManager_cpp >":
    return _pylauncher.HandleToLocalInstance(ptrInStringFrmt)
class Launcher_cpp(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _pylauncher.Launcher_cpp_swiginit(self, _pylauncher.new_Launcher_cpp())
    __swig_destroy__ = _pylauncher.delete_Launcher_cpp

    def createJob(self, job_parameters: "JobParameters_cpp") -> "int":
        return _pylauncher.Launcher_cpp_createJob(self, job_parameters)

    def launchJob(self, job_id: "int") -> "void":
        return _pylauncher.Launcher_cpp_launchJob(self, job_id)

    def getJobState(self, job_id: "int") -> "std::string":
        return _pylauncher.Launcher_cpp_getJobState(self, job_id)

    def getAssignedHostnames(self, job_id: "int") -> "std::string":
        return _pylauncher.Launcher_cpp_getAssignedHostnames(self, job_id)

    def exportInputFiles(self, job_id: "int") -> "void":
        return _pylauncher.Launcher_cpp_exportInputFiles(self, job_id)

    def getJobResults(self, job_id: "int", directory: "std::string") -> "void":
        return _pylauncher.Launcher_cpp_getJobResults(self, job_id, directory)

    def clearJobWorkingDir(self, job_id: "int") -> "void":
        return _pylauncher.Launcher_cpp_clearJobWorkingDir(self, job_id)

    def getJobDumpState(self, job_id: "int", directory: "std::string") -> "bool":
        return _pylauncher.Launcher_cpp_getJobDumpState(self, job_id, directory)

    def getJobWorkFile(self, job_id: "int", work_file: "std::string", directory: "std::string") -> "bool":
        return _pylauncher.Launcher_cpp_getJobWorkFile(self, job_id, work_file, directory)

    def getMaximumDurationInSecond(self, job_id: "int") -> "long":
        return _pylauncher.Launcher_cpp_getMaximumDurationInSecond(self, job_id)

    def stopJob(self, job_id: "int") -> "void":
        return _pylauncher.Launcher_cpp_stopJob(self, job_id)

    def removeJob(self, job_id: "int") -> "void":
        return _pylauncher.Launcher_cpp_removeJob(self, job_id)

    def dumpJob(self, job_id: "int") -> "std::string":
        return _pylauncher.Launcher_cpp_dumpJob(self, job_id)

    def restoreJob(self, dumpedJob: "std::string const &") -> "int":
        return _pylauncher.Launcher_cpp_restoreJob(self, dumpedJob)

    def getJobParameters(self, job_id: "int") -> "JobParameters_cpp":
        return _pylauncher.Launcher_cpp_getJobParameters(self, job_id)

    def loadJobs(self, jobs_file: "char const *") -> "std::list< int,std::allocator< int > >":
        return _pylauncher.Launcher_cpp_loadJobs(self, jobs_file)

    def saveJobs(self, jobs_file: "char const *") -> "void":
        return _pylauncher.Launcher_cpp_saveJobs(self, jobs_file)

    def createJobWithFile(self, xmlExecuteFile: "std::string", clusterName: "std::string") -> "long":
        return _pylauncher.Launcher_cpp_createJobWithFile(self, xmlExecuteFile, clusterName)

    def SetResourcesManager(self, rm: "std::shared_ptr< ResourcesManager_cpp > &") -> "void":
        return _pylauncher.Launcher_cpp_SetResourcesManager(self, rm)

# Register Launcher_cpp in _pylauncher:
_pylauncher.Launcher_cpp_swigregister(Launcher_cpp)


def CreateSSHContainerResource(hostname,applipath,nbOfNodes=1):
  return CreateContainerResource(hostname,applipath,"ssh",nbOfNodes)

def CreateSRUNContainerResource(hostname,applipath,nbOfNodes=1):
  return CreateContainerResource(hostname,applipath,"srun",nbOfNodes)

def CreateContainerResource(hostname,applipath,protocol,nbOfNodes=1):
  import getpass
  ret = ResourceDefinition_cpp()
  ret.name = hostname.split(".")[0]
  ret.hostname = ret.name
  ret.protocol = protocol
  ret.applipath = applipath
  ret.nb_node = nbOfNodes
  ret.nb_proc_per_node = 1
  ret.can_run_containers = True
  ret.can_launch_batch_jobs = False
  ret.mpiImpl = "no mpi"
  ret.iprotocol = protocol
  ret.type = "single_machine"
  ret.username = getpass.getuser()
  return ret

def ResourceDefinition_cpp_repr(self):
  pat0 = "{} = {}"
  pat1 = "{} = \"{}\""
  data = [("name","name",pat0),
  ("hostname","hostname",pat0),
  ("type","type",pat0),
  ("protocol","protocol",pat0),
  ("userName","username",pat0),
  ("appliPath","applipath",pat1),
  ("mpi","mpiImpl",pat0),
  ("nbOfNodes","nb_node",pat0),
  ("nbOfProcPerNode","nb_proc_per_node",pat0),
  ("canRunContainer","can_run_containers",pat0)
  ]
  ret = [c.format(a,getattr(self,b)) for a,b,c in data]
  return "\n".join( ret )

def ResourcesManager_cpp_GetList(self):
  return {name:self.GetResourceDefinition(name) for name in self.GetListOfEntries()}

def ResourcesManager_cpp___getitem__(self,name):
  return self.GetResourceDefinition(name)

def ResourcesManager_cpp___repr__(self):
  return str( self.GetList() )

ListOfAttrCommon = ['name', 'OS', 'applipath', 'batch', 'can_launch_batch_jobs', 'can_run_containers', 'componentList', 'cpu_clock', 'hostname', 'iprotocol', 'mem_mb', 'mpiImpl', 'nb_node', 'nb_proc_per_node', 'protocol', 'type', 'username', 'working_directory']

def ResourceDefinition_cpp_isEqual(self,other):
  return all( [getattr(self,k) == getattr(other,k) for k in ListOfAttrCommon] )

def RetrieveRMCppSingleton():
  from salome.kernel import KernelLauncher
  return HandleToLocalInstance( KernelLauncher.RetrieveInternalInstanceOfLocalCppResourcesManager() )

def GetPlayGroundInsideASlurmJob():
  import subprocess as sp
  cont = sp.check_output(["srun","hostname"])
  nodesMul = [elt for elt in cont.decode().split("\n") if elt != ""]
  from collections import defaultdict
  d = defaultdict(int)
  for elt in nodesMul:
      d[elt]+=1
  return d

def BuildCatalogFromScratch(protocol,appliPath):
  import os
  d = GetPlayGroundInsideASlurmJob()
  rmcpp = RetrieveRMCppSingleton()
  rmcpp.DeleteAllResourcesInCatalog()
  for k,v in d.items():
      contRes = CreateContainerResource(hostname=k,applipath=appliPath,protocol=protocol,nbOfNodes=v)
      rmcpp.AddResourceInCatalogNoQuestion(contRes)

def GetRequestForGiveContainer(hostname, contName):
  from salome.kernel import Engines
  import os
  rp=Engines.ResourceParameters(name=hostname,
                                hostname=hostname,
                                can_launch_batch_jobs=False,
                                can_run_containers=True,
                                OS="Linux",
                                componentList=[],
                                nb_proc=1,
                                mem_mb=1000,
                                cpu_clock=1000,
                                nb_node=1,
                                nb_proc_per_node=1,
                                policy="first",
                                resList=[])

  cp=Engines.ContainerParameters(container_name=contName,
                                  mode="start",
                                  workingdir=os.path.expanduser("~"),
                                  nb_proc=1,
                                  isMPI=False,
                                  parallelLib="",
                                  resource_params=rp)
  return cp


def FromEngineResourceDefinitionToCPP( corbaInstance ):
  """
  Convert Engine.ResourceDefinition to ResourceDefinition_cpp instance
  """
  ret = ResourceDefinition_cpp()
  for k in ListOfAttrCommon:
    setattr(ret,k,getattr(corbaInstance,k))
  return ret

def ToEngineResourceDefinitionFromCPP( cppInstance ):
  from salome.kernel import Engines
  return Engines.ResourceDefinition(**{k:getattr(cppInstance,k) for k in ListOfAttrCommon})

ResourceDefinition_cpp.repr = ResourceDefinition_cpp_repr
ResourceDefinition_cpp.__repr__ = ResourceDefinition_cpp_repr
ResourceDefinition_cpp.__eq__ = ResourceDefinition_cpp_isEqual

ResourcesManager_cpp.GetList = ResourcesManager_cpp_GetList
ResourcesManager_cpp.__getitem__ = ResourcesManager_cpp___getitem__
ResourcesManager_cpp.__repr__ = ResourcesManager_cpp___repr__




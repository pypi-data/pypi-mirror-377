# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""All is needed to create and execute a calculation schema."""

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _pilot
else:
    import _pilot

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class pilot_PySwigIterator(object):
    r"""Proxy of C++ swig::pilot_PySwigIterator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pilot.delete_pilot_PySwigIterator

    def value(self):
        r"""value(pilot_PySwigIterator self) -> PyObject *"""
        return _pilot.pilot_PySwigIterator_value(self)

    def incr(self, n=1):
        r"""incr(pilot_PySwigIterator self, size_t n=1) -> pilot_PySwigIterator"""
        return _pilot.pilot_PySwigIterator_incr(self, n)

    def decr(self, n=1):
        r"""decr(pilot_PySwigIterator self, size_t n=1) -> pilot_PySwigIterator"""
        return _pilot.pilot_PySwigIterator_decr(self, n)

    def distance(self, x):
        r"""distance(pilot_PySwigIterator self, pilot_PySwigIterator x) -> ptrdiff_t"""
        return _pilot.pilot_PySwigIterator_distance(self, x)

    def equal(self, x):
        r"""equal(pilot_PySwigIterator self, pilot_PySwigIterator x) -> bool"""
        return _pilot.pilot_PySwigIterator_equal(self, x)

    def copy(self):
        r"""copy(pilot_PySwigIterator self) -> pilot_PySwigIterator"""
        return _pilot.pilot_PySwigIterator_copy(self)

    def next(self):
        r"""next(pilot_PySwigIterator self) -> PyObject *"""
        return _pilot.pilot_PySwigIterator_next(self)

    def __next__(self):
        r"""__next__(pilot_PySwigIterator self) -> PyObject *"""
        return _pilot.pilot_PySwigIterator___next__(self)

    def previous(self):
        r"""previous(pilot_PySwigIterator self) -> PyObject *"""
        return _pilot.pilot_PySwigIterator_previous(self)

    def advance(self, n):
        r"""advance(pilot_PySwigIterator self, ptrdiff_t n) -> pilot_PySwigIterator"""
        return _pilot.pilot_PySwigIterator_advance(self, n)

    def __eq__(self, x):
        r"""__eq__(pilot_PySwigIterator self, pilot_PySwigIterator x) -> bool"""
        return _pilot.pilot_PySwigIterator___eq__(self, x)

    def __ne__(self, x):
        r"""__ne__(pilot_PySwigIterator self, pilot_PySwigIterator x) -> bool"""
        return _pilot.pilot_PySwigIterator___ne__(self, x)

    def __iadd__(self, n):
        r"""__iadd__(pilot_PySwigIterator self, ptrdiff_t n) -> pilot_PySwigIterator"""
        return _pilot.pilot_PySwigIterator___iadd__(self, n)

    def __isub__(self, n):
        r"""__isub__(pilot_PySwigIterator self, ptrdiff_t n) -> pilot_PySwigIterator"""
        return _pilot.pilot_PySwigIterator___isub__(self, n)

    def __add__(self, n):
        r"""__add__(pilot_PySwigIterator self, ptrdiff_t n) -> pilot_PySwigIterator"""
        return _pilot.pilot_PySwigIterator___add__(self, n)

    def __sub__(self, *args):
        r"""
        __sub__(pilot_PySwigIterator self, ptrdiff_t n) -> pilot_PySwigIterator
        __sub__(pilot_PySwigIterator self, pilot_PySwigIterator x) -> ptrdiff_t
        """
        return _pilot.pilot_PySwigIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register pilot_PySwigIterator in _pilot:
_pilot.pilot_PySwigIterator_swigregister(pilot_PySwigIterator)

class ItPy3TC(object):
    r"""Proxy of C++ IteratorPy3< YACS::ENGINE::TypeCode * > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, _cur, _end):
        r"""__init__(ItPy3TC self, std::map< std::string,YACS::ENGINE::TypeCode **,std::less< std::string >,std::allocator< std::pair< std::string const,YACS::ENGINE::TypeCode ** > > >::iterator _cur, std::map< std::string,YACS::ENGINE::TypeCode **,std::less< std::string >,std::allocator< std::pair< std::string const,YACS::ENGINE::TypeCode ** > > >::iterator _end) -> ItPy3TC"""
        _pilot.ItPy3TC_swiginit(self, _pilot.new_ItPy3TC(_cur, _end))
    __swig_destroy__ = _pilot.delete_ItPy3TC

    def __iter__(self):
        r"""__iter__(ItPy3TC self) -> ItPy3TC"""
        return _pilot.ItPy3TC___iter__(self)
    cur = property(_pilot.ItPy3TC_cur_get, _pilot.ItPy3TC_cur_set, doc=r"""cur : std::map<(std::string,p.p.YACS::ENGINE::TypeCode,std::less<(std::string)>,std::allocator<(std::pair<(q(const).std::string,p.p.YACS::ENGINE::TypeCode)>)>)>::iterator""")
    end = property(_pilot.ItPy3TC_end_get, _pilot.ItPy3TC_end_set, doc=r"""end : std::map<(std::string,p.p.YACS::ENGINE::TypeCode,std::less<(std::string)>,std::allocator<(std::pair<(q(const).std::string,p.p.YACS::ENGINE::TypeCode)>)>)>::iterator""")

# Register ItPy3TC in _pilot:
_pilot.ItPy3TC_swigregister(ItPy3TC)

class TCmapit(object):
    r"""Proxy of C++ IteratorPy3< YACS::ENGINE::TypeCode > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, _cur, _end):
        r"""__init__(TCmapit self, std::map< std::string,YACS::ENGINE::TypeCode *,std::less< std::string >,std::allocator< std::pair< std::string const,YACS::ENGINE::TypeCode * > > >::iterator _cur, std::map< std::string,YACS::ENGINE::TypeCode *,std::less< std::string >,std::allocator< std::pair< std::string const,YACS::ENGINE::TypeCode * > > >::iterator _end) -> TCmapit"""
        _pilot.TCmapit_swiginit(self, _pilot.new_TCmapit(_cur, _end))
    __swig_destroy__ = _pilot.delete_TCmapit

    def __iter__(self):
        r"""__iter__(TCmapit self) -> TCmapit"""
        return _pilot.TCmapit___iter__(self)
    cur = property(_pilot.TCmapit_cur_get, _pilot.TCmapit_cur_set, doc=r"""cur : std::map<(std::string,p.YACS::ENGINE::TypeCode,std::less<(std::string)>,std::allocator<(std::pair<(q(const).std::string,p.YACS::ENGINE::TypeCode)>)>)>::iterator""")
    end = property(_pilot.TCmapit_end_get, _pilot.TCmapit_end_set, doc=r"""end : std::map<(std::string,p.YACS::ENGINE::TypeCode,std::less<(std::string)>,std::allocator<(std::pair<(q(const).std::string,p.YACS::ENGINE::TypeCode)>)>)>::iterator""")

    def __next__(self):
        r"""__next__(TCmapit self) -> std::string"""
        return _pilot.TCmapit___next__(self)

# Register TCmapit in _pilot:
_pilot.TCmapit_swigregister(TCmapit)

class TCmap(object):
    r"""Proxy of C++ std::map< std::string,YACS::ENGINE::TypeCode * > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __setitem__(self, name, c):
        r"""__setitem__(TCmap self, std::string const & name, TypeCode c)"""
        return _pilot.TCmap___setitem__(self, name, c)

    def __getitem__(self, name):
        r"""__getitem__(TCmap self, std::string name) -> TypeCode"""
        return _pilot.TCmap___getitem__(self, name)

    def __delitem__(self, name):
        r"""__delitem__(TCmap self, std::string name)"""
        return _pilot.TCmap___delitem__(self, name)

    def keys(self):
        r"""keys(TCmap self) -> PyObject *"""
        return _pilot.TCmap_keys(self)

    def __iter__(self):
        r"""__iter__(TCmap self) -> TCmapit"""
        return _pilot.TCmap___iter__(self)

    def __len__(self):
        r"""__len__(TCmap self) -> int"""
        return _pilot.TCmap___len__(self)

    def __init__(self):
        r"""__init__(TCmap self) -> TCmap"""
        _pilot.TCmap_swiginit(self, _pilot.new_TCmap())
    __swig_destroy__ = _pilot.delete_TCmap

# Register TCmap in _pilot:
_pilot.TCmap_swigregister(TCmap)


from collections.abc import MutableMapping
class TCmap(TCmap,MutableMapping):pass
import sys
def zeFunc( moduleName ):
  elt = moduleName.split(".")
  return ( ".".join( elt[:-1] + [ "_{}".format(elt[-1]) ] ) )
sys.modules[ zeFunc( __name__ ) ].TCmap_swigregister(TCmap)
del zeFunc

class NODEmap(object):
    r"""Proxy of C++ std::map< std::string,YACS::ENGINE::Node * > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(NODEmap self) -> pilot_PySwigIterator"""
        return _pilot.NODEmap_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(NODEmap self) -> bool"""
        return _pilot.NODEmap___nonzero__(self)

    def __bool__(self):
        r"""__bool__(NODEmap self) -> bool"""
        return _pilot.NODEmap___bool__(self)

    def __len__(self):
        r"""__len__(NODEmap self) -> std::map< std::string,YACS::ENGINE::Node * >::size_type"""
        return _pilot.NODEmap___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        r"""__getitem__(NODEmap self, std::map< std::string,YACS::ENGINE::Node * >::key_type const & key) -> Node"""
        return _pilot.NODEmap___getitem__(self, key)

    def __delitem__(self, key):
        r"""__delitem__(NODEmap self, std::map< std::string,YACS::ENGINE::Node * >::key_type const & key)"""
        return _pilot.NODEmap___delitem__(self, key)

    def has_key(self, key):
        r"""has_key(NODEmap self, std::map< std::string,YACS::ENGINE::Node * >::key_type const & key) -> bool"""
        return _pilot.NODEmap_has_key(self, key)

    def keys(self):
        r"""keys(NODEmap self) -> PyObject *"""
        return _pilot.NODEmap_keys(self)

    def values(self):
        r"""values(NODEmap self) -> PyObject *"""
        return _pilot.NODEmap_values(self)

    def items(self):
        r"""items(NODEmap self) -> PyObject *"""
        return _pilot.NODEmap_items(self)

    def __contains__(self, key):
        r"""__contains__(NODEmap self, std::map< std::string,YACS::ENGINE::Node * >::key_type const & key) -> bool"""
        return _pilot.NODEmap___contains__(self, key)

    def key_iterator(self):
        r"""key_iterator(NODEmap self) -> pilot_PySwigIterator"""
        return _pilot.NODEmap_key_iterator(self)

    def value_iterator(self):
        r"""value_iterator(NODEmap self) -> pilot_PySwigIterator"""
        return _pilot.NODEmap_value_iterator(self)

    def __setitem__(self, *args):
        r"""
        __setitem__(NODEmap self, std::map< std::string,YACS::ENGINE::Node * >::key_type const & key)
        __setitem__(NODEmap self, std::map< std::string,YACS::ENGINE::Node * >::key_type const & key, Node x)
        """
        return _pilot.NODEmap___setitem__(self, *args)

    def asdict(self):
        r"""asdict(NODEmap self) -> PyObject *"""
        return _pilot.NODEmap_asdict(self)

    def __init__(self, *args):
        r"""
        __init__(NODEmap self, std::less< std::string > const & other) -> NODEmap
        __init__(NODEmap self) -> NODEmap
        __init__(NODEmap self, NODEmap other) -> NODEmap
        """
        _pilot.NODEmap_swiginit(self, _pilot.new_NODEmap(*args))

    def empty(self):
        r"""empty(NODEmap self) -> bool"""
        return _pilot.NODEmap_empty(self)

    def size(self):
        r"""size(NODEmap self) -> std::map< std::string,YACS::ENGINE::Node * >::size_type"""
        return _pilot.NODEmap_size(self)

    def swap(self, v):
        r"""swap(NODEmap self, NODEmap v)"""
        return _pilot.NODEmap_swap(self, v)

    def begin(self):
        r"""begin(NODEmap self) -> std::map< std::string,YACS::ENGINE::Node * >::iterator"""
        return _pilot.NODEmap_begin(self)

    def end(self):
        r"""end(NODEmap self) -> std::map< std::string,YACS::ENGINE::Node * >::iterator"""
        return _pilot.NODEmap_end(self)

    def rbegin(self):
        r"""rbegin(NODEmap self) -> std::map< std::string,YACS::ENGINE::Node * >::reverse_iterator"""
        return _pilot.NODEmap_rbegin(self)

    def rend(self):
        r"""rend(NODEmap self) -> std::map< std::string,YACS::ENGINE::Node * >::reverse_iterator"""
        return _pilot.NODEmap_rend(self)

    def clear(self):
        r"""clear(NODEmap self)"""
        return _pilot.NODEmap_clear(self)

    def get_allocator(self):
        r"""get_allocator(NODEmap self) -> std::map< std::string,YACS::ENGINE::Node * >::allocator_type"""
        return _pilot.NODEmap_get_allocator(self)

    def count(self, x):
        r"""count(NODEmap self, std::map< std::string,YACS::ENGINE::Node * >::key_type const & x) -> std::map< std::string,YACS::ENGINE::Node * >::size_type"""
        return _pilot.NODEmap_count(self, x)

    def erase(self, *args):
        r"""
        erase(NODEmap self, std::map< std::string,YACS::ENGINE::Node * >::key_type const & x) -> std::map< std::string,YACS::ENGINE::Node * >::size_type
        erase(NODEmap self, std::map< std::string,YACS::ENGINE::Node * >::iterator position)
        erase(NODEmap self, std::map< std::string,YACS::ENGINE::Node * >::iterator first, std::map< std::string,YACS::ENGINE::Node * >::iterator last)
        """
        return _pilot.NODEmap_erase(self, *args)

    def find(self, x):
        r"""find(NODEmap self, std::map< std::string,YACS::ENGINE::Node * >::key_type const & x) -> std::map< std::string,YACS::ENGINE::Node * >::iterator"""
        return _pilot.NODEmap_find(self, x)

    def lower_bound(self, x):
        r"""lower_bound(NODEmap self, std::map< std::string,YACS::ENGINE::Node * >::key_type const & x) -> std::map< std::string,YACS::ENGINE::Node * >::iterator"""
        return _pilot.NODEmap_lower_bound(self, x)

    def upper_bound(self, x):
        r"""upper_bound(NODEmap self, std::map< std::string,YACS::ENGINE::Node * >::key_type const & x) -> std::map< std::string,YACS::ENGINE::Node * >::iterator"""
        return _pilot.NODEmap_upper_bound(self, x)
    __swig_destroy__ = _pilot.delete_NODEmap

# Register NODEmap in _pilot:
_pilot.NODEmap_swigregister(NODEmap)

class INODEmap(object):
    r"""Proxy of C++ std::map< std::string,YACS::ENGINE::InlineNode * > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(INODEmap self) -> pilot_PySwigIterator"""
        return _pilot.INODEmap_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(INODEmap self) -> bool"""
        return _pilot.INODEmap___nonzero__(self)

    def __bool__(self):
        r"""__bool__(INODEmap self) -> bool"""
        return _pilot.INODEmap___bool__(self)

    def __len__(self):
        r"""__len__(INODEmap self) -> std::map< std::string,YACS::ENGINE::InlineNode * >::size_type"""
        return _pilot.INODEmap___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        r"""__getitem__(INODEmap self, std::map< std::string,YACS::ENGINE::InlineNode * >::key_type const & key) -> InlineNode"""
        return _pilot.INODEmap___getitem__(self, key)

    def __delitem__(self, key):
        r"""__delitem__(INODEmap self, std::map< std::string,YACS::ENGINE::InlineNode * >::key_type const & key)"""
        return _pilot.INODEmap___delitem__(self, key)

    def has_key(self, key):
        r"""has_key(INODEmap self, std::map< std::string,YACS::ENGINE::InlineNode * >::key_type const & key) -> bool"""
        return _pilot.INODEmap_has_key(self, key)

    def keys(self):
        r"""keys(INODEmap self) -> PyObject *"""
        return _pilot.INODEmap_keys(self)

    def values(self):
        r"""values(INODEmap self) -> PyObject *"""
        return _pilot.INODEmap_values(self)

    def items(self):
        r"""items(INODEmap self) -> PyObject *"""
        return _pilot.INODEmap_items(self)

    def __contains__(self, key):
        r"""__contains__(INODEmap self, std::map< std::string,YACS::ENGINE::InlineNode * >::key_type const & key) -> bool"""
        return _pilot.INODEmap___contains__(self, key)

    def key_iterator(self):
        r"""key_iterator(INODEmap self) -> pilot_PySwigIterator"""
        return _pilot.INODEmap_key_iterator(self)

    def value_iterator(self):
        r"""value_iterator(INODEmap self) -> pilot_PySwigIterator"""
        return _pilot.INODEmap_value_iterator(self)

    def __setitem__(self, *args):
        r"""
        __setitem__(INODEmap self, std::map< std::string,YACS::ENGINE::InlineNode * >::key_type const & key)
        __setitem__(INODEmap self, std::map< std::string,YACS::ENGINE::InlineNode * >::key_type const & key, InlineNode x)
        """
        return _pilot.INODEmap___setitem__(self, *args)

    def asdict(self):
        r"""asdict(INODEmap self) -> PyObject *"""
        return _pilot.INODEmap_asdict(self)

    def __init__(self, *args):
        r"""
        __init__(INODEmap self, std::less< std::string > const & other) -> INODEmap
        __init__(INODEmap self) -> INODEmap
        __init__(INODEmap self, INODEmap other) -> INODEmap
        """
        _pilot.INODEmap_swiginit(self, _pilot.new_INODEmap(*args))

    def empty(self):
        r"""empty(INODEmap self) -> bool"""
        return _pilot.INODEmap_empty(self)

    def size(self):
        r"""size(INODEmap self) -> std::map< std::string,YACS::ENGINE::InlineNode * >::size_type"""
        return _pilot.INODEmap_size(self)

    def swap(self, v):
        r"""swap(INODEmap self, INODEmap v)"""
        return _pilot.INODEmap_swap(self, v)

    def begin(self):
        r"""begin(INODEmap self) -> std::map< std::string,YACS::ENGINE::InlineNode * >::iterator"""
        return _pilot.INODEmap_begin(self)

    def end(self):
        r"""end(INODEmap self) -> std::map< std::string,YACS::ENGINE::InlineNode * >::iterator"""
        return _pilot.INODEmap_end(self)

    def rbegin(self):
        r"""rbegin(INODEmap self) -> std::map< std::string,YACS::ENGINE::InlineNode * >::reverse_iterator"""
        return _pilot.INODEmap_rbegin(self)

    def rend(self):
        r"""rend(INODEmap self) -> std::map< std::string,YACS::ENGINE::InlineNode * >::reverse_iterator"""
        return _pilot.INODEmap_rend(self)

    def clear(self):
        r"""clear(INODEmap self)"""
        return _pilot.INODEmap_clear(self)

    def get_allocator(self):
        r"""get_allocator(INODEmap self) -> std::map< std::string,YACS::ENGINE::InlineNode * >::allocator_type"""
        return _pilot.INODEmap_get_allocator(self)

    def count(self, x):
        r"""count(INODEmap self, std::map< std::string,YACS::ENGINE::InlineNode * >::key_type const & x) -> std::map< std::string,YACS::ENGINE::InlineNode * >::size_type"""
        return _pilot.INODEmap_count(self, x)

    def erase(self, *args):
        r"""
        erase(INODEmap self, std::map< std::string,YACS::ENGINE::InlineNode * >::key_type const & x) -> std::map< std::string,YACS::ENGINE::InlineNode * >::size_type
        erase(INODEmap self, std::map< std::string,YACS::ENGINE::InlineNode * >::iterator position)
        erase(INODEmap self, std::map< std::string,YACS::ENGINE::InlineNode * >::iterator first, std::map< std::string,YACS::ENGINE::InlineNode * >::iterator last)
        """
        return _pilot.INODEmap_erase(self, *args)

    def find(self, x):
        r"""find(INODEmap self, std::map< std::string,YACS::ENGINE::InlineNode * >::key_type const & x) -> std::map< std::string,YACS::ENGINE::InlineNode * >::iterator"""
        return _pilot.INODEmap_find(self, x)

    def lower_bound(self, x):
        r"""lower_bound(INODEmap self, std::map< std::string,YACS::ENGINE::InlineNode * >::key_type const & x) -> std::map< std::string,YACS::ENGINE::InlineNode * >::iterator"""
        return _pilot.INODEmap_lower_bound(self, x)

    def upper_bound(self, x):
        r"""upper_bound(INODEmap self, std::map< std::string,YACS::ENGINE::InlineNode * >::key_type const & x) -> std::map< std::string,YACS::ENGINE::InlineNode * >::iterator"""
        return _pilot.INODEmap_upper_bound(self, x)
    __swig_destroy__ = _pilot.delete_INODEmap

# Register INODEmap in _pilot:
_pilot.INODEmap_swigregister(INODEmap)

class SNODEmap(object):
    r"""Proxy of C++ std::map< std::string,YACS::ENGINE::ServiceNode * > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(SNODEmap self) -> pilot_PySwigIterator"""
        return _pilot.SNODEmap_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(SNODEmap self) -> bool"""
        return _pilot.SNODEmap___nonzero__(self)

    def __bool__(self):
        r"""__bool__(SNODEmap self) -> bool"""
        return _pilot.SNODEmap___bool__(self)

    def __len__(self):
        r"""__len__(SNODEmap self) -> std::map< std::string,YACS::ENGINE::ServiceNode * >::size_type"""
        return _pilot.SNODEmap___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        r"""__getitem__(SNODEmap self, std::map< std::string,YACS::ENGINE::ServiceNode * >::key_type const & key) -> ServiceNode"""
        return _pilot.SNODEmap___getitem__(self, key)

    def __delitem__(self, key):
        r"""__delitem__(SNODEmap self, std::map< std::string,YACS::ENGINE::ServiceNode * >::key_type const & key)"""
        return _pilot.SNODEmap___delitem__(self, key)

    def has_key(self, key):
        r"""has_key(SNODEmap self, std::map< std::string,YACS::ENGINE::ServiceNode * >::key_type const & key) -> bool"""
        return _pilot.SNODEmap_has_key(self, key)

    def keys(self):
        r"""keys(SNODEmap self) -> PyObject *"""
        return _pilot.SNODEmap_keys(self)

    def values(self):
        r"""values(SNODEmap self) -> PyObject *"""
        return _pilot.SNODEmap_values(self)

    def items(self):
        r"""items(SNODEmap self) -> PyObject *"""
        return _pilot.SNODEmap_items(self)

    def __contains__(self, key):
        r"""__contains__(SNODEmap self, std::map< std::string,YACS::ENGINE::ServiceNode * >::key_type const & key) -> bool"""
        return _pilot.SNODEmap___contains__(self, key)

    def key_iterator(self):
        r"""key_iterator(SNODEmap self) -> pilot_PySwigIterator"""
        return _pilot.SNODEmap_key_iterator(self)

    def value_iterator(self):
        r"""value_iterator(SNODEmap self) -> pilot_PySwigIterator"""
        return _pilot.SNODEmap_value_iterator(self)

    def __setitem__(self, *args):
        r"""
        __setitem__(SNODEmap self, std::map< std::string,YACS::ENGINE::ServiceNode * >::key_type const & key)
        __setitem__(SNODEmap self, std::map< std::string,YACS::ENGINE::ServiceNode * >::key_type const & key, ServiceNode x)
        """
        return _pilot.SNODEmap___setitem__(self, *args)

    def asdict(self):
        r"""asdict(SNODEmap self) -> PyObject *"""
        return _pilot.SNODEmap_asdict(self)

    def __init__(self, *args):
        r"""
        __init__(SNODEmap self, std::less< std::string > const & other) -> SNODEmap
        __init__(SNODEmap self) -> SNODEmap
        __init__(SNODEmap self, SNODEmap other) -> SNODEmap
        """
        _pilot.SNODEmap_swiginit(self, _pilot.new_SNODEmap(*args))

    def empty(self):
        r"""empty(SNODEmap self) -> bool"""
        return _pilot.SNODEmap_empty(self)

    def size(self):
        r"""size(SNODEmap self) -> std::map< std::string,YACS::ENGINE::ServiceNode * >::size_type"""
        return _pilot.SNODEmap_size(self)

    def swap(self, v):
        r"""swap(SNODEmap self, SNODEmap v)"""
        return _pilot.SNODEmap_swap(self, v)

    def begin(self):
        r"""begin(SNODEmap self) -> std::map< std::string,YACS::ENGINE::ServiceNode * >::iterator"""
        return _pilot.SNODEmap_begin(self)

    def end(self):
        r"""end(SNODEmap self) -> std::map< std::string,YACS::ENGINE::ServiceNode * >::iterator"""
        return _pilot.SNODEmap_end(self)

    def rbegin(self):
        r"""rbegin(SNODEmap self) -> std::map< std::string,YACS::ENGINE::ServiceNode * >::reverse_iterator"""
        return _pilot.SNODEmap_rbegin(self)

    def rend(self):
        r"""rend(SNODEmap self) -> std::map< std::string,YACS::ENGINE::ServiceNode * >::reverse_iterator"""
        return _pilot.SNODEmap_rend(self)

    def clear(self):
        r"""clear(SNODEmap self)"""
        return _pilot.SNODEmap_clear(self)

    def get_allocator(self):
        r"""get_allocator(SNODEmap self) -> std::map< std::string,YACS::ENGINE::ServiceNode * >::allocator_type"""
        return _pilot.SNODEmap_get_allocator(self)

    def count(self, x):
        r"""count(SNODEmap self, std::map< std::string,YACS::ENGINE::ServiceNode * >::key_type const & x) -> std::map< std::string,YACS::ENGINE::ServiceNode * >::size_type"""
        return _pilot.SNODEmap_count(self, x)

    def erase(self, *args):
        r"""
        erase(SNODEmap self, std::map< std::string,YACS::ENGINE::ServiceNode * >::key_type const & x) -> std::map< std::string,YACS::ENGINE::ServiceNode * >::size_type
        erase(SNODEmap self, std::map< std::string,YACS::ENGINE::ServiceNode * >::iterator position)
        erase(SNODEmap self, std::map< std::string,YACS::ENGINE::ServiceNode * >::iterator first, std::map< std::string,YACS::ENGINE::ServiceNode * >::iterator last)
        """
        return _pilot.SNODEmap_erase(self, *args)

    def find(self, x):
        r"""find(SNODEmap self, std::map< std::string,YACS::ENGINE::ServiceNode * >::key_type const & x) -> std::map< std::string,YACS::ENGINE::ServiceNode * >::iterator"""
        return _pilot.SNODEmap_find(self, x)

    def lower_bound(self, x):
        r"""lower_bound(SNODEmap self, std::map< std::string,YACS::ENGINE::ServiceNode * >::key_type const & x) -> std::map< std::string,YACS::ENGINE::ServiceNode * >::iterator"""
        return _pilot.SNODEmap_lower_bound(self, x)

    def upper_bound(self, x):
        r"""upper_bound(SNODEmap self, std::map< std::string,YACS::ENGINE::ServiceNode * >::key_type const & x) -> std::map< std::string,YACS::ENGINE::ServiceNode * >::iterator"""
        return _pilot.SNODEmap_upper_bound(self, x)
    __swig_destroy__ = _pilot.delete_SNODEmap

# Register SNODEmap in _pilot:
_pilot.SNODEmap_swigregister(SNODEmap)

class ItPy3Cont(object):
    r"""Proxy of C++ IteratorPy3< YACS::ENGINE::Container * > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, _cur, _end):
        r"""__init__(ItPy3Cont self, std::map< std::string,YACS::ENGINE::Container **,std::less< std::string >,std::allocator< std::pair< std::string const,YACS::ENGINE::Container ** > > >::iterator _cur, std::map< std::string,YACS::ENGINE::Container **,std::less< std::string >,std::allocator< std::pair< std::string const,YACS::ENGINE::Container ** > > >::iterator _end) -> ItPy3Cont"""
        _pilot.ItPy3Cont_swiginit(self, _pilot.new_ItPy3Cont(_cur, _end))
    __swig_destroy__ = _pilot.delete_ItPy3Cont

    def __iter__(self):
        r"""__iter__(ItPy3Cont self) -> ItPy3Cont"""
        return _pilot.ItPy3Cont___iter__(self)
    cur = property(_pilot.ItPy3Cont_cur_get, _pilot.ItPy3Cont_cur_set, doc=r"""cur : std::map<(std::string,p.p.YACS::ENGINE::Container,std::less<(std::string)>,std::allocator<(std::pair<(q(const).std::string,p.p.YACS::ENGINE::Container)>)>)>::iterator""")
    end = property(_pilot.ItPy3Cont_end_get, _pilot.ItPy3Cont_end_set, doc=r"""end : std::map<(std::string,p.p.YACS::ENGINE::Container,std::less<(std::string)>,std::allocator<(std::pair<(q(const).std::string,p.p.YACS::ENGINE::Container)>)>)>::iterator""")

# Register ItPy3Cont in _pilot:
_pilot.ItPy3Cont_swigregister(ItPy3Cont)

class CONTAINmapit(object):
    r"""Proxy of C++ IteratorPy3< YACS::ENGINE::Container > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, _cur, _end):
        r"""__init__(CONTAINmapit self, std::map< std::string,YACS::ENGINE::Container *,std::less< std::string >,std::allocator< std::pair< std::string const,YACS::ENGINE::Container * > > >::iterator _cur, std::map< std::string,YACS::ENGINE::Container *,std::less< std::string >,std::allocator< std::pair< std::string const,YACS::ENGINE::Container * > > >::iterator _end) -> CONTAINmapit"""
        _pilot.CONTAINmapit_swiginit(self, _pilot.new_CONTAINmapit(_cur, _end))
    __swig_destroy__ = _pilot.delete_CONTAINmapit

    def __iter__(self):
        r"""__iter__(CONTAINmapit self) -> CONTAINmapit"""
        return _pilot.CONTAINmapit___iter__(self)
    cur = property(_pilot.CONTAINmapit_cur_get, _pilot.CONTAINmapit_cur_set, doc=r"""cur : std::map<(std::string,p.YACS::ENGINE::Container,std::less<(std::string)>,std::allocator<(std::pair<(q(const).std::string,p.YACS::ENGINE::Container)>)>)>::iterator""")
    end = property(_pilot.CONTAINmapit_end_get, _pilot.CONTAINmapit_end_set, doc=r"""end : std::map<(std::string,p.YACS::ENGINE::Container,std::less<(std::string)>,std::allocator<(std::pair<(q(const).std::string,p.YACS::ENGINE::Container)>)>)>::iterator""")

    def __next__(self):
        r"""__next__(CONTAINmapit self) -> std::string"""
        return _pilot.CONTAINmapit___next__(self)

# Register CONTAINmapit in _pilot:
_pilot.CONTAINmapit_swigregister(CONTAINmapit)

class CONTAINmap(object):
    r"""Proxy of C++ std::map< std::string,YACS::ENGINE::Container * > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __setitem__(self, name, c):
        r"""__setitem__(CONTAINmap self, std::string const & name, Container c)"""
        return _pilot.CONTAINmap___setitem__(self, name, c)

    def __getitem__(self, name):
        r"""__getitem__(CONTAINmap self, std::string name) -> Container"""
        return _pilot.CONTAINmap___getitem__(self, name)

    def __delitem__(self, name):
        r"""__delitem__(CONTAINmap self, std::string name)"""
        return _pilot.CONTAINmap___delitem__(self, name)

    def keys(self):
        r"""keys(CONTAINmap self) -> PyObject *"""
        return _pilot.CONTAINmap_keys(self)

    def __iter__(self):
        r"""__iter__(CONTAINmap self) -> CONTAINmapit"""
        return _pilot.CONTAINmap___iter__(self)

    def __len__(self):
        r"""__len__(CONTAINmap self) -> int"""
        return _pilot.CONTAINmap___len__(self)

    def __init__(self):
        r"""__init__(CONTAINmap self) -> CONTAINmap"""
        _pilot.CONTAINmap_swiginit(self, _pilot.new_CONTAINmap())
    __swig_destroy__ = _pilot.delete_CONTAINmap

# Register CONTAINmap in _pilot:
_pilot.CONTAINmap_swigregister(CONTAINmap)


from collections.abc import MutableMapping
class CONTAINmap(CONTAINmap,MutableMapping):pass
import sys
def zeFunc( moduleName ):
  elt = moduleName.split(".")
  return ( ".".join( elt[:-1] + [ "_{}".format(elt[-1]) ] ) )
sys.modules[ zeFunc( __name__ ) ].CONTAINmap_swigregister(CONTAINmap)
del zeFunc

class strvec(object):
    r"""Proxy of C++ std::vector< std::string > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(strvec self) -> pilot_PySwigIterator"""
        return _pilot.strvec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(strvec self) -> bool"""
        return _pilot.strvec___nonzero__(self)

    def __bool__(self):
        r"""__bool__(strvec self) -> bool"""
        return _pilot.strvec___bool__(self)

    def __len__(self):
        r"""__len__(strvec self) -> std::vector< std::string >::size_type"""
        return _pilot.strvec___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(strvec self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j) -> strvec"""
        return _pilot.strvec___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(strvec self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j)
        __setslice__(strvec self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j, strvec v)
        """
        return _pilot.strvec___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(strvec self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j)"""
        return _pilot.strvec___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(strvec self, std::vector< std::string >::difference_type i)
        __delitem__(strvec self, PySliceObject * slice)
        """
        return _pilot.strvec___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(strvec self, PySliceObject * slice) -> strvec
        __getitem__(strvec self, std::vector< std::string >::difference_type i) -> std::vector< std::string >::value_type const &
        """
        return _pilot.strvec___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(strvec self, PySliceObject * slice, strvec v)
        __setitem__(strvec self, PySliceObject * slice)
        __setitem__(strvec self, std::vector< std::string >::difference_type i, std::vector< std::string >::value_type const & x)
        """
        return _pilot.strvec___setitem__(self, *args)

    def pop(self):
        r"""pop(strvec self) -> std::vector< std::string >::value_type"""
        return _pilot.strvec_pop(self)

    def append(self, x):
        r"""append(strvec self, std::vector< std::string >::value_type const & x)"""
        return _pilot.strvec_append(self, x)

    def empty(self):
        r"""empty(strvec self) -> bool"""
        return _pilot.strvec_empty(self)

    def size(self):
        r"""size(strvec self) -> std::vector< std::string >::size_type"""
        return _pilot.strvec_size(self)

    def swap(self, v):
        r"""swap(strvec self, strvec v)"""
        return _pilot.strvec_swap(self, v)

    def begin(self):
        r"""begin(strvec self) -> std::vector< std::string >::iterator"""
        return _pilot.strvec_begin(self)

    def end(self):
        r"""end(strvec self) -> std::vector< std::string >::iterator"""
        return _pilot.strvec_end(self)

    def rbegin(self):
        r"""rbegin(strvec self) -> std::vector< std::string >::reverse_iterator"""
        return _pilot.strvec_rbegin(self)

    def rend(self):
        r"""rend(strvec self) -> std::vector< std::string >::reverse_iterator"""
        return _pilot.strvec_rend(self)

    def clear(self):
        r"""clear(strvec self)"""
        return _pilot.strvec_clear(self)

    def get_allocator(self):
        r"""get_allocator(strvec self) -> std::vector< std::string >::allocator_type"""
        return _pilot.strvec_get_allocator(self)

    def pop_back(self):
        r"""pop_back(strvec self)"""
        return _pilot.strvec_pop_back(self)

    def erase(self, *args):
        r"""
        erase(strvec self, std::vector< std::string >::iterator pos) -> std::vector< std::string >::iterator
        erase(strvec self, std::vector< std::string >::iterator first, std::vector< std::string >::iterator last) -> std::vector< std::string >::iterator
        """
        return _pilot.strvec_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(strvec self) -> strvec
        __init__(strvec self, strvec other) -> strvec
        __init__(strvec self, std::vector< std::string >::size_type size) -> strvec
        __init__(strvec self, std::vector< std::string >::size_type size, std::vector< std::string >::value_type const & value) -> strvec
        """
        _pilot.strvec_swiginit(self, _pilot.new_strvec(*args))

    def push_back(self, x):
        r"""push_back(strvec self, std::vector< std::string >::value_type const & x)"""
        return _pilot.strvec_push_back(self, x)

    def front(self):
        r"""front(strvec self) -> std::vector< std::string >::value_type const &"""
        return _pilot.strvec_front(self)

    def back(self):
        r"""back(strvec self) -> std::vector< std::string >::value_type const &"""
        return _pilot.strvec_back(self)

    def assign(self, n, x):
        r"""assign(strvec self, std::vector< std::string >::size_type n, std::vector< std::string >::value_type const & x)"""
        return _pilot.strvec_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(strvec self, std::vector< std::string >::size_type new_size)
        resize(strvec self, std::vector< std::string >::size_type new_size, std::vector< std::string >::value_type const & x)
        """
        return _pilot.strvec_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(strvec self, std::vector< std::string >::iterator pos, std::vector< std::string >::value_type const & x) -> std::vector< std::string >::iterator
        insert(strvec self, std::vector< std::string >::iterator pos, std::vector< std::string >::size_type n, std::vector< std::string >::value_type const & x)
        """
        return _pilot.strvec_insert(self, *args)

    def reserve(self, n):
        r"""reserve(strvec self, std::vector< std::string >::size_type n)"""
        return _pilot.strvec_reserve(self, n)

    def capacity(self):
        r"""capacity(strvec self) -> std::vector< std::string >::size_type"""
        return _pilot.strvec_capacity(self)
    __swig_destroy__ = _pilot.delete_strvec

# Register strvec in _pilot:
_pilot.strvec_swigregister(strvec)

class uivec(object):
    r"""Proxy of C++ std::vector< unsigned int > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(uivec self) -> pilot_PySwigIterator"""
        return _pilot.uivec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(uivec self) -> bool"""
        return _pilot.uivec___nonzero__(self)

    def __bool__(self):
        r"""__bool__(uivec self) -> bool"""
        return _pilot.uivec___bool__(self)

    def __len__(self):
        r"""__len__(uivec self) -> std::vector< unsigned int >::size_type"""
        return _pilot.uivec___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(uivec self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j) -> uivec"""
        return _pilot.uivec___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(uivec self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j)
        __setslice__(uivec self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j, uivec v)
        """
        return _pilot.uivec___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(uivec self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j)"""
        return _pilot.uivec___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(uivec self, std::vector< unsigned int >::difference_type i)
        __delitem__(uivec self, PySliceObject * slice)
        """
        return _pilot.uivec___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(uivec self, PySliceObject * slice) -> uivec
        __getitem__(uivec self, std::vector< unsigned int >::difference_type i) -> std::vector< unsigned int >::value_type const &
        """
        return _pilot.uivec___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(uivec self, PySliceObject * slice, uivec v)
        __setitem__(uivec self, PySliceObject * slice)
        __setitem__(uivec self, std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::value_type const & x)
        """
        return _pilot.uivec___setitem__(self, *args)

    def pop(self):
        r"""pop(uivec self) -> std::vector< unsigned int >::value_type"""
        return _pilot.uivec_pop(self)

    def append(self, x):
        r"""append(uivec self, std::vector< unsigned int >::value_type const & x)"""
        return _pilot.uivec_append(self, x)

    def empty(self):
        r"""empty(uivec self) -> bool"""
        return _pilot.uivec_empty(self)

    def size(self):
        r"""size(uivec self) -> std::vector< unsigned int >::size_type"""
        return _pilot.uivec_size(self)

    def swap(self, v):
        r"""swap(uivec self, uivec v)"""
        return _pilot.uivec_swap(self, v)

    def begin(self):
        r"""begin(uivec self) -> std::vector< unsigned int >::iterator"""
        return _pilot.uivec_begin(self)

    def end(self):
        r"""end(uivec self) -> std::vector< unsigned int >::iterator"""
        return _pilot.uivec_end(self)

    def rbegin(self):
        r"""rbegin(uivec self) -> std::vector< unsigned int >::reverse_iterator"""
        return _pilot.uivec_rbegin(self)

    def rend(self):
        r"""rend(uivec self) -> std::vector< unsigned int >::reverse_iterator"""
        return _pilot.uivec_rend(self)

    def clear(self):
        r"""clear(uivec self)"""
        return _pilot.uivec_clear(self)

    def get_allocator(self):
        r"""get_allocator(uivec self) -> std::vector< unsigned int >::allocator_type"""
        return _pilot.uivec_get_allocator(self)

    def pop_back(self):
        r"""pop_back(uivec self)"""
        return _pilot.uivec_pop_back(self)

    def erase(self, *args):
        r"""
        erase(uivec self, std::vector< unsigned int >::iterator pos) -> std::vector< unsigned int >::iterator
        erase(uivec self, std::vector< unsigned int >::iterator first, std::vector< unsigned int >::iterator last) -> std::vector< unsigned int >::iterator
        """
        return _pilot.uivec_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(uivec self) -> uivec
        __init__(uivec self, uivec other) -> uivec
        __init__(uivec self, std::vector< unsigned int >::size_type size) -> uivec
        __init__(uivec self, std::vector< unsigned int >::size_type size, std::vector< unsigned int >::value_type const & value) -> uivec
        """
        _pilot.uivec_swiginit(self, _pilot.new_uivec(*args))

    def push_back(self, x):
        r"""push_back(uivec self, std::vector< unsigned int >::value_type const & x)"""
        return _pilot.uivec_push_back(self, x)

    def front(self):
        r"""front(uivec self) -> std::vector< unsigned int >::value_type const &"""
        return _pilot.uivec_front(self)

    def back(self):
        r"""back(uivec self) -> std::vector< unsigned int >::value_type const &"""
        return _pilot.uivec_back(self)

    def assign(self, n, x):
        r"""assign(uivec self, std::vector< unsigned int >::size_type n, std::vector< unsigned int >::value_type const & x)"""
        return _pilot.uivec_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(uivec self, std::vector< unsigned int >::size_type new_size)
        resize(uivec self, std::vector< unsigned int >::size_type new_size, std::vector< unsigned int >::value_type const & x)
        """
        return _pilot.uivec_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(uivec self, std::vector< unsigned int >::iterator pos, std::vector< unsigned int >::value_type const & x) -> std::vector< unsigned int >::iterator
        insert(uivec self, std::vector< unsigned int >::iterator pos, std::vector< unsigned int >::size_type n, std::vector< unsigned int >::value_type const & x)
        """
        return _pilot.uivec_insert(self, *args)

    def reserve(self, n):
        r"""reserve(uivec self, std::vector< unsigned int >::size_type n)"""
        return _pilot.uivec_reserve(self, n)

    def capacity(self):
        r"""capacity(uivec self) -> std::vector< unsigned int >::size_type"""
        return _pilot.uivec_capacity(self)
    __swig_destroy__ = _pilot.delete_uivec

# Register uivec in _pilot:
_pilot.uivec_swigregister(uivec)

class ivec(object):
    r"""Proxy of C++ std::vector< int > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(ivec self) -> pilot_PySwigIterator"""
        return _pilot.ivec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(ivec self) -> bool"""
        return _pilot.ivec___nonzero__(self)

    def __bool__(self):
        r"""__bool__(ivec self) -> bool"""
        return _pilot.ivec___bool__(self)

    def __len__(self):
        r"""__len__(ivec self) -> std::vector< int >::size_type"""
        return _pilot.ivec___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(ivec self, std::vector< int >::difference_type i, std::vector< int >::difference_type j) -> ivec"""
        return _pilot.ivec___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(ivec self, std::vector< int >::difference_type i, std::vector< int >::difference_type j)
        __setslice__(ivec self, std::vector< int >::difference_type i, std::vector< int >::difference_type j, ivec v)
        """
        return _pilot.ivec___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(ivec self, std::vector< int >::difference_type i, std::vector< int >::difference_type j)"""
        return _pilot.ivec___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(ivec self, std::vector< int >::difference_type i)
        __delitem__(ivec self, PySliceObject * slice)
        """
        return _pilot.ivec___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(ivec self, PySliceObject * slice) -> ivec
        __getitem__(ivec self, std::vector< int >::difference_type i) -> std::vector< int >::value_type const &
        """
        return _pilot.ivec___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(ivec self, PySliceObject * slice, ivec v)
        __setitem__(ivec self, PySliceObject * slice)
        __setitem__(ivec self, std::vector< int >::difference_type i, std::vector< int >::value_type const & x)
        """
        return _pilot.ivec___setitem__(self, *args)

    def pop(self):
        r"""pop(ivec self) -> std::vector< int >::value_type"""
        return _pilot.ivec_pop(self)

    def append(self, x):
        r"""append(ivec self, std::vector< int >::value_type const & x)"""
        return _pilot.ivec_append(self, x)

    def empty(self):
        r"""empty(ivec self) -> bool"""
        return _pilot.ivec_empty(self)

    def size(self):
        r"""size(ivec self) -> std::vector< int >::size_type"""
        return _pilot.ivec_size(self)

    def swap(self, v):
        r"""swap(ivec self, ivec v)"""
        return _pilot.ivec_swap(self, v)

    def begin(self):
        r"""begin(ivec self) -> std::vector< int >::iterator"""
        return _pilot.ivec_begin(self)

    def end(self):
        r"""end(ivec self) -> std::vector< int >::iterator"""
        return _pilot.ivec_end(self)

    def rbegin(self):
        r"""rbegin(ivec self) -> std::vector< int >::reverse_iterator"""
        return _pilot.ivec_rbegin(self)

    def rend(self):
        r"""rend(ivec self) -> std::vector< int >::reverse_iterator"""
        return _pilot.ivec_rend(self)

    def clear(self):
        r"""clear(ivec self)"""
        return _pilot.ivec_clear(self)

    def get_allocator(self):
        r"""get_allocator(ivec self) -> std::vector< int >::allocator_type"""
        return _pilot.ivec_get_allocator(self)

    def pop_back(self):
        r"""pop_back(ivec self)"""
        return _pilot.ivec_pop_back(self)

    def erase(self, *args):
        r"""
        erase(ivec self, std::vector< int >::iterator pos) -> std::vector< int >::iterator
        erase(ivec self, std::vector< int >::iterator first, std::vector< int >::iterator last) -> std::vector< int >::iterator
        """
        return _pilot.ivec_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(ivec self) -> ivec
        __init__(ivec self, ivec other) -> ivec
        __init__(ivec self, std::vector< int >::size_type size) -> ivec
        __init__(ivec self, std::vector< int >::size_type size, std::vector< int >::value_type const & value) -> ivec
        """
        _pilot.ivec_swiginit(self, _pilot.new_ivec(*args))

    def push_back(self, x):
        r"""push_back(ivec self, std::vector< int >::value_type const & x)"""
        return _pilot.ivec_push_back(self, x)

    def front(self):
        r"""front(ivec self) -> std::vector< int >::value_type const &"""
        return _pilot.ivec_front(self)

    def back(self):
        r"""back(ivec self) -> std::vector< int >::value_type const &"""
        return _pilot.ivec_back(self)

    def assign(self, n, x):
        r"""assign(ivec self, std::vector< int >::size_type n, std::vector< int >::value_type const & x)"""
        return _pilot.ivec_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(ivec self, std::vector< int >::size_type new_size)
        resize(ivec self, std::vector< int >::size_type new_size, std::vector< int >::value_type const & x)
        """
        return _pilot.ivec_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(ivec self, std::vector< int >::iterator pos, std::vector< int >::value_type const & x) -> std::vector< int >::iterator
        insert(ivec self, std::vector< int >::iterator pos, std::vector< int >::size_type n, std::vector< int >::value_type const & x)
        """
        return _pilot.ivec_insert(self, *args)

    def reserve(self, n):
        r"""reserve(ivec self, std::vector< int >::size_type n)"""
        return _pilot.ivec_reserve(self, n)

    def capacity(self):
        r"""capacity(ivec self) -> std::vector< int >::size_type"""
        return _pilot.ivec_capacity(self)
    __swig_destroy__ = _pilot.delete_ivec

# Register ivec in _pilot:
_pilot.ivec_swigregister(ivec)

class linksvec(object):
    r"""Proxy of C++ std::vector< std::pair< YACS::ENGINE::OutPort *,YACS::ENGINE::InPort * > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(linksvec self) -> pilot_PySwigIterator"""
        return _pilot.linksvec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(linksvec self) -> bool"""
        return _pilot.linksvec___nonzero__(self)

    def __bool__(self):
        r"""__bool__(linksvec self) -> bool"""
        return _pilot.linksvec___bool__(self)

    def __len__(self):
        r"""__len__(linksvec self) -> std::vector< std::pair< YACS::ENGINE::OutPort *,YACS::ENGINE::InPort * > >::size_type"""
        return _pilot.linksvec___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(linksvec self, std::vector< std::pair< YACS::ENGINE::OutPort *,YACS::ENGINE::InPort * > >::difference_type i, std::vector< std::pair< YACS::ENGINE::OutPort *,YACS::ENGINE::InPort * > >::difference_type j) -> linksvec"""
        return _pilot.linksvec___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(linksvec self, std::vector< std::pair< YACS::ENGINE::OutPort *,YACS::ENGINE::InPort * > >::difference_type i, std::vector< std::pair< YACS::ENGINE::OutPort *,YACS::ENGINE::InPort * > >::difference_type j)
        __setslice__(linksvec self, std::vector< std::pair< YACS::ENGINE::OutPort *,YACS::ENGINE::InPort * > >::difference_type i, std::vector< std::pair< YACS::ENGINE::OutPort *,YACS::ENGINE::InPort * > >::difference_type j, linksvec v)
        """
        return _pilot.linksvec___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(linksvec self, std::vector< std::pair< YACS::ENGINE::OutPort *,YACS::ENGINE::InPort * > >::difference_type i, std::vector< std::pair< YACS::ENGINE::OutPort *,YACS::ENGINE::InPort * > >::difference_type j)"""
        return _pilot.linksvec___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(linksvec self, std::vector< std::pair< YACS::ENGINE::OutPort *,YACS::ENGINE::InPort * > >::difference_type i)
        __delitem__(linksvec self, PySliceObject * slice)
        """
        return _pilot.linksvec___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(linksvec self, PySliceObject * slice) -> linksvec
        __getitem__(linksvec self, std::vector< std::pair< YACS::ENGINE::OutPort *,YACS::ENGINE::InPort * > >::difference_type i) -> std::vector< std::pair< YACS::ENGINE::OutPort *,YACS::ENGINE::InPort * > >::value_type const &
        """
        return _pilot.linksvec___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(linksvec self, PySliceObject * slice, linksvec v)
        __setitem__(linksvec self, PySliceObject * slice)
        __setitem__(linksvec self, std::vector< std::pair< YACS::ENGINE::OutPort *,YACS::ENGINE::InPort * > >::difference_type i, std::vector< std::pair< YACS::ENGINE::OutPort *,YACS::ENGINE::InPort * > >::value_type const & x)
        """
        return _pilot.linksvec___setitem__(self, *args)

    def pop(self):
        r"""pop(linksvec self) -> std::vector< std::pair< YACS::ENGINE::OutPort *,YACS::ENGINE::InPort * > >::value_type"""
        return _pilot.linksvec_pop(self)

    def append(self, x):
        r"""append(linksvec self, std::vector< std::pair< YACS::ENGINE::OutPort *,YACS::ENGINE::InPort * > >::value_type const & x)"""
        return _pilot.linksvec_append(self, x)

    def empty(self):
        r"""empty(linksvec self) -> bool"""
        return _pilot.linksvec_empty(self)

    def size(self):
        r"""size(linksvec self) -> std::vector< std::pair< YACS::ENGINE::OutPort *,YACS::ENGINE::InPort * > >::size_type"""
        return _pilot.linksvec_size(self)

    def swap(self, v):
        r"""swap(linksvec self, linksvec v)"""
        return _pilot.linksvec_swap(self, v)

    def begin(self):
        r"""begin(linksvec self) -> std::vector< std::pair< YACS::ENGINE::OutPort *,YACS::ENGINE::InPort * > >::iterator"""
        return _pilot.linksvec_begin(self)

    def end(self):
        r"""end(linksvec self) -> std::vector< std::pair< YACS::ENGINE::OutPort *,YACS::ENGINE::InPort * > >::iterator"""
        return _pilot.linksvec_end(self)

    def rbegin(self):
        r"""rbegin(linksvec self) -> std::vector< std::pair< YACS::ENGINE::OutPort *,YACS::ENGINE::InPort * > >::reverse_iterator"""
        return _pilot.linksvec_rbegin(self)

    def rend(self):
        r"""rend(linksvec self) -> std::vector< std::pair< YACS::ENGINE::OutPort *,YACS::ENGINE::InPort * > >::reverse_iterator"""
        return _pilot.linksvec_rend(self)

    def clear(self):
        r"""clear(linksvec self)"""
        return _pilot.linksvec_clear(self)

    def get_allocator(self):
        r"""get_allocator(linksvec self) -> std::vector< std::pair< YACS::ENGINE::OutPort *,YACS::ENGINE::InPort * > >::allocator_type"""
        return _pilot.linksvec_get_allocator(self)

    def pop_back(self):
        r"""pop_back(linksvec self)"""
        return _pilot.linksvec_pop_back(self)

    def erase(self, *args):
        r"""
        erase(linksvec self, std::vector< std::pair< YACS::ENGINE::OutPort *,YACS::ENGINE::InPort * > >::iterator pos) -> std::vector< std::pair< YACS::ENGINE::OutPort *,YACS::ENGINE::InPort * > >::iterator
        erase(linksvec self, std::vector< std::pair< YACS::ENGINE::OutPort *,YACS::ENGINE::InPort * > >::iterator first, std::vector< std::pair< YACS::ENGINE::OutPort *,YACS::ENGINE::InPort * > >::iterator last) -> std::vector< std::pair< YACS::ENGINE::OutPort *,YACS::ENGINE::InPort * > >::iterator
        """
        return _pilot.linksvec_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(linksvec self) -> linksvec
        __init__(linksvec self, linksvec other) -> linksvec
        __init__(linksvec self, std::vector< std::pair< YACS::ENGINE::OutPort *,YACS::ENGINE::InPort * > >::size_type size) -> linksvec
        __init__(linksvec self, std::vector< std::pair< YACS::ENGINE::OutPort *,YACS::ENGINE::InPort * > >::size_type size, std::vector< std::pair< YACS::ENGINE::OutPort *,YACS::ENGINE::InPort * > >::value_type const & value) -> linksvec
        """
        _pilot.linksvec_swiginit(self, _pilot.new_linksvec(*args))

    def push_back(self, x):
        r"""push_back(linksvec self, std::vector< std::pair< YACS::ENGINE::OutPort *,YACS::ENGINE::InPort * > >::value_type const & x)"""
        return _pilot.linksvec_push_back(self, x)

    def front(self):
        r"""front(linksvec self) -> std::vector< std::pair< YACS::ENGINE::OutPort *,YACS::ENGINE::InPort * > >::value_type const &"""
        return _pilot.linksvec_front(self)

    def back(self):
        r"""back(linksvec self) -> std::vector< std::pair< YACS::ENGINE::OutPort *,YACS::ENGINE::InPort * > >::value_type const &"""
        return _pilot.linksvec_back(self)

    def assign(self, n, x):
        r"""assign(linksvec self, std::vector< std::pair< YACS::ENGINE::OutPort *,YACS::ENGINE::InPort * > >::size_type n, std::vector< std::pair< YACS::ENGINE::OutPort *,YACS::ENGINE::InPort * > >::value_type const & x)"""
        return _pilot.linksvec_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(linksvec self, std::vector< std::pair< YACS::ENGINE::OutPort *,YACS::ENGINE::InPort * > >::size_type new_size)
        resize(linksvec self, std::vector< std::pair< YACS::ENGINE::OutPort *,YACS::ENGINE::InPort * > >::size_type new_size, std::vector< std::pair< YACS::ENGINE::OutPort *,YACS::ENGINE::InPort * > >::value_type const & x)
        """
        return _pilot.linksvec_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(linksvec self, std::vector< std::pair< YACS::ENGINE::OutPort *,YACS::ENGINE::InPort * > >::iterator pos, std::vector< std::pair< YACS::ENGINE::OutPort *,YACS::ENGINE::InPort * > >::value_type const & x) -> std::vector< std::pair< YACS::ENGINE::OutPort *,YACS::ENGINE::InPort * > >::iterator
        insert(linksvec self, std::vector< std::pair< YACS::ENGINE::OutPort *,YACS::ENGINE::InPort * > >::iterator pos, std::vector< std::pair< YACS::ENGINE::OutPort *,YACS::ENGINE::InPort * > >::size_type n, std::vector< std::pair< YACS::ENGINE::OutPort *,YACS::ENGINE::InPort * > >::value_type const & x)
        """
        return _pilot.linksvec_insert(self, *args)

    def reserve(self, n):
        r"""reserve(linksvec self, std::vector< std::pair< YACS::ENGINE::OutPort *,YACS::ENGINE::InPort * > >::size_type n)"""
        return _pilot.linksvec_reserve(self, n)

    def capacity(self):
        r"""capacity(linksvec self) -> std::vector< std::pair< YACS::ENGINE::OutPort *,YACS::ENGINE::InPort * > >::size_type"""
        return _pilot.linksvec_capacity(self)
    __swig_destroy__ = _pilot.delete_linksvec

# Register linksvec in _pilot:
_pilot.linksvec_swigregister(linksvec)

class linkvec(object):
    r"""Proxy of C++ std::vector< std::pair< YACS::ENGINE::InPort *,YACS::ENGINE::OutPort * > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(linkvec self) -> pilot_PySwigIterator"""
        return _pilot.linkvec_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(linkvec self) -> bool"""
        return _pilot.linkvec___nonzero__(self)

    def __bool__(self):
        r"""__bool__(linkvec self) -> bool"""
        return _pilot.linkvec___bool__(self)

    def __len__(self):
        r"""__len__(linkvec self) -> std::vector< std::pair< YACS::ENGINE::InPort *,YACS::ENGINE::OutPort * > >::size_type"""
        return _pilot.linkvec___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(linkvec self, std::vector< std::pair< YACS::ENGINE::InPort *,YACS::ENGINE::OutPort * > >::difference_type i, std::vector< std::pair< YACS::ENGINE::InPort *,YACS::ENGINE::OutPort * > >::difference_type j) -> linkvec"""
        return _pilot.linkvec___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(linkvec self, std::vector< std::pair< YACS::ENGINE::InPort *,YACS::ENGINE::OutPort * > >::difference_type i, std::vector< std::pair< YACS::ENGINE::InPort *,YACS::ENGINE::OutPort * > >::difference_type j)
        __setslice__(linkvec self, std::vector< std::pair< YACS::ENGINE::InPort *,YACS::ENGINE::OutPort * > >::difference_type i, std::vector< std::pair< YACS::ENGINE::InPort *,YACS::ENGINE::OutPort * > >::difference_type j, linkvec v)
        """
        return _pilot.linkvec___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(linkvec self, std::vector< std::pair< YACS::ENGINE::InPort *,YACS::ENGINE::OutPort * > >::difference_type i, std::vector< std::pair< YACS::ENGINE::InPort *,YACS::ENGINE::OutPort * > >::difference_type j)"""
        return _pilot.linkvec___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(linkvec self, std::vector< std::pair< YACS::ENGINE::InPort *,YACS::ENGINE::OutPort * > >::difference_type i)
        __delitem__(linkvec self, PySliceObject * slice)
        """
        return _pilot.linkvec___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(linkvec self, PySliceObject * slice) -> linkvec
        __getitem__(linkvec self, std::vector< std::pair< YACS::ENGINE::InPort *,YACS::ENGINE::OutPort * > >::difference_type i) -> std::vector< std::pair< YACS::ENGINE::InPort *,YACS::ENGINE::OutPort * > >::value_type const &
        """
        return _pilot.linkvec___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(linkvec self, PySliceObject * slice, linkvec v)
        __setitem__(linkvec self, PySliceObject * slice)
        __setitem__(linkvec self, std::vector< std::pair< YACS::ENGINE::InPort *,YACS::ENGINE::OutPort * > >::difference_type i, std::vector< std::pair< YACS::ENGINE::InPort *,YACS::ENGINE::OutPort * > >::value_type const & x)
        """
        return _pilot.linkvec___setitem__(self, *args)

    def pop(self):
        r"""pop(linkvec self) -> std::vector< std::pair< YACS::ENGINE::InPort *,YACS::ENGINE::OutPort * > >::value_type"""
        return _pilot.linkvec_pop(self)

    def append(self, x):
        r"""append(linkvec self, std::vector< std::pair< YACS::ENGINE::InPort *,YACS::ENGINE::OutPort * > >::value_type const & x)"""
        return _pilot.linkvec_append(self, x)

    def empty(self):
        r"""empty(linkvec self) -> bool"""
        return _pilot.linkvec_empty(self)

    def size(self):
        r"""size(linkvec self) -> std::vector< std::pair< YACS::ENGINE::InPort *,YACS::ENGINE::OutPort * > >::size_type"""
        return _pilot.linkvec_size(self)

    def swap(self, v):
        r"""swap(linkvec self, linkvec v)"""
        return _pilot.linkvec_swap(self, v)

    def begin(self):
        r"""begin(linkvec self) -> std::vector< std::pair< YACS::ENGINE::InPort *,YACS::ENGINE::OutPort * > >::iterator"""
        return _pilot.linkvec_begin(self)

    def end(self):
        r"""end(linkvec self) -> std::vector< std::pair< YACS::ENGINE::InPort *,YACS::ENGINE::OutPort * > >::iterator"""
        return _pilot.linkvec_end(self)

    def rbegin(self):
        r"""rbegin(linkvec self) -> std::vector< std::pair< YACS::ENGINE::InPort *,YACS::ENGINE::OutPort * > >::reverse_iterator"""
        return _pilot.linkvec_rbegin(self)

    def rend(self):
        r"""rend(linkvec self) -> std::vector< std::pair< YACS::ENGINE::InPort *,YACS::ENGINE::OutPort * > >::reverse_iterator"""
        return _pilot.linkvec_rend(self)

    def clear(self):
        r"""clear(linkvec self)"""
        return _pilot.linkvec_clear(self)

    def get_allocator(self):
        r"""get_allocator(linkvec self) -> std::vector< std::pair< YACS::ENGINE::InPort *,YACS::ENGINE::OutPort * > >::allocator_type"""
        return _pilot.linkvec_get_allocator(self)

    def pop_back(self):
        r"""pop_back(linkvec self)"""
        return _pilot.linkvec_pop_back(self)

    def erase(self, *args):
        r"""
        erase(linkvec self, std::vector< std::pair< YACS::ENGINE::InPort *,YACS::ENGINE::OutPort * > >::iterator pos) -> std::vector< std::pair< YACS::ENGINE::InPort *,YACS::ENGINE::OutPort * > >::iterator
        erase(linkvec self, std::vector< std::pair< YACS::ENGINE::InPort *,YACS::ENGINE::OutPort * > >::iterator first, std::vector< std::pair< YACS::ENGINE::InPort *,YACS::ENGINE::OutPort * > >::iterator last) -> std::vector< std::pair< YACS::ENGINE::InPort *,YACS::ENGINE::OutPort * > >::iterator
        """
        return _pilot.linkvec_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(linkvec self) -> linkvec
        __init__(linkvec self, linkvec other) -> linkvec
        __init__(linkvec self, std::vector< std::pair< YACS::ENGINE::InPort *,YACS::ENGINE::OutPort * > >::size_type size) -> linkvec
        __init__(linkvec self, std::vector< std::pair< YACS::ENGINE::InPort *,YACS::ENGINE::OutPort * > >::size_type size, std::vector< std::pair< YACS::ENGINE::InPort *,YACS::ENGINE::OutPort * > >::value_type const & value) -> linkvec
        """
        _pilot.linkvec_swiginit(self, _pilot.new_linkvec(*args))

    def push_back(self, x):
        r"""push_back(linkvec self, std::vector< std::pair< YACS::ENGINE::InPort *,YACS::ENGINE::OutPort * > >::value_type const & x)"""
        return _pilot.linkvec_push_back(self, x)

    def front(self):
        r"""front(linkvec self) -> std::vector< std::pair< YACS::ENGINE::InPort *,YACS::ENGINE::OutPort * > >::value_type const &"""
        return _pilot.linkvec_front(self)

    def back(self):
        r"""back(linkvec self) -> std::vector< std::pair< YACS::ENGINE::InPort *,YACS::ENGINE::OutPort * > >::value_type const &"""
        return _pilot.linkvec_back(self)

    def assign(self, n, x):
        r"""assign(linkvec self, std::vector< std::pair< YACS::ENGINE::InPort *,YACS::ENGINE::OutPort * > >::size_type n, std::vector< std::pair< YACS::ENGINE::InPort *,YACS::ENGINE::OutPort * > >::value_type const & x)"""
        return _pilot.linkvec_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(linkvec self, std::vector< std::pair< YACS::ENGINE::InPort *,YACS::ENGINE::OutPort * > >::size_type new_size)
        resize(linkvec self, std::vector< std::pair< YACS::ENGINE::InPort *,YACS::ENGINE::OutPort * > >::size_type new_size, std::vector< std::pair< YACS::ENGINE::InPort *,YACS::ENGINE::OutPort * > >::value_type const & x)
        """
        return _pilot.linkvec_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(linkvec self, std::vector< std::pair< YACS::ENGINE::InPort *,YACS::ENGINE::OutPort * > >::iterator pos, std::vector< std::pair< YACS::ENGINE::InPort *,YACS::ENGINE::OutPort * > >::value_type const & x) -> std::vector< std::pair< YACS::ENGINE::InPort *,YACS::ENGINE::OutPort * > >::iterator
        insert(linkvec self, std::vector< std::pair< YACS::ENGINE::InPort *,YACS::ENGINE::OutPort * > >::iterator pos, std::vector< std::pair< YACS::ENGINE::InPort *,YACS::ENGINE::OutPort * > >::size_type n, std::vector< std::pair< YACS::ENGINE::InPort *,YACS::ENGINE::OutPort * > >::value_type const & x)
        """
        return _pilot.linkvec_insert(self, *args)

    def reserve(self, n):
        r"""reserve(linkvec self, std::vector< std::pair< YACS::ENGINE::InPort *,YACS::ENGINE::OutPort * > >::size_type n)"""
        return _pilot.linkvec_reserve(self, n)

    def capacity(self):
        r"""capacity(linkvec self) -> std::vector< std::pair< YACS::ENGINE::InPort *,YACS::ENGINE::OutPort * > >::size_type"""
        return _pilot.linkvec_capacity(self)
    __swig_destroy__ = _pilot.delete_linkvec

# Register linkvec in _pilot:
_pilot.linkvec_swigregister(linkvec)

class instreamlist(object):
    r"""Proxy of C++ std::list< YACS::ENGINE::InputDataStreamPort * > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(instreamlist self) -> pilot_PySwigIterator"""
        return _pilot.instreamlist_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(instreamlist self) -> bool"""
        return _pilot.instreamlist___nonzero__(self)

    def __bool__(self):
        r"""__bool__(instreamlist self) -> bool"""
        return _pilot.instreamlist___bool__(self)

    def __len__(self):
        r"""__len__(instreamlist self) -> std::list< YACS::ENGINE::InputDataStreamPort * >::size_type"""
        return _pilot.instreamlist___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(instreamlist self, std::list< YACS::ENGINE::InputDataStreamPort * >::difference_type i, std::list< YACS::ENGINE::InputDataStreamPort * >::difference_type j) -> instreamlist"""
        return _pilot.instreamlist___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(instreamlist self, std::list< YACS::ENGINE::InputDataStreamPort * >::difference_type i, std::list< YACS::ENGINE::InputDataStreamPort * >::difference_type j)
        __setslice__(instreamlist self, std::list< YACS::ENGINE::InputDataStreamPort * >::difference_type i, std::list< YACS::ENGINE::InputDataStreamPort * >::difference_type j, instreamlist v)
        """
        return _pilot.instreamlist___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(instreamlist self, std::list< YACS::ENGINE::InputDataStreamPort * >::difference_type i, std::list< YACS::ENGINE::InputDataStreamPort * >::difference_type j)"""
        return _pilot.instreamlist___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(instreamlist self, std::list< YACS::ENGINE::InputDataStreamPort * >::difference_type i)
        __delitem__(instreamlist self, PySliceObject * slice)
        """
        return _pilot.instreamlist___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(instreamlist self, PySliceObject * slice) -> instreamlist
        __getitem__(instreamlist self, std::list< YACS::ENGINE::InputDataStreamPort * >::difference_type i) -> InputDataStreamPort
        """
        return _pilot.instreamlist___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(instreamlist self, PySliceObject * slice, instreamlist v)
        __setitem__(instreamlist self, PySliceObject * slice)
        __setitem__(instreamlist self, std::list< YACS::ENGINE::InputDataStreamPort * >::difference_type i, InputDataStreamPort x)
        """
        return _pilot.instreamlist___setitem__(self, *args)

    def pop(self):
        r"""pop(instreamlist self) -> InputDataStreamPort"""
        return _pilot.instreamlist_pop(self)

    def append(self, x):
        r"""append(instreamlist self, InputDataStreamPort x)"""
        return _pilot.instreamlist_append(self, x)

    def empty(self):
        r"""empty(instreamlist self) -> bool"""
        return _pilot.instreamlist_empty(self)

    def size(self):
        r"""size(instreamlist self) -> std::list< YACS::ENGINE::InputDataStreamPort * >::size_type"""
        return _pilot.instreamlist_size(self)

    def swap(self, v):
        r"""swap(instreamlist self, instreamlist v)"""
        return _pilot.instreamlist_swap(self, v)

    def begin(self):
        r"""begin(instreamlist self) -> std::list< YACS::ENGINE::InputDataStreamPort * >::iterator"""
        return _pilot.instreamlist_begin(self)

    def end(self):
        r"""end(instreamlist self) -> std::list< YACS::ENGINE::InputDataStreamPort * >::iterator"""
        return _pilot.instreamlist_end(self)

    def rbegin(self):
        r"""rbegin(instreamlist self) -> std::list< YACS::ENGINE::InputDataStreamPort * >::reverse_iterator"""
        return _pilot.instreamlist_rbegin(self)

    def rend(self):
        r"""rend(instreamlist self) -> std::list< YACS::ENGINE::InputDataStreamPort * >::reverse_iterator"""
        return _pilot.instreamlist_rend(self)

    def clear(self):
        r"""clear(instreamlist self)"""
        return _pilot.instreamlist_clear(self)

    def get_allocator(self):
        r"""get_allocator(instreamlist self) -> std::list< YACS::ENGINE::InputDataStreamPort * >::allocator_type"""
        return _pilot.instreamlist_get_allocator(self)

    def pop_back(self):
        r"""pop_back(instreamlist self)"""
        return _pilot.instreamlist_pop_back(self)

    def erase(self, *args):
        r"""
        erase(instreamlist self, std::list< YACS::ENGINE::InputDataStreamPort * >::iterator pos) -> std::list< YACS::ENGINE::InputDataStreamPort * >::iterator
        erase(instreamlist self, std::list< YACS::ENGINE::InputDataStreamPort * >::iterator first, std::list< YACS::ENGINE::InputDataStreamPort * >::iterator last) -> std::list< YACS::ENGINE::InputDataStreamPort * >::iterator
        """
        return _pilot.instreamlist_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(instreamlist self) -> instreamlist
        __init__(instreamlist self, instreamlist other) -> instreamlist
        __init__(instreamlist self, std::list< YACS::ENGINE::InputDataStreamPort * >::size_type size) -> instreamlist
        __init__(instreamlist self, std::list< YACS::ENGINE::InputDataStreamPort * >::size_type size, InputDataStreamPort value) -> instreamlist
        """
        _pilot.instreamlist_swiginit(self, _pilot.new_instreamlist(*args))

    def push_back(self, x):
        r"""push_back(instreamlist self, InputDataStreamPort x)"""
        return _pilot.instreamlist_push_back(self, x)

    def front(self):
        r"""front(instreamlist self) -> InputDataStreamPort"""
        return _pilot.instreamlist_front(self)

    def back(self):
        r"""back(instreamlist self) -> InputDataStreamPort"""
        return _pilot.instreamlist_back(self)

    def assign(self, n, x):
        r"""assign(instreamlist self, std::list< YACS::ENGINE::InputDataStreamPort * >::size_type n, InputDataStreamPort x)"""
        return _pilot.instreamlist_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(instreamlist self, std::list< YACS::ENGINE::InputDataStreamPort * >::size_type new_size)
        resize(instreamlist self, std::list< YACS::ENGINE::InputDataStreamPort * >::size_type new_size, InputDataStreamPort x)
        """
        return _pilot.instreamlist_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(instreamlist self, std::list< YACS::ENGINE::InputDataStreamPort * >::iterator pos, InputDataStreamPort x) -> std::list< YACS::ENGINE::InputDataStreamPort * >::iterator
        insert(instreamlist self, std::list< YACS::ENGINE::InputDataStreamPort * >::iterator pos, std::list< YACS::ENGINE::InputDataStreamPort * >::size_type n, InputDataStreamPort x)
        """
        return _pilot.instreamlist_insert(self, *args)

    def pop_front(self):
        r"""pop_front(instreamlist self)"""
        return _pilot.instreamlist_pop_front(self)

    def push_front(self, x):
        r"""push_front(instreamlist self, InputDataStreamPort x)"""
        return _pilot.instreamlist_push_front(self, x)

    def remove(self, x):
        r"""remove(instreamlist self, InputDataStreamPort x)"""
        return _pilot.instreamlist_remove(self, x)

    def unique(self):
        r"""unique(instreamlist self)"""
        return _pilot.instreamlist_unique(self)

    def reverse(self):
        r"""reverse(instreamlist self)"""
        return _pilot.instreamlist_reverse(self)

    def sort(self):
        r"""sort(instreamlist self)"""
        return _pilot.instreamlist_sort(self)

    def merge(self, x):
        r"""merge(instreamlist self, instreamlist x)"""
        return _pilot.instreamlist_merge(self, x)
    __swig_destroy__ = _pilot.delete_instreamlist

# Register instreamlist in _pilot:
_pilot.instreamlist_swigregister(instreamlist)

class outstreamlist(object):
    r"""Proxy of C++ std::list< YACS::ENGINE::OutputDataStreamPort * > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(outstreamlist self) -> pilot_PySwigIterator"""
        return _pilot.outstreamlist_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(outstreamlist self) -> bool"""
        return _pilot.outstreamlist___nonzero__(self)

    def __bool__(self):
        r"""__bool__(outstreamlist self) -> bool"""
        return _pilot.outstreamlist___bool__(self)

    def __len__(self):
        r"""__len__(outstreamlist self) -> std::list< YACS::ENGINE::OutputDataStreamPort * >::size_type"""
        return _pilot.outstreamlist___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(outstreamlist self, std::list< YACS::ENGINE::OutputDataStreamPort * >::difference_type i, std::list< YACS::ENGINE::OutputDataStreamPort * >::difference_type j) -> outstreamlist"""
        return _pilot.outstreamlist___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(outstreamlist self, std::list< YACS::ENGINE::OutputDataStreamPort * >::difference_type i, std::list< YACS::ENGINE::OutputDataStreamPort * >::difference_type j)
        __setslice__(outstreamlist self, std::list< YACS::ENGINE::OutputDataStreamPort * >::difference_type i, std::list< YACS::ENGINE::OutputDataStreamPort * >::difference_type j, outstreamlist v)
        """
        return _pilot.outstreamlist___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(outstreamlist self, std::list< YACS::ENGINE::OutputDataStreamPort * >::difference_type i, std::list< YACS::ENGINE::OutputDataStreamPort * >::difference_type j)"""
        return _pilot.outstreamlist___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(outstreamlist self, std::list< YACS::ENGINE::OutputDataStreamPort * >::difference_type i)
        __delitem__(outstreamlist self, PySliceObject * slice)
        """
        return _pilot.outstreamlist___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(outstreamlist self, PySliceObject * slice) -> outstreamlist
        __getitem__(outstreamlist self, std::list< YACS::ENGINE::OutputDataStreamPort * >::difference_type i) -> OutputDataStreamPort
        """
        return _pilot.outstreamlist___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(outstreamlist self, PySliceObject * slice, outstreamlist v)
        __setitem__(outstreamlist self, PySliceObject * slice)
        __setitem__(outstreamlist self, std::list< YACS::ENGINE::OutputDataStreamPort * >::difference_type i, OutputDataStreamPort x)
        """
        return _pilot.outstreamlist___setitem__(self, *args)

    def pop(self):
        r"""pop(outstreamlist self) -> OutputDataStreamPort"""
        return _pilot.outstreamlist_pop(self)

    def append(self, x):
        r"""append(outstreamlist self, OutputDataStreamPort x)"""
        return _pilot.outstreamlist_append(self, x)

    def empty(self):
        r"""empty(outstreamlist self) -> bool"""
        return _pilot.outstreamlist_empty(self)

    def size(self):
        r"""size(outstreamlist self) -> std::list< YACS::ENGINE::OutputDataStreamPort * >::size_type"""
        return _pilot.outstreamlist_size(self)

    def swap(self, v):
        r"""swap(outstreamlist self, outstreamlist v)"""
        return _pilot.outstreamlist_swap(self, v)

    def begin(self):
        r"""begin(outstreamlist self) -> std::list< YACS::ENGINE::OutputDataStreamPort * >::iterator"""
        return _pilot.outstreamlist_begin(self)

    def end(self):
        r"""end(outstreamlist self) -> std::list< YACS::ENGINE::OutputDataStreamPort * >::iterator"""
        return _pilot.outstreamlist_end(self)

    def rbegin(self):
        r"""rbegin(outstreamlist self) -> std::list< YACS::ENGINE::OutputDataStreamPort * >::reverse_iterator"""
        return _pilot.outstreamlist_rbegin(self)

    def rend(self):
        r"""rend(outstreamlist self) -> std::list< YACS::ENGINE::OutputDataStreamPort * >::reverse_iterator"""
        return _pilot.outstreamlist_rend(self)

    def clear(self):
        r"""clear(outstreamlist self)"""
        return _pilot.outstreamlist_clear(self)

    def get_allocator(self):
        r"""get_allocator(outstreamlist self) -> std::list< YACS::ENGINE::OutputDataStreamPort * >::allocator_type"""
        return _pilot.outstreamlist_get_allocator(self)

    def pop_back(self):
        r"""pop_back(outstreamlist self)"""
        return _pilot.outstreamlist_pop_back(self)

    def erase(self, *args):
        r"""
        erase(outstreamlist self, std::list< YACS::ENGINE::OutputDataStreamPort * >::iterator pos) -> std::list< YACS::ENGINE::OutputDataStreamPort * >::iterator
        erase(outstreamlist self, std::list< YACS::ENGINE::OutputDataStreamPort * >::iterator first, std::list< YACS::ENGINE::OutputDataStreamPort * >::iterator last) -> std::list< YACS::ENGINE::OutputDataStreamPort * >::iterator
        """
        return _pilot.outstreamlist_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(outstreamlist self) -> outstreamlist
        __init__(outstreamlist self, outstreamlist other) -> outstreamlist
        __init__(outstreamlist self, std::list< YACS::ENGINE::OutputDataStreamPort * >::size_type size) -> outstreamlist
        __init__(outstreamlist self, std::list< YACS::ENGINE::OutputDataStreamPort * >::size_type size, OutputDataStreamPort value) -> outstreamlist
        """
        _pilot.outstreamlist_swiginit(self, _pilot.new_outstreamlist(*args))

    def push_back(self, x):
        r"""push_back(outstreamlist self, OutputDataStreamPort x)"""
        return _pilot.outstreamlist_push_back(self, x)

    def front(self):
        r"""front(outstreamlist self) -> OutputDataStreamPort"""
        return _pilot.outstreamlist_front(self)

    def back(self):
        r"""back(outstreamlist self) -> OutputDataStreamPort"""
        return _pilot.outstreamlist_back(self)

    def assign(self, n, x):
        r"""assign(outstreamlist self, std::list< YACS::ENGINE::OutputDataStreamPort * >::size_type n, OutputDataStreamPort x)"""
        return _pilot.outstreamlist_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(outstreamlist self, std::list< YACS::ENGINE::OutputDataStreamPort * >::size_type new_size)
        resize(outstreamlist self, std::list< YACS::ENGINE::OutputDataStreamPort * >::size_type new_size, OutputDataStreamPort x)
        """
        return _pilot.outstreamlist_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(outstreamlist self, std::list< YACS::ENGINE::OutputDataStreamPort * >::iterator pos, OutputDataStreamPort x) -> std::list< YACS::ENGINE::OutputDataStreamPort * >::iterator
        insert(outstreamlist self, std::list< YACS::ENGINE::OutputDataStreamPort * >::iterator pos, std::list< YACS::ENGINE::OutputDataStreamPort * >::size_type n, OutputDataStreamPort x)
        """
        return _pilot.outstreamlist_insert(self, *args)

    def pop_front(self):
        r"""pop_front(outstreamlist self)"""
        return _pilot.outstreamlist_pop_front(self)

    def push_front(self, x):
        r"""push_front(outstreamlist self, OutputDataStreamPort x)"""
        return _pilot.outstreamlist_push_front(self, x)

    def remove(self, x):
        r"""remove(outstreamlist self, OutputDataStreamPort x)"""
        return _pilot.outstreamlist_remove(self, x)

    def unique(self):
        r"""unique(outstreamlist self)"""
        return _pilot.outstreamlist_unique(self)

    def reverse(self):
        r"""reverse(outstreamlist self)"""
        return _pilot.outstreamlist_reverse(self)

    def sort(self):
        r"""sort(outstreamlist self)"""
        return _pilot.outstreamlist_sort(self)

    def merge(self, x):
        r"""merge(outstreamlist self, outstreamlist x)"""
        return _pilot.outstreamlist_merge(self, x)
    __swig_destroy__ = _pilot.delete_outstreamlist

# Register outstreamlist in _pilot:
_pilot.outstreamlist_swigregister(outstreamlist)

class vpsi(object):
    r"""Proxy of C++ std::vector< std::pair< std::string,int > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(vpsi self) -> pilot_PySwigIterator"""
        return _pilot.vpsi_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(vpsi self) -> bool"""
        return _pilot.vpsi___nonzero__(self)

    def __bool__(self):
        r"""__bool__(vpsi self) -> bool"""
        return _pilot.vpsi___bool__(self)

    def __len__(self):
        r"""__len__(vpsi self) -> std::vector< std::pair< std::string,int > >::size_type"""
        return _pilot.vpsi___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(vpsi self, std::vector< std::pair< std::string,int > >::difference_type i, std::vector< std::pair< std::string,int > >::difference_type j) -> vpsi"""
        return _pilot.vpsi___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(vpsi self, std::vector< std::pair< std::string,int > >::difference_type i, std::vector< std::pair< std::string,int > >::difference_type j)
        __setslice__(vpsi self, std::vector< std::pair< std::string,int > >::difference_type i, std::vector< std::pair< std::string,int > >::difference_type j, vpsi v)
        """
        return _pilot.vpsi___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(vpsi self, std::vector< std::pair< std::string,int > >::difference_type i, std::vector< std::pair< std::string,int > >::difference_type j)"""
        return _pilot.vpsi___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(vpsi self, std::vector< std::pair< std::string,int > >::difference_type i)
        __delitem__(vpsi self, PySliceObject * slice)
        """
        return _pilot.vpsi___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(vpsi self, PySliceObject * slice) -> vpsi
        __getitem__(vpsi self, std::vector< std::pair< std::string,int > >::difference_type i) -> std::vector< std::pair< std::string,int > >::value_type const &
        """
        return _pilot.vpsi___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(vpsi self, PySliceObject * slice, vpsi v)
        __setitem__(vpsi self, PySliceObject * slice)
        __setitem__(vpsi self, std::vector< std::pair< std::string,int > >::difference_type i, std::vector< std::pair< std::string,int > >::value_type const & x)
        """
        return _pilot.vpsi___setitem__(self, *args)

    def pop(self):
        r"""pop(vpsi self) -> std::vector< std::pair< std::string,int > >::value_type"""
        return _pilot.vpsi_pop(self)

    def append(self, x):
        r"""append(vpsi self, std::vector< std::pair< std::string,int > >::value_type const & x)"""
        return _pilot.vpsi_append(self, x)

    def empty(self):
        r"""empty(vpsi self) -> bool"""
        return _pilot.vpsi_empty(self)

    def size(self):
        r"""size(vpsi self) -> std::vector< std::pair< std::string,int > >::size_type"""
        return _pilot.vpsi_size(self)

    def swap(self, v):
        r"""swap(vpsi self, vpsi v)"""
        return _pilot.vpsi_swap(self, v)

    def begin(self):
        r"""begin(vpsi self) -> std::vector< std::pair< std::string,int > >::iterator"""
        return _pilot.vpsi_begin(self)

    def end(self):
        r"""end(vpsi self) -> std::vector< std::pair< std::string,int > >::iterator"""
        return _pilot.vpsi_end(self)

    def rbegin(self):
        r"""rbegin(vpsi self) -> std::vector< std::pair< std::string,int > >::reverse_iterator"""
        return _pilot.vpsi_rbegin(self)

    def rend(self):
        r"""rend(vpsi self) -> std::vector< std::pair< std::string,int > >::reverse_iterator"""
        return _pilot.vpsi_rend(self)

    def clear(self):
        r"""clear(vpsi self)"""
        return _pilot.vpsi_clear(self)

    def get_allocator(self):
        r"""get_allocator(vpsi self) -> std::vector< std::pair< std::string,int > >::allocator_type"""
        return _pilot.vpsi_get_allocator(self)

    def pop_back(self):
        r"""pop_back(vpsi self)"""
        return _pilot.vpsi_pop_back(self)

    def erase(self, *args):
        r"""
        erase(vpsi self, std::vector< std::pair< std::string,int > >::iterator pos) -> std::vector< std::pair< std::string,int > >::iterator
        erase(vpsi self, std::vector< std::pair< std::string,int > >::iterator first, std::vector< std::pair< std::string,int > >::iterator last) -> std::vector< std::pair< std::string,int > >::iterator
        """
        return _pilot.vpsi_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(vpsi self) -> vpsi
        __init__(vpsi self, vpsi other) -> vpsi
        __init__(vpsi self, std::vector< std::pair< std::string,int > >::size_type size) -> vpsi
        __init__(vpsi self, std::vector< std::pair< std::string,int > >::size_type size, std::vector< std::pair< std::string,int > >::value_type const & value) -> vpsi
        """
        _pilot.vpsi_swiginit(self, _pilot.new_vpsi(*args))

    def push_back(self, x):
        r"""push_back(vpsi self, std::vector< std::pair< std::string,int > >::value_type const & x)"""
        return _pilot.vpsi_push_back(self, x)

    def front(self):
        r"""front(vpsi self) -> std::vector< std::pair< std::string,int > >::value_type const &"""
        return _pilot.vpsi_front(self)

    def back(self):
        r"""back(vpsi self) -> std::vector< std::pair< std::string,int > >::value_type const &"""
        return _pilot.vpsi_back(self)

    def assign(self, n, x):
        r"""assign(vpsi self, std::vector< std::pair< std::string,int > >::size_type n, std::vector< std::pair< std::string,int > >::value_type const & x)"""
        return _pilot.vpsi_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(vpsi self, std::vector< std::pair< std::string,int > >::size_type new_size)
        resize(vpsi self, std::vector< std::pair< std::string,int > >::size_type new_size, std::vector< std::pair< std::string,int > >::value_type const & x)
        """
        return _pilot.vpsi_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(vpsi self, std::vector< std::pair< std::string,int > >::iterator pos, std::vector< std::pair< std::string,int > >::value_type const & x) -> std::vector< std::pair< std::string,int > >::iterator
        insert(vpsi self, std::vector< std::pair< std::string,int > >::iterator pos, std::vector< std::pair< std::string,int > >::size_type n, std::vector< std::pair< std::string,int > >::value_type const & x)
        """
        return _pilot.vpsi_insert(self, *args)

    def reserve(self, n):
        r"""reserve(vpsi self, std::vector< std::pair< std::string,int > >::size_type n)"""
        return _pilot.vpsi_reserve(self, n)

    def capacity(self):
        r"""capacity(vpsi self) -> std::vector< std::pair< std::string,int > >::size_type"""
        return _pilot.vpsi_capacity(self)
    __swig_destroy__ = _pilot.delete_vpsi

# Register vpsi in _pilot:
_pilot.vpsi_swigregister(vpsi)

class loadermap(object):
    r"""Proxy of C++ std::map< std::string,YACS::ENGINE::CatalogLoader * > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(loadermap self) -> pilot_PySwigIterator"""
        return _pilot.loadermap_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(loadermap self) -> bool"""
        return _pilot.loadermap___nonzero__(self)

    def __bool__(self):
        r"""__bool__(loadermap self) -> bool"""
        return _pilot.loadermap___bool__(self)

    def __len__(self):
        r"""__len__(loadermap self) -> std::map< std::string,YACS::ENGINE::CatalogLoader * >::size_type"""
        return _pilot.loadermap___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        r"""__getitem__(loadermap self, std::map< std::string,YACS::ENGINE::CatalogLoader * >::key_type const & key) -> CatalogLoader"""
        return _pilot.loadermap___getitem__(self, key)

    def __delitem__(self, key):
        r"""__delitem__(loadermap self, std::map< std::string,YACS::ENGINE::CatalogLoader * >::key_type const & key)"""
        return _pilot.loadermap___delitem__(self, key)

    def has_key(self, key):
        r"""has_key(loadermap self, std::map< std::string,YACS::ENGINE::CatalogLoader * >::key_type const & key) -> bool"""
        return _pilot.loadermap_has_key(self, key)

    def keys(self):
        r"""keys(loadermap self) -> PyObject *"""
        return _pilot.loadermap_keys(self)

    def values(self):
        r"""values(loadermap self) -> PyObject *"""
        return _pilot.loadermap_values(self)

    def items(self):
        r"""items(loadermap self) -> PyObject *"""
        return _pilot.loadermap_items(self)

    def __contains__(self, key):
        r"""__contains__(loadermap self, std::map< std::string,YACS::ENGINE::CatalogLoader * >::key_type const & key) -> bool"""
        return _pilot.loadermap___contains__(self, key)

    def key_iterator(self):
        r"""key_iterator(loadermap self) -> pilot_PySwigIterator"""
        return _pilot.loadermap_key_iterator(self)

    def value_iterator(self):
        r"""value_iterator(loadermap self) -> pilot_PySwigIterator"""
        return _pilot.loadermap_value_iterator(self)

    def __setitem__(self, *args):
        r"""
        __setitem__(loadermap self, std::map< std::string,YACS::ENGINE::CatalogLoader * >::key_type const & key)
        __setitem__(loadermap self, std::map< std::string,YACS::ENGINE::CatalogLoader * >::key_type const & key, CatalogLoader x)
        """
        return _pilot.loadermap___setitem__(self, *args)

    def asdict(self):
        r"""asdict(loadermap self) -> PyObject *"""
        return _pilot.loadermap_asdict(self)

    def __init__(self, *args):
        r"""
        __init__(loadermap self, std::less< std::string > const & other) -> loadermap
        __init__(loadermap self) -> loadermap
        __init__(loadermap self, loadermap other) -> loadermap
        """
        _pilot.loadermap_swiginit(self, _pilot.new_loadermap(*args))

    def empty(self):
        r"""empty(loadermap self) -> bool"""
        return _pilot.loadermap_empty(self)

    def size(self):
        r"""size(loadermap self) -> std::map< std::string,YACS::ENGINE::CatalogLoader * >::size_type"""
        return _pilot.loadermap_size(self)

    def swap(self, v):
        r"""swap(loadermap self, loadermap v)"""
        return _pilot.loadermap_swap(self, v)

    def begin(self):
        r"""begin(loadermap self) -> std::map< std::string,YACS::ENGINE::CatalogLoader * >::iterator"""
        return _pilot.loadermap_begin(self)

    def end(self):
        r"""end(loadermap self) -> std::map< std::string,YACS::ENGINE::CatalogLoader * >::iterator"""
        return _pilot.loadermap_end(self)

    def rbegin(self):
        r"""rbegin(loadermap self) -> std::map< std::string,YACS::ENGINE::CatalogLoader * >::reverse_iterator"""
        return _pilot.loadermap_rbegin(self)

    def rend(self):
        r"""rend(loadermap self) -> std::map< std::string,YACS::ENGINE::CatalogLoader * >::reverse_iterator"""
        return _pilot.loadermap_rend(self)

    def clear(self):
        r"""clear(loadermap self)"""
        return _pilot.loadermap_clear(self)

    def get_allocator(self):
        r"""get_allocator(loadermap self) -> std::map< std::string,YACS::ENGINE::CatalogLoader * >::allocator_type"""
        return _pilot.loadermap_get_allocator(self)

    def count(self, x):
        r"""count(loadermap self, std::map< std::string,YACS::ENGINE::CatalogLoader * >::key_type const & x) -> std::map< std::string,YACS::ENGINE::CatalogLoader * >::size_type"""
        return _pilot.loadermap_count(self, x)

    def erase(self, *args):
        r"""
        erase(loadermap self, std::map< std::string,YACS::ENGINE::CatalogLoader * >::key_type const & x) -> std::map< std::string,YACS::ENGINE::CatalogLoader * >::size_type
        erase(loadermap self, std::map< std::string,YACS::ENGINE::CatalogLoader * >::iterator position)
        erase(loadermap self, std::map< std::string,YACS::ENGINE::CatalogLoader * >::iterator first, std::map< std::string,YACS::ENGINE::CatalogLoader * >::iterator last)
        """
        return _pilot.loadermap_erase(self, *args)

    def find(self, x):
        r"""find(loadermap self, std::map< std::string,YACS::ENGINE::CatalogLoader * >::key_type const & x) -> std::map< std::string,YACS::ENGINE::CatalogLoader * >::iterator"""
        return _pilot.loadermap_find(self, x)

    def lower_bound(self, x):
        r"""lower_bound(loadermap self, std::map< std::string,YACS::ENGINE::CatalogLoader * >::key_type const & x) -> std::map< std::string,YACS::ENGINE::CatalogLoader * >::iterator"""
        return _pilot.loadermap_lower_bound(self, x)

    def upper_bound(self, x):
        r"""upper_bound(loadermap self, std::map< std::string,YACS::ENGINE::CatalogLoader * >::key_type const & x) -> std::map< std::string,YACS::ENGINE::CatalogLoader * >::iterator"""
        return _pilot.loadermap_upper_bound(self, x)
    __swig_destroy__ = _pilot.delete_loadermap

# Register loadermap in _pilot:
_pilot.loadermap_swigregister(loadermap)

class composedmap(object):
    r"""Proxy of C++ std::map< std::string,YACS::ENGINE::ComposedNode * > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(composedmap self) -> pilot_PySwigIterator"""
        return _pilot.composedmap_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(composedmap self) -> bool"""
        return _pilot.composedmap___nonzero__(self)

    def __bool__(self):
        r"""__bool__(composedmap self) -> bool"""
        return _pilot.composedmap___bool__(self)

    def __len__(self):
        r"""__len__(composedmap self) -> std::map< std::string,YACS::ENGINE::ComposedNode * >::size_type"""
        return _pilot.composedmap___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        r"""__getitem__(composedmap self, std::map< std::string,YACS::ENGINE::ComposedNode * >::key_type const & key) -> ComposedNode"""
        return _pilot.composedmap___getitem__(self, key)

    def __delitem__(self, key):
        r"""__delitem__(composedmap self, std::map< std::string,YACS::ENGINE::ComposedNode * >::key_type const & key)"""
        return _pilot.composedmap___delitem__(self, key)

    def has_key(self, key):
        r"""has_key(composedmap self, std::map< std::string,YACS::ENGINE::ComposedNode * >::key_type const & key) -> bool"""
        return _pilot.composedmap_has_key(self, key)

    def keys(self):
        r"""keys(composedmap self) -> PyObject *"""
        return _pilot.composedmap_keys(self)

    def values(self):
        r"""values(composedmap self) -> PyObject *"""
        return _pilot.composedmap_values(self)

    def items(self):
        r"""items(composedmap self) -> PyObject *"""
        return _pilot.composedmap_items(self)

    def __contains__(self, key):
        r"""__contains__(composedmap self, std::map< std::string,YACS::ENGINE::ComposedNode * >::key_type const & key) -> bool"""
        return _pilot.composedmap___contains__(self, key)

    def key_iterator(self):
        r"""key_iterator(composedmap self) -> pilot_PySwigIterator"""
        return _pilot.composedmap_key_iterator(self)

    def value_iterator(self):
        r"""value_iterator(composedmap self) -> pilot_PySwigIterator"""
        return _pilot.composedmap_value_iterator(self)

    def __setitem__(self, *args):
        r"""
        __setitem__(composedmap self, std::map< std::string,YACS::ENGINE::ComposedNode * >::key_type const & key)
        __setitem__(composedmap self, std::map< std::string,YACS::ENGINE::ComposedNode * >::key_type const & key, ComposedNode x)
        """
        return _pilot.composedmap___setitem__(self, *args)

    def asdict(self):
        r"""asdict(composedmap self) -> PyObject *"""
        return _pilot.composedmap_asdict(self)

    def __init__(self, *args):
        r"""
        __init__(composedmap self, std::less< std::string > const & other) -> composedmap
        __init__(composedmap self) -> composedmap
        __init__(composedmap self, composedmap other) -> composedmap
        """
        _pilot.composedmap_swiginit(self, _pilot.new_composedmap(*args))

    def empty(self):
        r"""empty(composedmap self) -> bool"""
        return _pilot.composedmap_empty(self)

    def size(self):
        r"""size(composedmap self) -> std::map< std::string,YACS::ENGINE::ComposedNode * >::size_type"""
        return _pilot.composedmap_size(self)

    def swap(self, v):
        r"""swap(composedmap self, composedmap v)"""
        return _pilot.composedmap_swap(self, v)

    def begin(self):
        r"""begin(composedmap self) -> std::map< std::string,YACS::ENGINE::ComposedNode * >::iterator"""
        return _pilot.composedmap_begin(self)

    def end(self):
        r"""end(composedmap self) -> std::map< std::string,YACS::ENGINE::ComposedNode * >::iterator"""
        return _pilot.composedmap_end(self)

    def rbegin(self):
        r"""rbegin(composedmap self) -> std::map< std::string,YACS::ENGINE::ComposedNode * >::reverse_iterator"""
        return _pilot.composedmap_rbegin(self)

    def rend(self):
        r"""rend(composedmap self) -> std::map< std::string,YACS::ENGINE::ComposedNode * >::reverse_iterator"""
        return _pilot.composedmap_rend(self)

    def clear(self):
        r"""clear(composedmap self)"""
        return _pilot.composedmap_clear(self)

    def get_allocator(self):
        r"""get_allocator(composedmap self) -> std::map< std::string,YACS::ENGINE::ComposedNode * >::allocator_type"""
        return _pilot.composedmap_get_allocator(self)

    def count(self, x):
        r"""count(composedmap self, std::map< std::string,YACS::ENGINE::ComposedNode * >::key_type const & x) -> std::map< std::string,YACS::ENGINE::ComposedNode * >::size_type"""
        return _pilot.composedmap_count(self, x)

    def erase(self, *args):
        r"""
        erase(composedmap self, std::map< std::string,YACS::ENGINE::ComposedNode * >::key_type const & x) -> std::map< std::string,YACS::ENGINE::ComposedNode * >::size_type
        erase(composedmap self, std::map< std::string,YACS::ENGINE::ComposedNode * >::iterator position)
        erase(composedmap self, std::map< std::string,YACS::ENGINE::ComposedNode * >::iterator first, std::map< std::string,YACS::ENGINE::ComposedNode * >::iterator last)
        """
        return _pilot.composedmap_erase(self, *args)

    def find(self, x):
        r"""find(composedmap self, std::map< std::string,YACS::ENGINE::ComposedNode * >::key_type const & x) -> std::map< std::string,YACS::ENGINE::ComposedNode * >::iterator"""
        return _pilot.composedmap_find(self, x)

    def lower_bound(self, x):
        r"""lower_bound(composedmap self, std::map< std::string,YACS::ENGINE::ComposedNode * >::key_type const & x) -> std::map< std::string,YACS::ENGINE::ComposedNode * >::iterator"""
        return _pilot.composedmap_lower_bound(self, x)

    def upper_bound(self, x):
        r"""upper_bound(composedmap self, std::map< std::string,YACS::ENGINE::ComposedNode * >::key_type const & x) -> std::map< std::string,YACS::ENGINE::ComposedNode * >::iterator"""
        return _pilot.composedmap_upper_bound(self, x)
    __swig_destroy__ = _pilot.delete_composedmap

# Register composedmap in _pilot:
_pilot.composedmap_swigregister(composedmap)

class compomap(object):
    r"""Proxy of C++ std::map< std::string,YACS::ENGINE::ComponentDefinition * > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(compomap self) -> pilot_PySwigIterator"""
        return _pilot.compomap_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(compomap self) -> bool"""
        return _pilot.compomap___nonzero__(self)

    def __bool__(self):
        r"""__bool__(compomap self) -> bool"""
        return _pilot.compomap___bool__(self)

    def __len__(self):
        r"""__len__(compomap self) -> std::map< std::string,YACS::ENGINE::ComponentDefinition * >::size_type"""
        return _pilot.compomap___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        r"""__getitem__(compomap self, std::map< std::string,YACS::ENGINE::ComponentDefinition * >::key_type const & key) -> ComponentDefinition"""
        return _pilot.compomap___getitem__(self, key)

    def __delitem__(self, key):
        r"""__delitem__(compomap self, std::map< std::string,YACS::ENGINE::ComponentDefinition * >::key_type const & key)"""
        return _pilot.compomap___delitem__(self, key)

    def has_key(self, key):
        r"""has_key(compomap self, std::map< std::string,YACS::ENGINE::ComponentDefinition * >::key_type const & key) -> bool"""
        return _pilot.compomap_has_key(self, key)

    def keys(self):
        r"""keys(compomap self) -> PyObject *"""
        return _pilot.compomap_keys(self)

    def values(self):
        r"""values(compomap self) -> PyObject *"""
        return _pilot.compomap_values(self)

    def items(self):
        r"""items(compomap self) -> PyObject *"""
        return _pilot.compomap_items(self)

    def __contains__(self, key):
        r"""__contains__(compomap self, std::map< std::string,YACS::ENGINE::ComponentDefinition * >::key_type const & key) -> bool"""
        return _pilot.compomap___contains__(self, key)

    def key_iterator(self):
        r"""key_iterator(compomap self) -> pilot_PySwigIterator"""
        return _pilot.compomap_key_iterator(self)

    def value_iterator(self):
        r"""value_iterator(compomap self) -> pilot_PySwigIterator"""
        return _pilot.compomap_value_iterator(self)

    def __setitem__(self, *args):
        r"""
        __setitem__(compomap self, std::map< std::string,YACS::ENGINE::ComponentDefinition * >::key_type const & key)
        __setitem__(compomap self, std::map< std::string,YACS::ENGINE::ComponentDefinition * >::key_type const & key, ComponentDefinition x)
        """
        return _pilot.compomap___setitem__(self, *args)

    def asdict(self):
        r"""asdict(compomap self) -> PyObject *"""
        return _pilot.compomap_asdict(self)

    def __init__(self, *args):
        r"""
        __init__(compomap self, std::less< std::string > const & other) -> compomap
        __init__(compomap self) -> compomap
        __init__(compomap self, compomap other) -> compomap
        """
        _pilot.compomap_swiginit(self, _pilot.new_compomap(*args))

    def empty(self):
        r"""empty(compomap self) -> bool"""
        return _pilot.compomap_empty(self)

    def size(self):
        r"""size(compomap self) -> std::map< std::string,YACS::ENGINE::ComponentDefinition * >::size_type"""
        return _pilot.compomap_size(self)

    def swap(self, v):
        r"""swap(compomap self, compomap v)"""
        return _pilot.compomap_swap(self, v)

    def begin(self):
        r"""begin(compomap self) -> std::map< std::string,YACS::ENGINE::ComponentDefinition * >::iterator"""
        return _pilot.compomap_begin(self)

    def end(self):
        r"""end(compomap self) -> std::map< std::string,YACS::ENGINE::ComponentDefinition * >::iterator"""
        return _pilot.compomap_end(self)

    def rbegin(self):
        r"""rbegin(compomap self) -> std::map< std::string,YACS::ENGINE::ComponentDefinition * >::reverse_iterator"""
        return _pilot.compomap_rbegin(self)

    def rend(self):
        r"""rend(compomap self) -> std::map< std::string,YACS::ENGINE::ComponentDefinition * >::reverse_iterator"""
        return _pilot.compomap_rend(self)

    def clear(self):
        r"""clear(compomap self)"""
        return _pilot.compomap_clear(self)

    def get_allocator(self):
        r"""get_allocator(compomap self) -> std::map< std::string,YACS::ENGINE::ComponentDefinition * >::allocator_type"""
        return _pilot.compomap_get_allocator(self)

    def count(self, x):
        r"""count(compomap self, std::map< std::string,YACS::ENGINE::ComponentDefinition * >::key_type const & x) -> std::map< std::string,YACS::ENGINE::ComponentDefinition * >::size_type"""
        return _pilot.compomap_count(self, x)

    def erase(self, *args):
        r"""
        erase(compomap self, std::map< std::string,YACS::ENGINE::ComponentDefinition * >::key_type const & x) -> std::map< std::string,YACS::ENGINE::ComponentDefinition * >::size_type
        erase(compomap self, std::map< std::string,YACS::ENGINE::ComponentDefinition * >::iterator position)
        erase(compomap self, std::map< std::string,YACS::ENGINE::ComponentDefinition * >::iterator first, std::map< std::string,YACS::ENGINE::ComponentDefinition * >::iterator last)
        """
        return _pilot.compomap_erase(self, *args)

    def find(self, x):
        r"""find(compomap self, std::map< std::string,YACS::ENGINE::ComponentDefinition * >::key_type const & x) -> std::map< std::string,YACS::ENGINE::ComponentDefinition * >::iterator"""
        return _pilot.compomap_find(self, x)

    def lower_bound(self, x):
        r"""lower_bound(compomap self, std::map< std::string,YACS::ENGINE::ComponentDefinition * >::key_type const & x) -> std::map< std::string,YACS::ENGINE::ComponentDefinition * >::iterator"""
        return _pilot.compomap_lower_bound(self, x)

    def upper_bound(self, x):
        r"""upper_bound(compomap self, std::map< std::string,YACS::ENGINE::ComponentDefinition * >::key_type const & x) -> std::map< std::string,YACS::ENGINE::ComponentDefinition * >::iterator"""
        return _pilot.compomap_upper_bound(self, x)
    __swig_destroy__ = _pilot.delete_compomap

# Register compomap in _pilot:
_pilot.compomap_swigregister(compomap)

class propmap(object):
    r"""Proxy of C++ std::map< std::string,std::string > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(propmap self) -> pilot_PySwigIterator"""
        return _pilot.propmap_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(propmap self) -> bool"""
        return _pilot.propmap___nonzero__(self)

    def __bool__(self):
        r"""__bool__(propmap self) -> bool"""
        return _pilot.propmap___bool__(self)

    def __len__(self):
        r"""__len__(propmap self) -> std::map< std::string,std::string >::size_type"""
        return _pilot.propmap___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        r"""__getitem__(propmap self, std::map< std::string,std::string >::key_type const & key) -> std::map< std::string,std::string >::mapped_type const &"""
        return _pilot.propmap___getitem__(self, key)

    def __delitem__(self, key):
        r"""__delitem__(propmap self, std::map< std::string,std::string >::key_type const & key)"""
        return _pilot.propmap___delitem__(self, key)

    def has_key(self, key):
        r"""has_key(propmap self, std::map< std::string,std::string >::key_type const & key) -> bool"""
        return _pilot.propmap_has_key(self, key)

    def keys(self):
        r"""keys(propmap self) -> PyObject *"""
        return _pilot.propmap_keys(self)

    def values(self):
        r"""values(propmap self) -> PyObject *"""
        return _pilot.propmap_values(self)

    def items(self):
        r"""items(propmap self) -> PyObject *"""
        return _pilot.propmap_items(self)

    def __contains__(self, key):
        r"""__contains__(propmap self, std::map< std::string,std::string >::key_type const & key) -> bool"""
        return _pilot.propmap___contains__(self, key)

    def key_iterator(self):
        r"""key_iterator(propmap self) -> pilot_PySwigIterator"""
        return _pilot.propmap_key_iterator(self)

    def value_iterator(self):
        r"""value_iterator(propmap self) -> pilot_PySwigIterator"""
        return _pilot.propmap_value_iterator(self)

    def __setitem__(self, *args):
        r"""
        __setitem__(propmap self, std::map< std::string,std::string >::key_type const & key)
        __setitem__(propmap self, std::map< std::string,std::string >::key_type const & key, std::map< std::string,std::string >::mapped_type const & x)
        """
        return _pilot.propmap___setitem__(self, *args)

    def asdict(self):
        r"""asdict(propmap self) -> PyObject *"""
        return _pilot.propmap_asdict(self)

    def __init__(self, *args):
        r"""
        __init__(propmap self, std::less< std::string > const & other) -> propmap
        __init__(propmap self) -> propmap
        __init__(propmap self, propmap other) -> propmap
        """
        _pilot.propmap_swiginit(self, _pilot.new_propmap(*args))

    def empty(self):
        r"""empty(propmap self) -> bool"""
        return _pilot.propmap_empty(self)

    def size(self):
        r"""size(propmap self) -> std::map< std::string,std::string >::size_type"""
        return _pilot.propmap_size(self)

    def swap(self, v):
        r"""swap(propmap self, propmap v)"""
        return _pilot.propmap_swap(self, v)

    def begin(self):
        r"""begin(propmap self) -> std::map< std::string,std::string >::iterator"""
        return _pilot.propmap_begin(self)

    def end(self):
        r"""end(propmap self) -> std::map< std::string,std::string >::iterator"""
        return _pilot.propmap_end(self)

    def rbegin(self):
        r"""rbegin(propmap self) -> std::map< std::string,std::string >::reverse_iterator"""
        return _pilot.propmap_rbegin(self)

    def rend(self):
        r"""rend(propmap self) -> std::map< std::string,std::string >::reverse_iterator"""
        return _pilot.propmap_rend(self)

    def clear(self):
        r"""clear(propmap self)"""
        return _pilot.propmap_clear(self)

    def get_allocator(self):
        r"""get_allocator(propmap self) -> std::map< std::string,std::string >::allocator_type"""
        return _pilot.propmap_get_allocator(self)

    def count(self, x):
        r"""count(propmap self, std::map< std::string,std::string >::key_type const & x) -> std::map< std::string,std::string >::size_type"""
        return _pilot.propmap_count(self, x)

    def erase(self, *args):
        r"""
        erase(propmap self, std::map< std::string,std::string >::key_type const & x) -> std::map< std::string,std::string >::size_type
        erase(propmap self, std::map< std::string,std::string >::iterator position)
        erase(propmap self, std::map< std::string,std::string >::iterator first, std::map< std::string,std::string >::iterator last)
        """
        return _pilot.propmap_erase(self, *args)

    def find(self, x):
        r"""find(propmap self, std::map< std::string,std::string >::key_type const & x) -> std::map< std::string,std::string >::iterator"""
        return _pilot.propmap_find(self, x)

    def lower_bound(self, x):
        r"""lower_bound(propmap self, std::map< std::string,std::string >::key_type const & x) -> std::map< std::string,std::string >::iterator"""
        return _pilot.propmap_lower_bound(self, x)

    def upper_bound(self, x):
        r"""upper_bound(propmap self, std::map< std::string,std::string >::key_type const & x) -> std::map< std::string,std::string >::iterator"""
        return _pilot.propmap_upper_bound(self, x)
    __swig_destroy__ = _pilot.delete_propmap

# Register propmap in _pilot:
_pilot.propmap_swigregister(propmap)

class ItPy3Comp(object):
    r"""Proxy of C++ IteratorPy3< YACS::ENGINE::ComponentInstance * > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, _cur, _end):
        r"""__init__(ItPy3Comp self, std::map< std::string,YACS::ENGINE::ComponentInstance **,std::less< std::string >,std::allocator< std::pair< std::string const,YACS::ENGINE::ComponentInstance ** > > >::iterator _cur, std::map< std::string,YACS::ENGINE::ComponentInstance **,std::less< std::string >,std::allocator< std::pair< std::string const,YACS::ENGINE::ComponentInstance ** > > >::iterator _end) -> ItPy3Comp"""
        _pilot.ItPy3Comp_swiginit(self, _pilot.new_ItPy3Comp(_cur, _end))
    __swig_destroy__ = _pilot.delete_ItPy3Comp

    def __iter__(self):
        r"""__iter__(ItPy3Comp self) -> ItPy3Comp"""
        return _pilot.ItPy3Comp___iter__(self)
    cur = property(_pilot.ItPy3Comp_cur_get, _pilot.ItPy3Comp_cur_set, doc=r"""cur : std::map<(std::string,p.p.YACS::ENGINE::ComponentInstance,std::less<(std::string)>,std::allocator<(std::pair<(q(const).std::string,p.p.YACS::ENGINE::ComponentInstance)>)>)>::iterator""")
    end = property(_pilot.ItPy3Comp_end_get, _pilot.ItPy3Comp_end_set, doc=r"""end : std::map<(std::string,p.p.YACS::ENGINE::ComponentInstance,std::less<(std::string)>,std::allocator<(std::pair<(q(const).std::string,p.p.YACS::ENGINE::ComponentInstance)>)>)>::iterator""")

# Register ItPy3Comp in _pilot:
_pilot.ItPy3Comp_swigregister(ItPy3Comp)

class listpairingatebool(object):
    r"""Proxy of C++ std::list< std::pair< YACS::ENGINE::InGate *,bool > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(listpairingatebool self) -> pilot_PySwigIterator"""
        return _pilot.listpairingatebool_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(listpairingatebool self) -> bool"""
        return _pilot.listpairingatebool___nonzero__(self)

    def __bool__(self):
        r"""__bool__(listpairingatebool self) -> bool"""
        return _pilot.listpairingatebool___bool__(self)

    def __len__(self):
        r"""__len__(listpairingatebool self) -> std::list< std::pair< YACS::ENGINE::InGate *,bool > >::size_type"""
        return _pilot.listpairingatebool___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(listpairingatebool self, std::list< std::pair< YACS::ENGINE::InGate *,bool > >::difference_type i, std::list< std::pair< YACS::ENGINE::InGate *,bool > >::difference_type j) -> listpairingatebool"""
        return _pilot.listpairingatebool___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(listpairingatebool self, std::list< std::pair< YACS::ENGINE::InGate *,bool > >::difference_type i, std::list< std::pair< YACS::ENGINE::InGate *,bool > >::difference_type j)
        __setslice__(listpairingatebool self, std::list< std::pair< YACS::ENGINE::InGate *,bool > >::difference_type i, std::list< std::pair< YACS::ENGINE::InGate *,bool > >::difference_type j, listpairingatebool v)
        """
        return _pilot.listpairingatebool___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(listpairingatebool self, std::list< std::pair< YACS::ENGINE::InGate *,bool > >::difference_type i, std::list< std::pair< YACS::ENGINE::InGate *,bool > >::difference_type j)"""
        return _pilot.listpairingatebool___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(listpairingatebool self, std::list< std::pair< YACS::ENGINE::InGate *,bool > >::difference_type i)
        __delitem__(listpairingatebool self, PySliceObject * slice)
        """
        return _pilot.listpairingatebool___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(listpairingatebool self, PySliceObject * slice) -> listpairingatebool
        __getitem__(listpairingatebool self, std::list< std::pair< YACS::ENGINE::InGate *,bool > >::difference_type i) -> std::list< std::pair< YACS::ENGINE::InGate *,bool > >::value_type const &
        """
        return _pilot.listpairingatebool___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(listpairingatebool self, PySliceObject * slice, listpairingatebool v)
        __setitem__(listpairingatebool self, PySliceObject * slice)
        __setitem__(listpairingatebool self, std::list< std::pair< YACS::ENGINE::InGate *,bool > >::difference_type i, std::list< std::pair< YACS::ENGINE::InGate *,bool > >::value_type const & x)
        """
        return _pilot.listpairingatebool___setitem__(self, *args)

    def pop(self):
        r"""pop(listpairingatebool self) -> std::list< std::pair< YACS::ENGINE::InGate *,bool > >::value_type"""
        return _pilot.listpairingatebool_pop(self)

    def append(self, x):
        r"""append(listpairingatebool self, std::list< std::pair< YACS::ENGINE::InGate *,bool > >::value_type const & x)"""
        return _pilot.listpairingatebool_append(self, x)

    def empty(self):
        r"""empty(listpairingatebool self) -> bool"""
        return _pilot.listpairingatebool_empty(self)

    def size(self):
        r"""size(listpairingatebool self) -> std::list< std::pair< YACS::ENGINE::InGate *,bool > >::size_type"""
        return _pilot.listpairingatebool_size(self)

    def swap(self, v):
        r"""swap(listpairingatebool self, listpairingatebool v)"""
        return _pilot.listpairingatebool_swap(self, v)

    def begin(self):
        r"""begin(listpairingatebool self) -> std::list< std::pair< YACS::ENGINE::InGate *,bool > >::iterator"""
        return _pilot.listpairingatebool_begin(self)

    def end(self):
        r"""end(listpairingatebool self) -> std::list< std::pair< YACS::ENGINE::InGate *,bool > >::iterator"""
        return _pilot.listpairingatebool_end(self)

    def rbegin(self):
        r"""rbegin(listpairingatebool self) -> std::list< std::pair< YACS::ENGINE::InGate *,bool > >::reverse_iterator"""
        return _pilot.listpairingatebool_rbegin(self)

    def rend(self):
        r"""rend(listpairingatebool self) -> std::list< std::pair< YACS::ENGINE::InGate *,bool > >::reverse_iterator"""
        return _pilot.listpairingatebool_rend(self)

    def clear(self):
        r"""clear(listpairingatebool self)"""
        return _pilot.listpairingatebool_clear(self)

    def get_allocator(self):
        r"""get_allocator(listpairingatebool self) -> std::list< std::pair< YACS::ENGINE::InGate *,bool > >::allocator_type"""
        return _pilot.listpairingatebool_get_allocator(self)

    def pop_back(self):
        r"""pop_back(listpairingatebool self)"""
        return _pilot.listpairingatebool_pop_back(self)

    def erase(self, *args):
        r"""
        erase(listpairingatebool self, std::list< std::pair< YACS::ENGINE::InGate *,bool > >::iterator pos) -> std::list< std::pair< YACS::ENGINE::InGate *,bool > >::iterator
        erase(listpairingatebool self, std::list< std::pair< YACS::ENGINE::InGate *,bool > >::iterator first, std::list< std::pair< YACS::ENGINE::InGate *,bool > >::iterator last) -> std::list< std::pair< YACS::ENGINE::InGate *,bool > >::iterator
        """
        return _pilot.listpairingatebool_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(listpairingatebool self) -> listpairingatebool
        __init__(listpairingatebool self, listpairingatebool other) -> listpairingatebool
        __init__(listpairingatebool self, std::list< std::pair< YACS::ENGINE::InGate *,bool > >::size_type size) -> listpairingatebool
        __init__(listpairingatebool self, std::list< std::pair< YACS::ENGINE::InGate *,bool > >::size_type size, std::list< std::pair< YACS::ENGINE::InGate *,bool > >::value_type const & value) -> listpairingatebool
        """
        _pilot.listpairingatebool_swiginit(self, _pilot.new_listpairingatebool(*args))

    def push_back(self, x):
        r"""push_back(listpairingatebool self, std::list< std::pair< YACS::ENGINE::InGate *,bool > >::value_type const & x)"""
        return _pilot.listpairingatebool_push_back(self, x)

    def front(self):
        r"""front(listpairingatebool self) -> std::list< std::pair< YACS::ENGINE::InGate *,bool > >::value_type const &"""
        return _pilot.listpairingatebool_front(self)

    def back(self):
        r"""back(listpairingatebool self) -> std::list< std::pair< YACS::ENGINE::InGate *,bool > >::value_type const &"""
        return _pilot.listpairingatebool_back(self)

    def assign(self, n, x):
        r"""assign(listpairingatebool self, std::list< std::pair< YACS::ENGINE::InGate *,bool > >::size_type n, std::list< std::pair< YACS::ENGINE::InGate *,bool > >::value_type const & x)"""
        return _pilot.listpairingatebool_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(listpairingatebool self, std::list< std::pair< YACS::ENGINE::InGate *,bool > >::size_type new_size)
        resize(listpairingatebool self, std::list< std::pair< YACS::ENGINE::InGate *,bool > >::size_type new_size, std::list< std::pair< YACS::ENGINE::InGate *,bool > >::value_type const & x)
        """
        return _pilot.listpairingatebool_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(listpairingatebool self, std::list< std::pair< YACS::ENGINE::InGate *,bool > >::iterator pos, std::list< std::pair< YACS::ENGINE::InGate *,bool > >::value_type const & x) -> std::list< std::pair< YACS::ENGINE::InGate *,bool > >::iterator
        insert(listpairingatebool self, std::list< std::pair< YACS::ENGINE::InGate *,bool > >::iterator pos, std::list< std::pair< YACS::ENGINE::InGate *,bool > >::size_type n, std::list< std::pair< YACS::ENGINE::InGate *,bool > >::value_type const & x)
        """
        return _pilot.listpairingatebool_insert(self, *args)

    def pop_front(self):
        r"""pop_front(listpairingatebool self)"""
        return _pilot.listpairingatebool_pop_front(self)

    def push_front(self, x):
        r"""push_front(listpairingatebool self, std::list< std::pair< YACS::ENGINE::InGate *,bool > >::value_type const & x)"""
        return _pilot.listpairingatebool_push_front(self, x)

    def reverse(self):
        r"""reverse(listpairingatebool self)"""
        return _pilot.listpairingatebool_reverse(self)
    __swig_destroy__ = _pilot.delete_listpairingatebool

# Register listpairingatebool in _pilot:
_pilot.listpairingatebool_swigregister(listpairingatebool)

class CompoInstmapit(object):
    r"""Proxy of C++ IteratorPy3< YACS::ENGINE::ComponentInstance > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, _cur, _end):
        r"""__init__(CompoInstmapit self, std::map< std::string,YACS::ENGINE::ComponentInstance *,std::less< std::string >,std::allocator< std::pair< std::string const,YACS::ENGINE::ComponentInstance * > > >::iterator _cur, std::map< std::string,YACS::ENGINE::ComponentInstance *,std::less< std::string >,std::allocator< std::pair< std::string const,YACS::ENGINE::ComponentInstance * > > >::iterator _end) -> CompoInstmapit"""
        _pilot.CompoInstmapit_swiginit(self, _pilot.new_CompoInstmapit(_cur, _end))
    __swig_destroy__ = _pilot.delete_CompoInstmapit

    def __iter__(self):
        r"""__iter__(CompoInstmapit self) -> CompoInstmapit"""
        return _pilot.CompoInstmapit___iter__(self)
    cur = property(_pilot.CompoInstmapit_cur_get, _pilot.CompoInstmapit_cur_set, doc=r"""cur : std::map<(std::string,p.YACS::ENGINE::ComponentInstance,std::less<(std::string)>,std::allocator<(std::pair<(q(const).std::string,p.YACS::ENGINE::ComponentInstance)>)>)>::iterator""")
    end = property(_pilot.CompoInstmapit_end_get, _pilot.CompoInstmapit_end_set, doc=r"""end : std::map<(std::string,p.YACS::ENGINE::ComponentInstance,std::less<(std::string)>,std::allocator<(std::pair<(q(const).std::string,p.YACS::ENGINE::ComponentInstance)>)>)>::iterator""")

    def __next__(self):
        r"""__next__(CompoInstmapit self) -> std::string"""
        return _pilot.CompoInstmapit___next__(self)

# Register CompoInstmapit in _pilot:
_pilot.CompoInstmapit_swigregister(CompoInstmapit)

class CompoInstmap(object):
    r"""Proxy of C++ std::map< std::string,YACS::ENGINE::ComponentInstance * > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __setitem__(self, name, c):
        r"""__setitem__(CompoInstmap self, std::string const & name, ComponentInstance c)"""
        return _pilot.CompoInstmap___setitem__(self, name, c)

    def __getitem__(self, name):
        r"""__getitem__(CompoInstmap self, std::string name) -> ComponentInstance"""
        return _pilot.CompoInstmap___getitem__(self, name)

    def __delitem__(self, name):
        r"""__delitem__(CompoInstmap self, std::string name)"""
        return _pilot.CompoInstmap___delitem__(self, name)

    def keys(self):
        r"""keys(CompoInstmap self) -> PyObject *"""
        return _pilot.CompoInstmap_keys(self)

    def __iter__(self):
        r"""__iter__(CompoInstmap self) -> CompoInstmapit"""
        return _pilot.CompoInstmap___iter__(self)

    def __len__(self):
        r"""__len__(CompoInstmap self) -> int"""
        return _pilot.CompoInstmap___len__(self)

    def __init__(self):
        r"""__init__(CompoInstmap self) -> CompoInstmap"""
        _pilot.CompoInstmap_swiginit(self, _pilot.new_CompoInstmap())
    __swig_destroy__ = _pilot.delete_CompoInstmap

# Register CompoInstmap in _pilot:
_pilot.CompoInstmap_swigregister(CompoInstmap)


from collections.abc import MutableMapping
class CompoInstmap(CompoInstmap,MutableMapping):pass
import sys
def zeFunc( moduleName ):
  elt = moduleName.split(".")
  return ( ".".join( elt[:-1] + [ "_{}".format(elt[-1]) ] ) )
sys.modules[ zeFunc( __name__ ) ].CompoInstmap_swigregister(CompoInstmap)
del zeFunc

White = _pilot.White

Grey = _pilot.Grey

Black = _pilot.Black

UNDEFINED = _pilot.UNDEFINED

INVALID = _pilot.INVALID

READY = _pilot.READY

TOLOAD = _pilot.TOLOAD

LOADED = _pilot.LOADED

TOACTIVATE = _pilot.TOACTIVATE

ACTIVATED = _pilot.ACTIVATED

DESACTIVATED = _pilot.DESACTIVATED

DONE = _pilot.DONE

SUSPENDED = _pilot.SUSPENDED

LOADFAILED = _pilot.LOADFAILED

EXECFAILED = _pilot.EXECFAILED

PAUSE = _pilot.PAUSE

TORECONNECT = _pilot.TORECONNECT

INTERNALERR = _pilot.INTERNALERR

DISABLED = _pilot.DISABLED

FAILED = _pilot.FAILED

ERROR = _pilot.ERROR

NOEVENT = _pilot.NOEVENT

START = _pilot.START

FINISH = _pilot.FINISH

ABORT = _pilot.ABORT

NOTYETINITIALIZED = _pilot.NOTYETINITIALIZED

INITIALISED = _pilot.INITIALISED

RUNNING = _pilot.RUNNING

WAITINGTASKS = _pilot.WAITINGTASKS

PAUSED = _pilot.PAUSED

FINISHED = _pilot.FINISHED

STOPPED = _pilot.STOPPED

CONTINUE = _pilot.CONTINUE

STEPBYSTEP = _pilot.STEPBYSTEP

STOPBEFORENODES = _pilot.STOPBEFORENODES

class Exception(object):
    r"""Proxy of C++ YACS::Exception class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, what, errNumber=0):
        r"""__init__(Exception self, std::string const & what, int errNumber=0) -> Exception"""
        _pilot.Exception_swiginit(self, _pilot.new_Exception(what, errNumber))

    def what(self):
        r"""what(Exception self) -> char const *"""
        return _pilot.Exception_what(self)
    __swig_destroy__ = _pilot.delete_Exception
    errNumber = property(_pilot.Exception_errNumber_get, _pilot.Exception_errNumber_set, doc=r"""errNumber : int""")

# Register Exception in _pilot:
_pilot.Exception_swigregister(Exception)

class ConversionException(Exception):
    r"""Proxy of C++ YACS::ENGINE::ConversionException class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, what, prefix=True):
        r"""__init__(ConversionException self, std::string const & what, bool prefix=True) -> ConversionException"""
        _pilot.ConversionException_swiginit(self, _pilot.new_ConversionException(what, prefix))
    __swig_destroy__ = _pilot.delete_ConversionException

# Register ConversionException in _pilot:
_pilot.ConversionException_swigregister(ConversionException)


def getRuntime():
    r"""getRuntime() -> Runtime"""
    return _pilot.getRuntime()
class Runtime(object):
    r"""Proxy of C++ YACS::ENGINE::Runtime class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def init(self):
        r"""init(Runtime self)"""
        return _pilot.Runtime_init(self)

    def fini(self):
        r"""fini(Runtime self)"""
        return _pilot.Runtime_fini(self)

    def getCatalogOfComputeNodes(self):
        r"""getCatalogOfComputeNodes(Runtime self) -> vpsi"""
        return _pilot.Runtime_getCatalogOfComputeNodes(self)

    def loadCatalog(self, sourceKind, path):
        r"""loadCatalog(Runtime self, std::string const & sourceKind, std::string const & path) -> Catalog"""
        return _pilot.Runtime_loadCatalog(self, sourceKind, path)

    def createFuncNode(self, kind, name):
        r"""createFuncNode(Runtime self, std::string const & kind, std::string const & name) -> InlineFuncNode"""
        return _pilot.Runtime_createFuncNode(self, kind, name)

    def createScriptNode(self, kind, name):
        r"""createScriptNode(Runtime self, std::string const & kind, std::string const & name) -> InlineNode"""
        return _pilot.Runtime_createScriptNode(self, kind, name)

    def createRefNode(self, kind, name):
        r"""createRefNode(Runtime self, std::string const & kind, std::string const & name) -> ServiceNode"""
        return _pilot.Runtime_createRefNode(self, kind, name)

    def createCompoNode(self, kind, name):
        r"""createCompoNode(Runtime self, std::string const & kind, std::string const & name) -> ServiceNode"""
        return _pilot.Runtime_createCompoNode(self, kind, name)

    def createSInlineNode(self, kind, name):
        r"""createSInlineNode(Runtime self, std::string const & kind, std::string const & name) -> ServiceInlineNode"""
        return _pilot.Runtime_createSInlineNode(self, kind, name)

    def createInDataNode(self, kind, name):
        r"""createInDataNode(Runtime self, std::string const & kind, std::string const & name) -> DataNode"""
        return _pilot.Runtime_createInDataNode(self, kind, name)

    def createOutDataNode(self, kind, name):
        r"""createOutDataNode(Runtime self, std::string const & kind, std::string const & name) -> DataNode"""
        return _pilot.Runtime_createOutDataNode(self, kind, name)

    def createComponentInstance(self, *args):
        r"""createComponentInstance(Runtime self, std::string const & name, std::string const & kind="") -> ComponentInstance"""
        return _pilot.Runtime_createComponentInstance(self, *args)

    def createContainer(self, *args):
        r"""createContainer(Runtime self, std::string const & kind="") -> Container"""
        return _pilot.Runtime_createContainer(self, *args)

    def createProc(self, name):
        r"""createProc(Runtime self, std::string const & name) -> Proc"""
        return _pilot.Runtime_createProc(self, name)

    def createBloc(self, name):
        r"""createBloc(Runtime self, std::string const & name) -> Bloc"""
        return _pilot.Runtime_createBloc(self, name)

    def createWhileLoop(self, name):
        r"""createWhileLoop(Runtime self, std::string const & name) -> WhileLoop"""
        return _pilot.Runtime_createWhileLoop(self, name)

    def createForLoop(self, name):
        r"""createForLoop(Runtime self, std::string const & name) -> ForLoop"""
        return _pilot.Runtime_createForLoop(self, name)

    def createForEachLoop(self, name, type):
        r"""createForEachLoop(Runtime self, std::string const & name, TypeCode type) -> ForEachLoop"""
        return _pilot.Runtime_createForEachLoop(self, name, type)

    def createForEachLoopDyn(self, name, type):
        r"""createForEachLoopDyn(Runtime self, std::string const & name, TypeCode type) -> ForEachLoopDyn"""
        return _pilot.Runtime_createForEachLoopDyn(self, name, type)

    def createOptimizerLoop(self, *args):
        r"""createOptimizerLoop(Runtime self, std::string const & name, std::string const & algLib, std::string const & factoryName, bool algInitOnFile, std::string const & kind="", Proc procForTypes=None) -> OptimizerLoop"""
        return _pilot.Runtime_createOptimizerLoop(self, *args)

    def createSwitch(self, name):
        r"""createSwitch(Runtime self, std::string const & name) -> Switch"""
        return _pilot.Runtime_createSwitch(self, name)

    def createInterfaceTc(self, id, name, ltc):
        r"""createInterfaceTc(Runtime self, std::string const & id, std::string const & name, std::list< YACS::ENGINE::TypeCodeObjref *,std::allocator< YACS::ENGINE::TypeCodeObjref * > > ltc) -> TypeCode"""
        return _pilot.Runtime_createInterfaceTc(self, id, name, ltc)

    def createSequenceTc(self, id, name, content):
        r"""createSequenceTc(Runtime self, std::string const & id, std::string const & name, TypeCode content) -> TypeCode"""
        return _pilot.Runtime_createSequenceTc(self, id, name, content)

    def createStructTc(self, id, name):
        r"""createStructTc(Runtime self, std::string const & id, std::string const & name) -> TypeCodeStruct"""
        return _pilot.Runtime_createStructTc(self, id, name)

    def createInputPort(self, name, impl, node, type):
        r"""createInputPort(Runtime self, std::string const & name, std::string const & impl, Node node, TypeCode type) -> InputPort"""
        return _pilot.Runtime_createInputPort(self, name, impl, node, type)

    def createOutputPort(self, name, impl, node, type):
        r"""createOutputPort(Runtime self, std::string const & name, std::string const & impl, Node node, TypeCode type) -> OutputPort"""
        return _pilot.Runtime_createOutputPort(self, name, impl, node, type)

    def createInputDataStreamPort(self, name, node, type):
        r"""createInputDataStreamPort(Runtime self, std::string const & name, Node node, TypeCode type) -> InputDataStreamPort"""
        return _pilot.Runtime_createInputDataStreamPort(self, name, node, type)

    def createOutputDataStreamPort(self, name, node, type):
        r"""createOutputDataStreamPort(Runtime self, std::string const & name, Node node, TypeCode type) -> OutputDataStreamPort"""
        return _pilot.Runtime_createOutputDataStreamPort(self, name, node, type)

    def adapt(self, *args):
        r"""
        adapt(Runtime self, InputPort source, std::string const & impl, TypeCode type, bool init=False) -> InputPort
        adapt(Runtime self, InPropertyPort source, std::string const & impl, TypeCode type, bool init=False) -> InputPort
        """
        return _pilot.Runtime_adapt(self, *args)

    def convertNeutral(self, type, data):
        r"""convertNeutral(Runtime self, TypeCode type, Any data) -> void *"""
        return _pilot.Runtime_convertNeutral(self, type, data)

    def convertNeutralAsString(self, type, data):
        r"""convertNeutralAsString(Runtime self, TypeCode type, Any data) -> std::string"""
        return _pilot.Runtime_convertNeutralAsString(self, type, data)

    def removeRuntime(self):
        r"""removeRuntime(Runtime self)"""
        return _pilot.Runtime_removeRuntime(self)
    __swig_destroy__ = _pilot.delete_Runtime
    _tc_stringpair = property(_pilot.Runtime__tc_stringpair_get, _pilot.Runtime__tc_stringpair_set, doc=r"""_tc_stringpair : p.YACS::ENGINE::TypeCode""")
    _tc_propvec = property(_pilot.Runtime__tc_propvec_get, _pilot.Runtime__tc_propvec_set, doc=r"""_tc_propvec : p.YACS::ENGINE::TypeCode""")

    def setCatalogLoaderFactory(self, name, factory):
        r"""setCatalogLoaderFactory(Runtime self, std::string const & name, CatalogLoader factory)"""
        return _pilot.Runtime_setCatalogLoaderFactory(self, name, factory)
    _catalogLoaderFactoryMap = property(_pilot.Runtime__catalogLoaderFactoryMap_get, _pilot.Runtime__catalogLoaderFactoryMap_set, doc=r"""_catalogLoaderFactoryMap : std::map<(std::string,p.YACS::ENGINE::CatalogLoader,std::less<(std::string)>,std::allocator<(std::pair<(q(const).std::string,p.YACS::ENGINE::CatalogLoader)>)>)>""")

    def getBuiltinCatalog(self):
        r"""getBuiltinCatalog(Runtime self) -> Catalog"""
        return _pilot.Runtime_getBuiltinCatalog(self)

    def addCatalog(self, catalog):
        r"""addCatalog(Runtime self, Catalog catalog)"""
        return _pilot.Runtime_addCatalog(self, catalog)

    def getTypeCode(self, name):
        r"""getTypeCode(Runtime self, std::string const & name) -> TypeCode"""
        return _pilot.Runtime_getTypeCode(self, name)

# Register Runtime in _pilot:
_pilot.Runtime_swigregister(Runtime)
cvar = _pilot.cvar
Runtime.RUNTIME_ENGINE_INTERACTION_IMPL_NAME = _pilot.cvar.Runtime_RUNTIME_ENGINE_INTERACTION_IMPL_NAME

class PropertyInterface(object):
    r"""Proxy of C++ YACS::ENGINE::PropertyInterface class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _pilot.delete_PropertyInterface

    def setProperty(self, name, value):
        r"""setProperty(PropertyInterface self, std::string const & name, std::string const & value)"""
        return _pilot.PropertyInterface_setProperty(self, name, value)

    def getProperty(self, name):
        r"""getProperty(PropertyInterface self, std::string const & name) -> std::string"""
        return _pilot.PropertyInterface_getProperty(self, name)

    def getProperties(self):
        r"""getProperties(PropertyInterface self) -> propmap"""
        return _pilot.PropertyInterface_getProperties(self)

    def setProperties(self, properties):
        r"""setProperties(PropertyInterface self, propmap properties)"""
        return _pilot.PropertyInterface_setProperties(self, properties)

    def __init__(self):
        r"""__init__(PropertyInterface self) -> PropertyInterface"""
        _pilot.PropertyInterface_swiginit(self, _pilot.new_PropertyInterface())

# Register PropertyInterface in _pilot:
_pilot.PropertyInterface_swigregister(PropertyInterface)

class Executor(object):
    r"""Proxy of C++ YACS::ENGINE::Executor class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""__init__(Executor self) -> Executor"""
        _pilot.Executor_swiginit(self, _pilot.new_Executor())
    __swig_destroy__ = _pilot.delete_Executor

    def RunA(self, graph, debug=0, fromScratch=True):
        r"""RunA(Executor self, Scheduler graph, int debug=0, bool fromScratch=True)"""
        return _pilot.Executor_RunA(self, graph, debug, fromScratch)

    def RunW(self, graph, debug=0, fromScratch=True):
        r"""RunW(Executor self, Scheduler graph, int debug=0, bool fromScratch=True)"""
        return _pilot.Executor_RunW(self, graph, debug, fromScratch)

    def RunB(self, graph, debug=0, fromScratch=True):
        r"""RunB(Executor self, Scheduler graph, int debug=0, bool fromScratch=True)"""
        return _pilot.Executor_RunB(self, graph, debug, fromScratch)

    def runWlm(self, graph, debug=0, fromScratch=True):
        r"""runWlm(Executor self, Scheduler graph, int debug=0, bool fromScratch=True)"""
        return _pilot.Executor_runWlm(self, graph, debug, fromScratch)

    def setKeepGoingProperty(self, newVal):
        r"""setKeepGoingProperty(Executor self, bool newVal)"""
        return _pilot.Executor_setKeepGoingProperty(self, newVal)

    def getKeepGoingProperty(self):
        r"""getKeepGoingProperty(Executor self) -> bool"""
        return _pilot.Executor_getKeepGoingProperty(self)

    def setDPLScopeSensitive(self, newVal):
        r"""setDPLScopeSensitive(Executor self, bool newVal)"""
        return _pilot.Executor_setDPLScopeSensitive(self, newVal)

    def getDPLScopeSensitive(self):
        r"""getDPLScopeSensitive(Executor self) -> bool"""
        return _pilot.Executor_getDPLScopeSensitive(self)

    def getCurrentExecMode(self):
        r"""getCurrentExecMode(Executor self) -> YACS::ExecutionMode"""
        return _pilot.Executor_getCurrentExecMode(self)

    def getExecutorState(self):
        r"""getExecutorState(Executor self) -> YACS::ExecutorState"""
        return _pilot.Executor_getExecutorState(self)

    def setExecMode(self, mode):
        r"""setExecMode(Executor self, YACS::ExecutionMode mode)"""
        return _pilot.Executor_setExecMode(self, mode)

    def setListOfBreakPoints(self, listOfBreakPoints):
        r"""setListOfBreakPoints(Executor self, std::list< std::string,std::allocator< std::string > > listOfBreakPoints)"""
        return _pilot.Executor_setListOfBreakPoints(self, listOfBreakPoints)

    def getTasksToLoad(self):
        r"""getTasksToLoad(Executor self) -> std::list< std::string,std::allocator< std::string > >"""
        return _pilot.Executor_getTasksToLoad(self)

    def setStepsToExecute(self, listToExecute):
        r"""setStepsToExecute(Executor self, std::list< std::string,std::allocator< std::string > > listToExecute) -> bool"""
        return _pilot.Executor_setStepsToExecute(self, listToExecute)

    def resumeCurrentBreakPoint(self):
        r"""resumeCurrentBreakPoint(Executor self) -> bool"""
        return _pilot.Executor_resumeCurrentBreakPoint(self)

    def isNotFinished(self):
        r"""isNotFinished(Executor self) -> bool"""
        return _pilot.Executor_isNotFinished(self)

    def stopExecution(self):
        r"""stopExecution(Executor self)"""
        return _pilot.Executor_stopExecution(self)

    def saveState(self, xmlFile):
        r"""saveState(Executor self, std::string const & xmlFile) -> bool"""
        return _pilot.Executor_saveState(self, xmlFile)

    def loadState(self):
        r"""loadState(Executor self) -> bool"""
        return _pilot.Executor_loadState(self)

    def getMaxNbOfThreads(self):
        r"""getMaxNbOfThreads(Executor self) -> int"""
        return _pilot.Executor_getMaxNbOfThreads(self)

    def setMaxNbOfThreads(self, maxNbThreads):
        r"""setMaxNbOfThreads(Executor self, int maxNbThreads)"""
        return _pilot.Executor_setMaxNbOfThreads(self, maxNbThreads)

    def getNbOfThreads(self):
        r"""getNbOfThreads(Executor self) -> int"""
        return _pilot.Executor_getNbOfThreads(self)

    def getNumberOfRunningTasks(self):
        r"""getNumberOfRunningTasks(Executor self) -> int"""
        return _pilot.Executor_getNumberOfRunningTasks(self)

    def displayDot(self, graph):
        r"""displayDot(Executor self, Scheduler graph)"""
        return _pilot.Executor_displayDot(self, graph)

    def setStopOnError(self, *args):
        r"""setStopOnError(Executor self, bool dumpRequested=False, std::string xmlFile="")"""
        return _pilot.Executor_setStopOnError(self, *args)

    def unsetStopOnError(self):
        r"""unsetStopOnError(Executor self)"""
        return _pilot.Executor_unsetStopOnError(self)

    def waitPause(self):
        r"""waitPause(Executor self)"""
        return _pilot.Executor_waitPause(self)

    def suspendASAP(self):
        r"""suspendASAP(Executor self) -> bool"""
        return _pilot.Executor_suspendASAP(self)

    def resume(self, suspended):
        r"""resume(Executor self, bool suspended)"""
        return _pilot.Executor_resume(self, suspended)
    _maxThreads = property(_pilot.Executor__maxThreads_get, _pilot.Executor__maxThreads_set, doc=r"""_maxThreads : int""")
    _threadStackSize = property(_pilot.Executor__threadStackSize_get, _pilot.Executor__threadStackSize_set, doc=r"""_threadStackSize : size_t""")

    def getTheMutexForSchedulerUpdate(self):
        r"""getTheMutexForSchedulerUpdate(Executor self) -> YACS::BASES::Mutex &"""
        return _pilot.Executor_getTheMutexForSchedulerUpdate(self)

    def loadTask(self, task, runInfo):
        r"""loadTask(Executor self, Task task, WorkloadManager::RunInfo const & runInfo)"""
        return _pilot.Executor_loadTask(self, task, runInfo)

    def runTask(self, task):
        r"""runTask(Executor self, Task task) -> YACS::Event"""
        return _pilot.Executor_runTask(self, task)

    def makeDatastreamConnections(self, task):
        r"""makeDatastreamConnections(Executor self, Task task)"""
        return _pilot.Executor_makeDatastreamConnections(self, task)

    def beginTask(self, task):
        r"""beginTask(Executor self, Task task)"""
        return _pilot.Executor_beginTask(self, task)

    def endTask(self, task, ev):
        r"""endTask(Executor self, Task task, YACS::Event ev)"""
        return _pilot.Executor_endTask(self, task, ev)

    def failTask(self, task, message):
        r"""failTask(Executor self, Task task, std::string const & message)"""
        return _pilot.Executor_failTask(self, task, message)

# Register Executor in _pilot:
_pilot.Executor_swigregister(Executor)

class ExecutorSwig(Executor):
    r"""Proxy of C++ YACS::ENGINE::ExecutorSwig class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def RunPy(self, graph, debug=0, isPyThread=True, fromscratch=True):
        r"""RunPy(ExecutorSwig self, Scheduler graph, int debug=0, bool isPyThread=True, bool fromscratch=True)"""
        return _pilot.ExecutorSwig_RunPy(self, graph, debug, isPyThread, fromscratch)

    def waitPause(self):
        r"""waitPause(ExecutorSwig self)"""
        return _pilot.ExecutorSwig_waitPause(self)

    def __init__(self):
        r"""__init__(ExecutorSwig self) -> ExecutorSwig"""
        _pilot.ExecutorSwig_swiginit(self, _pilot.new_ExecutorSwig())
    __swig_destroy__ = _pilot.delete_ExecutorSwig

# Register ExecutorSwig in _pilot:
_pilot.ExecutorSwig_swigregister(ExecutorSwig)

class RefCounter(object):
    r"""Proxy of C++ YACS::ENGINE::RefCounter class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def getRefCnt(self):
        r"""getRefCnt(RefCounter self) -> unsigned int"""
        return _pilot.RefCounter_getRefCnt(self)

    def incrRef(self):
        r"""incrRef(RefCounter self)"""
        return _pilot.RefCounter_incrRef(self)

    def decrRef(self):
        r"""decrRef(RefCounter self) -> bool"""
        return _pilot.RefCounter_decrRef(self)
    _totalCnt = property(_pilot.RefCounter__totalCnt_get, _pilot.RefCounter__totalCnt_set, doc=r"""_totalCnt : unsigned int""")
    __swig_destroy__ = _pilot.delete_RefCounter

# Register RefCounter in _pilot:
_pilot.RefCounter_swigregister(RefCounter)

class StringOnHeap(object):
    r"""Proxy of C++ YACS::ENGINE::StringOnHeap class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

# Register StringOnHeap in _pilot:
_pilot.StringOnHeap_swigregister(StringOnHeap)

class Any(RefCounter):
    r"""Proxy of C++ YACS::ENGINE::Any class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getType(self):
        r"""getType(Any self) -> TypeCode"""
        return _pilot.Any_getType(self)

    def clone(self):
        r"""clone(Any self) -> Any"""
        return _pilot.Any_clone(self)

    def __eq__(self, other):
        r"""__eq__(Any self, Any other) -> bool"""
        return _pilot.Any___eq__(self, other)

    def getIntValue(self):
        r"""getIntValue(Any self) -> int"""
        return _pilot.Any_getIntValue(self)

    def getBoolValue(self):
        r"""getBoolValue(Any self) -> bool"""
        return _pilot.Any_getBoolValue(self)

    def getDoubleValue(self):
        r"""getDoubleValue(Any self) -> double"""
        return _pilot.Any_getDoubleValue(self)

    def getStringValue(self):
        r"""getStringValue(Any self) -> std::string"""
        return _pilot.Any_getStringValue(self)

    def getBytes(self):
        r"""getBytes(Any self) -> PyObject *"""
        return _pilot.Any_getBytes(self)

    def getPyObj(self):
        r"""getPyObj(Any self) -> PyObject *"""
        return _pilot.Any_getPyObj(self)
    __swig_destroy__ = _pilot.delete_Any

# Register Any in _pilot:
_pilot.Any_swigregister(Any)

class AtomAny(Any):
    r"""Proxy of C++ YACS::ENGINE::AtomAny class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def clone(self):
        r"""clone(AtomAny self) -> Any"""
        return _pilot.AtomAny_clone(self)

    @staticmethod
    def New(*args):
        r"""
        New(char * val, YACS::ENGINE::Deallocator dealloc) -> AtomAny
        New(std::string const & val, TypeCode type) -> AtomAny
        """
        return _pilot.AtomAny_New(*args)

    def __eq__(self, other):
        r"""__eq__(AtomAny self, Any other) -> bool"""
        return _pilot.AtomAny___eq__(self, other)

    def getIntValue(self):
        r"""getIntValue(AtomAny self) -> int"""
        return _pilot.AtomAny_getIntValue(self)

    def getBoolValue(self):
        r"""getBoolValue(AtomAny self) -> bool"""
        return _pilot.AtomAny_getBoolValue(self)

    def getDoubleValue(self):
        r"""getDoubleValue(AtomAny self) -> double"""
        return _pilot.AtomAny_getDoubleValue(self)

    def getStringValue(self):
        r"""getStringValue(AtomAny self) -> std::string"""
        return _pilot.AtomAny_getStringValue(self)

    def getBytesValue(self, len):
        r"""getBytesValue(AtomAny self, std::size_t & len) -> char const *"""
        return _pilot.AtomAny_getBytesValue(self, len)

# Register AtomAny in _pilot:
_pilot.AtomAny_swigregister(AtomAny)

def AtomAny_New(*args):
    r"""
    AtomAny_New(char * val, YACS::ENGINE::Deallocator dealloc) -> AtomAny
    AtomAny_New(std::string const & val, TypeCode type) -> AtomAny
    """
    return _pilot.AtomAny_New(*args)

class SeqAlloc(object):
    r"""Proxy of C++ YACS::ENGINE::SeqAlloc class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

# Register SeqAlloc in _pilot:
_pilot.SeqAlloc_swigregister(SeqAlloc)
SeqAlloc.DFT_CHAR_VAR = _pilot.cvar.SeqAlloc_DFT_CHAR_VAR

class ComposedAny(Any):
    r"""Proxy of C++ YACS::ENGINE::ComposedAny class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setEltAtRank(self, i, elem):
        r"""setEltAtRank(ComposedAny self, int i, Any elem)"""
        return _pilot.ComposedAny_setEltAtRank(self, i, elem)
    __swig_destroy__ = _pilot.delete_ComposedAny

# Register ComposedAny in _pilot:
_pilot.ComposedAny_swigregister(ComposedAny)

class SequenceAny(ComposedAny):
    r"""Proxy of C++ YACS::ENGINE::SequenceAny class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def clear(self):
        r"""clear(SequenceAny self)"""
        return _pilot.SequenceAny_clear(self)

    def popBack(self):
        r"""popBack(SequenceAny self)"""
        return _pilot.SequenceAny_popBack(self)

    def size(self):
        r"""size(SequenceAny self) -> unsigned int"""
        return _pilot.SequenceAny_size(self)

    def pushBack(self, elem):
        r"""pushBack(SequenceAny self, Any elem)"""
        return _pilot.SequenceAny_pushBack(self, elem)

    def __eq__(self, other):
        r"""__eq__(SequenceAny self, Any other) -> bool"""
        return _pilot.SequenceAny___eq__(self, other)

    def setEltAtRank(self, i, elem):
        r"""setEltAtRank(SequenceAny self, int i, Any elem)"""
        return _pilot.SequenceAny_setEltAtRank(self, i, elem)

    def clone(self):
        r"""clone(SequenceAny self) -> Any"""
        return _pilot.SequenceAny_clone(self)

    @staticmethod
    def New(*args):
        r"""
        New(TypeCode typeOfContent) -> SequenceAny
        New(TypeCode typeOfContent, unsigned int lgth) -> SequenceAny
        """
        return _pilot.SequenceAny_New(*args)

    def getSetItems(self):
        r"""getSetItems(SequenceAny self) -> uivec"""
        return _pilot.SequenceAny_getSetItems(self)

    def removeUnsetItemsFromThis(self):
        r"""removeUnsetItemsFromThis(SequenceAny self) -> SequenceAny"""
        return _pilot.SequenceAny_removeUnsetItemsFromThis(self)

    def __getitem__(self, i):
        r"""__getitem__(SequenceAny self, int i) -> Any"""
        return _pilot.SequenceAny___getitem__(self, i)

# Register SequenceAny in _pilot:
_pilot.SequenceAny_swigregister(SequenceAny)

def SequenceAny_New(*args):
    r"""
    SequenceAny_New(TypeCode typeOfContent) -> SequenceAny
    SequenceAny_New(TypeCode typeOfContent, unsigned int lgth) -> SequenceAny
    """
    return _pilot.SequenceAny_New(*args)

class ArrayAny(ComposedAny):
    r"""Proxy of C++ YACS::ENGINE::ArrayAny class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def setEltAtRank(self, i, elem):
        r"""setEltAtRank(ArrayAny self, int i, Any elem)"""
        return _pilot.ArrayAny_setEltAtRank(self, i, elem)

    def __eq__(self, other):
        r"""__eq__(ArrayAny self, Any other) -> bool"""
        return _pilot.ArrayAny___eq__(self, other)

    def size(self):
        r"""size(ArrayAny self) -> unsigned int"""
        return _pilot.ArrayAny_size(self)

    def clone(self):
        r"""clone(ArrayAny self) -> Any"""
        return _pilot.ArrayAny_clone(self)

    @staticmethod
    def New(typeOfContent, lgth):
        r"""New(TypeCode typeOfContent, unsigned int lgth) -> ArrayAny"""
        return _pilot.ArrayAny_New(typeOfContent, lgth)

# Register ArrayAny in _pilot:
_pilot.ArrayAny_swigregister(ArrayAny)

def ArrayAny_New(typeOfContent, lgth):
    r"""ArrayAny_New(TypeCode typeOfContent, unsigned int lgth) -> ArrayAny"""
    return _pilot.ArrayAny_New(typeOfContent, lgth)

class StructAny(ComposedAny):
    r"""Proxy of C++ YACS::ENGINE::StructAny class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def clone(self):
        r"""clone(StructAny self) -> Any"""
        return _pilot.StructAny_clone(self)

    def __eq__(self, other):
        r"""__eq__(StructAny self, Any other) -> bool"""
        return _pilot.StructAny___eq__(self, other)

    @staticmethod
    def New(type):
        r"""New(TypeCodeStruct type) -> StructAny"""
        return _pilot.StructAny_New(type)

    def setEltAtRank(self, *args):
        r"""
        setEltAtRank(StructAny self, int i, Any elem)
        setEltAtRank(StructAny self, char const * key, Any elem)
        """
        return _pilot.StructAny_setEltAtRank(self, *args)

    def __getitem__(self, key):
        r"""__getitem__(StructAny self, char const * key) -> Any"""
        return _pilot.StructAny___getitem__(self, key)

# Register StructAny in _pilot:
_pilot.StructAny_swigregister(StructAny)

def StructAny_New(type):
    r"""StructAny_New(TypeCodeStruct type) -> StructAny"""
    return _pilot.StructAny_New(type)

NONE = _pilot.NONE

Double = _pilot.Double

Int = _pilot.Int

String = _pilot.String

Bool = _pilot.Bool

Objref = _pilot.Objref

Sequence = _pilot.Sequence

Array = _pilot.Array

Struct = _pilot.Struct

class TypeCode(RefCounter):
    r"""Proxy of C++ YACS::ENGINE::TypeCode class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, kind):
        r"""__init__(TypeCode self, YACS::ENGINE::DynType kind) -> TypeCode"""
        _pilot.TypeCode_swiginit(self, _pilot.new_TypeCode(kind))

    def kind(self):
        r"""kind(TypeCode self) -> YACS::ENGINE::DynType"""
        return _pilot.TypeCode_kind(self)

    def subContentType(self, lev):
        r"""subContentType(TypeCode self, int lev) -> TypeCode"""
        return _pilot.TypeCode_subContentType(self, lev)

    def clone(self):
        r"""clone(TypeCode self) -> TypeCode"""
        return _pilot.TypeCode_clone(self)

    def putReprAtPlace(self, pt, val, deepCpy):
        r"""putReprAtPlace(TypeCode self, char * pt, char const * val, bool deepCpy)"""
        return _pilot.TypeCode_putReprAtPlace(self, pt, val, deepCpy)

    def destroyZippedAny(self, data):
        r"""destroyZippedAny(TypeCode self, char * data)"""
        return _pilot.TypeCode_destroyZippedAny(self, data)

    def name(self):
        r"""name(TypeCode self) -> char const *"""
        return _pilot.TypeCode_name(self)

    def shortName(self):
        r"""shortName(TypeCode self) -> char const *"""
        return _pilot.TypeCode_shortName(self)

    def id(self):
        r"""id(TypeCode self) -> char const *"""
        return _pilot.TypeCode_id(self)

    def contentType(self):
        r"""contentType(TypeCode self) -> TypeCode"""
        return _pilot.TypeCode_contentType(self)

    def isA(self, *args):
        r"""
        isA(TypeCode self, char const * repositoryId) -> int
        isA(TypeCode self, TypeCode tc) -> int
        """
        return _pilot.TypeCode_isA(self, *args)

    def isAdaptable(self, tc):
        r"""isAdaptable(TypeCode self, TypeCode tc) -> int"""
        return _pilot.TypeCode_isAdaptable(self, tc)

    def isEquivalent(self, tc):
        r"""isEquivalent(TypeCode self, TypeCode tc) -> int"""
        return _pilot.TypeCode_isEquivalent(self, tc)

    def getSizeInByteOfAnyReprInSeq(self):
        r"""getSizeInByteOfAnyReprInSeq(TypeCode self) -> unsigned int"""
        return _pilot.TypeCode_getSizeInByteOfAnyReprInSeq(self)

    def getPrintStr(self):
        r"""getPrintStr(TypeCode self) -> std::string"""
        return _pilot.TypeCode_getPrintStr(self)

    @staticmethod
    def getKindRepr(*args):
        r"""
        getKindRepr() -> char const
        getKindRepr(YACS::ENGINE::DynType kind) -> char const *
        """
        return _pilot.TypeCode_getKindRepr(*args)

    @staticmethod
    def interfaceTc(*args):
        r"""
        interfaceTc(char const * id, char const * name) -> TypeCode
        interfaceTc(char const * id, char const * name, std::list< YACS::ENGINE::TypeCodeObjref *,std::allocator< YACS::ENGINE::TypeCodeObjref * > > const & ltc) -> TypeCode
        """
        return _pilot.TypeCode_interfaceTc(*args)

    @staticmethod
    def sequenceTc(id, name, content):
        r"""sequenceTc(char const * id, char const * name, TypeCode content) -> TypeCode"""
        return _pilot.TypeCode_sequenceTc(id, name, content)

    @staticmethod
    def structTc(id, name):
        r"""structTc(char const * id, char const * name) -> TypeCode"""
        return _pilot.TypeCode_structTc(id, name)
    __swig_destroy__ = _pilot.delete_TypeCode

# Register TypeCode in _pilot:
_pilot.TypeCode_swigregister(TypeCode)

def TypeCode_getKindRepr(*args):
    r"""
    TypeCode_getKindRepr() -> char const
    TypeCode_getKindRepr(YACS::ENGINE::DynType kind) -> char const *
    """
    return _pilot.TypeCode_getKindRepr(*args)

def TypeCode_interfaceTc(*args):
    r"""
    TypeCode_interfaceTc(char const * id, char const * name) -> TypeCode
    TypeCode_interfaceTc(char const * id, char const * name, std::list< YACS::ENGINE::TypeCodeObjref *,std::allocator< YACS::ENGINE::TypeCodeObjref * > > const & ltc) -> TypeCode
    """
    return _pilot.TypeCode_interfaceTc(*args)

def TypeCode_sequenceTc(id, name, content):
    r"""TypeCode_sequenceTc(char const * id, char const * name, TypeCode content) -> TypeCode"""
    return _pilot.TypeCode_sequenceTc(id, name, content)

def TypeCode_structTc(id, name):
    r"""TypeCode_structTc(char const * id, char const * name) -> TypeCode"""
    return _pilot.TypeCode_structTc(id, name)

class TypeCodeComposed(TypeCode):
    r"""Proxy of C++ YACS::ENGINE::TypeCodeComposed class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _pilot.delete_TypeCodeComposed

# Register TypeCodeComposed in _pilot:
_pilot.TypeCodeComposed_swigregister(TypeCodeComposed)

class TypeCodeObjref(TypeCodeComposed):
    r"""Proxy of C++ YACS::ENGINE::TypeCodeObjref class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(TypeCodeObjref self, char const * repositoryId, char const * name) -> TypeCodeObjref
        __init__(TypeCodeObjref self, char const * repositoryId, char const * name, std::list< YACS::ENGINE::TypeCodeObjref *,std::allocator< YACS::ENGINE::TypeCodeObjref * > > const & ltc) -> TypeCodeObjref
        """
        _pilot.TypeCodeObjref_swiginit(self, _pilot.new_TypeCodeObjref(*args))

    def clone(self):
        r"""clone(TypeCodeObjref self) -> TypeCode"""
        return _pilot.TypeCodeObjref_clone(self)

    def putReprAtPlace(self, pt, val, deepCpy):
        r"""putReprAtPlace(TypeCodeObjref self, char * pt, char const * val, bool deepCpy)"""
        return _pilot.TypeCodeObjref_putReprAtPlace(self, pt, val, deepCpy)

    def destroyZippedAny(self, data):
        r"""destroyZippedAny(TypeCodeObjref self, char * data)"""
        return _pilot.TypeCodeObjref_destroyZippedAny(self, data)

    def id(self):
        r"""id(TypeCodeObjref self) -> char const *"""
        return _pilot.TypeCodeObjref_id(self)

    def name(self):
        r"""name(TypeCodeObjref self) -> char const *"""
        return _pilot.TypeCodeObjref_name(self)

    def shortName(self):
        r"""shortName(TypeCodeObjref self) -> char const *"""
        return _pilot.TypeCodeObjref_shortName(self)

    def isA(self, *args):
        r"""
        isA(TypeCodeObjref self, char const * repositoryId) -> int
        isA(TypeCodeObjref self, TypeCode tc) -> int
        """
        return _pilot.TypeCodeObjref_isA(self, *args)

    def isAdaptable(self, tc):
        r"""isAdaptable(TypeCodeObjref self, TypeCode tc) -> int"""
        return _pilot.TypeCodeObjref_isAdaptable(self, tc)

    def isEquivalent(self, tc):
        r"""isEquivalent(TypeCodeObjref self, TypeCode tc) -> int"""
        return _pilot.TypeCodeObjref_isEquivalent(self, tc)
    __swig_destroy__ = _pilot.delete_TypeCodeObjref

# Register TypeCodeObjref in _pilot:
_pilot.TypeCodeObjref_swigregister(TypeCodeObjref)

class TypeCodeSeq(TypeCodeComposed):
    r"""Proxy of C++ YACS::ENGINE::TypeCodeSeq class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, repositoryId, name, content):
        r"""__init__(TypeCodeSeq self, char const * repositoryId, char const * name, TypeCode content) -> TypeCodeSeq"""
        _pilot.TypeCodeSeq_swiginit(self, _pilot.new_TypeCodeSeq(repositoryId, name, content))

    def clone(self):
        r"""clone(TypeCodeSeq self) -> TypeCode"""
        return _pilot.TypeCodeSeq_clone(self)

    def putReprAtPlace(self, pt, val, deepCpy):
        r"""putReprAtPlace(TypeCodeSeq self, char * pt, char const * val, bool deepCpy)"""
        return _pilot.TypeCodeSeq_putReprAtPlace(self, pt, val, deepCpy)

    def destroyZippedAny(self, data):
        r"""destroyZippedAny(TypeCodeSeq self, char * data)"""
        return _pilot.TypeCodeSeq_destroyZippedAny(self, data)

    def getSizeInByteOfAnyReprInSeq(self):
        r"""getSizeInByteOfAnyReprInSeq(TypeCodeSeq self) -> unsigned int"""
        return _pilot.TypeCodeSeq_getSizeInByteOfAnyReprInSeq(self)

    def id(self):
        r"""id(TypeCodeSeq self) -> char const *"""
        return _pilot.TypeCodeSeq_id(self)

    def name(self):
        r"""name(TypeCodeSeq self) -> char const *"""
        return _pilot.TypeCodeSeq_name(self)

    def shortName(self):
        r"""shortName(TypeCodeSeq self) -> char const *"""
        return _pilot.TypeCodeSeq_shortName(self)

    def getPrintStr(self):
        r"""getPrintStr(TypeCodeSeq self) -> std::string"""
        return _pilot.TypeCodeSeq_getPrintStr(self)

    def contentType(self):
        r"""contentType(TypeCodeSeq self) -> TypeCode"""
        return _pilot.TypeCodeSeq_contentType(self)

    def isA(self, tc):
        r"""isA(TypeCodeSeq self, TypeCode tc) -> int"""
        return _pilot.TypeCodeSeq_isA(self, tc)

    def isAdaptable(self, tc):
        r"""isAdaptable(TypeCodeSeq self, TypeCode tc) -> int"""
        return _pilot.TypeCodeSeq_isAdaptable(self, tc)

    def isEquivalent(self, tc):
        r"""isEquivalent(TypeCodeSeq self, TypeCode tc) -> int"""
        return _pilot.TypeCodeSeq_isEquivalent(self, tc)
    __swig_destroy__ = _pilot.delete_TypeCodeSeq

# Register TypeCodeSeq in _pilot:
_pilot.TypeCodeSeq_swigregister(TypeCodeSeq)

class TypeCodeArray(TypeCodeComposed):
    r"""Proxy of C++ YACS::ENGINE::TypeCodeArray class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, repositoryId, name, content, staticLgth):
        r"""__init__(TypeCodeArray self, char const * repositoryId, char const * name, TypeCode content, unsigned int staticLgth) -> TypeCodeArray"""
        _pilot.TypeCodeArray_swiginit(self, _pilot.new_TypeCodeArray(repositoryId, name, content, staticLgth))

    def clone(self):
        r"""clone(TypeCodeArray self) -> TypeCode"""
        return _pilot.TypeCodeArray_clone(self)

    def putReprAtPlace(self, pt, val, deepCpy):
        r"""putReprAtPlace(TypeCodeArray self, char * pt, char const * val, bool deepCpy)"""
        return _pilot.TypeCodeArray_putReprAtPlace(self, pt, val, deepCpy)

    def destroyZippedAny(self, data):
        r"""destroyZippedAny(TypeCodeArray self, char * data)"""
        return _pilot.TypeCodeArray_destroyZippedAny(self, data)

    def id(self):
        r"""id(TypeCodeArray self) -> char const *"""
        return _pilot.TypeCodeArray_id(self)

    def name(self):
        r"""name(TypeCodeArray self) -> char const *"""
        return _pilot.TypeCodeArray_name(self)

    def shortName(self):
        r"""shortName(TypeCodeArray self) -> char const *"""
        return _pilot.TypeCodeArray_shortName(self)

    def getStaticLgth(self):
        r"""getStaticLgth(TypeCodeArray self) -> unsigned int"""
        return _pilot.TypeCodeArray_getStaticLgth(self)

    def contentType(self):
        r"""contentType(TypeCodeArray self) -> TypeCode"""
        return _pilot.TypeCodeArray_contentType(self)

    def isA(self, tc):
        r"""isA(TypeCodeArray self, TypeCode tc) -> int"""
        return _pilot.TypeCodeArray_isA(self, tc)

    def isAdaptable(self, tc):
        r"""isAdaptable(TypeCodeArray self, TypeCode tc) -> int"""
        return _pilot.TypeCodeArray_isAdaptable(self, tc)

    def isEquivalent(self, tc):
        r"""isEquivalent(TypeCodeArray self, TypeCode tc) -> int"""
        return _pilot.TypeCodeArray_isEquivalent(self, tc)

    def getSizeInByteOfAnyReprInSeq(self):
        r"""getSizeInByteOfAnyReprInSeq(TypeCodeArray self) -> unsigned int"""
        return _pilot.TypeCodeArray_getSizeInByteOfAnyReprInSeq(self)
    __swig_destroy__ = _pilot.delete_TypeCodeArray

# Register TypeCodeArray in _pilot:
_pilot.TypeCodeArray_swigregister(TypeCodeArray)

class TypeCodeStruct(TypeCodeComposed):
    r"""Proxy of C++ YACS::ENGINE::TypeCodeStruct class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, repositoryId, name):
        r"""__init__(TypeCodeStruct self, char const * repositoryId, char const * name) -> TypeCodeStruct"""
        _pilot.TypeCodeStruct_swiginit(self, _pilot.new_TypeCodeStruct(repositoryId, name))

    def clone(self):
        r"""clone(TypeCodeStruct self) -> TypeCode"""
        return _pilot.TypeCodeStruct_clone(self)

    def putReprAtPlace(self, pt, val, deepCpy):
        r"""putReprAtPlace(TypeCodeStruct self, char * pt, char const * val, bool deepCpy)"""
        return _pilot.TypeCodeStruct_putReprAtPlace(self, pt, val, deepCpy)

    def destroyZippedAny(self, data):
        r"""destroyZippedAny(TypeCodeStruct self, char * data)"""
        return _pilot.TypeCodeStruct_destroyZippedAny(self, data)

    def id(self):
        r"""id(TypeCodeStruct self) -> char const *"""
        return _pilot.TypeCodeStruct_id(self)

    def name(self):
        r"""name(TypeCodeStruct self) -> char const *"""
        return _pilot.TypeCodeStruct_name(self)

    def shortName(self):
        r"""shortName(TypeCodeStruct self) -> char const *"""
        return _pilot.TypeCodeStruct_shortName(self)

    def getSizeInByteOfAnyReprInSeq(self):
        r"""getSizeInByteOfAnyReprInSeq(TypeCodeStruct self) -> unsigned int"""
        return _pilot.TypeCodeStruct_getSizeInByteOfAnyReprInSeq(self)

    def contentType(self):
        r"""contentType(TypeCodeStruct self) -> TypeCode"""
        return _pilot.TypeCodeStruct_contentType(self)

    def isA(self, *args):
        r"""
        isA(TypeCodeStruct self, char const * repositoryId) -> int
        isA(TypeCodeStruct self, TypeCode tc) -> int
        """
        return _pilot.TypeCodeStruct_isA(self, *args)

    def isAdaptable(self, tc):
        r"""isAdaptable(TypeCodeStruct self, TypeCode tc) -> int"""
        return _pilot.TypeCodeStruct_isAdaptable(self, tc)

    def isEquivalent(self, tc):
        r"""isEquivalent(TypeCodeStruct self, TypeCode tc) -> int"""
        return _pilot.TypeCodeStruct_isEquivalent(self, tc)

    def addMember(self, name, tc):
        r"""addMember(TypeCodeStruct self, std::string const & name, TypeCode tc)"""
        return _pilot.TypeCodeStruct_addMember(self, name, tc)

    def getMember(self, name, offset):
        r"""getMember(TypeCodeStruct self, std::string const & name, unsigned int & offset) -> TypeCode"""
        return _pilot.TypeCodeStruct_getMember(self, name, offset)

    def memberCount(self):
        r"""memberCount(TypeCodeStruct self) -> int"""
        return _pilot.TypeCodeStruct_memberCount(self)

    def memberName(self, index):
        r"""memberName(TypeCodeStruct self, int index) -> char const *"""
        return _pilot.TypeCodeStruct_memberName(self, index)

    def memberType(self, index):
        r"""memberType(TypeCodeStruct self, int index) -> TypeCode"""
        return _pilot.TypeCodeStruct_memberType(self, index)
    __swig_destroy__ = _pilot.delete_TypeCodeStruct

# Register TypeCodeStruct in _pilot:
_pilot.TypeCodeStruct_swigregister(TypeCodeStruct)

class Scheduler(object):
    r"""Proxy of C++ YACS::ENGINE::Scheduler class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def init(self, start=True):
        r"""init(Scheduler self, bool start=True)"""
        return _pilot.Scheduler_init(self, start)

    def isFinished(self):
        r"""isFinished(Scheduler self) -> bool"""
        return _pilot.Scheduler_isFinished(self)

    def exUpdateState(self):
        r"""exUpdateState(Scheduler self)"""
        return _pilot.Scheduler_exUpdateState(self)

    def getName(self):
        r"""getName(Scheduler self) -> std::string"""
        return _pilot.Scheduler_getName(self)

    def getTaskName(self, task):
        r"""getTaskName(Scheduler self, Task task) -> std::string"""
        return _pilot.Scheduler_getTaskName(self, task)

    def getNextTasks(self, isMore):
        r"""getNextTasks(Scheduler self, bool & isMore) -> std::vector< YACS::ENGINE::Task *,std::allocator< YACS::ENGINE::Task * > >"""
        return _pilot.Scheduler_getNextTasks(self, isMore)

    def selectRunnableTasks(self, tasks):
        r"""selectRunnableTasks(Scheduler self, std::vector< YACS::ENGINE::Task *,std::allocator< YACS::ENGINE::Task * > > & tasks)"""
        return _pilot.Scheduler_selectRunnableTasks(self, tasks)

    def notifyFrom(self, sender, event, execInst):
        r"""notifyFrom(Scheduler self, Task sender, YACS::Event event, Executor execInst)"""
        return _pilot.Scheduler_notifyFrom(self, sender, event, execInst)

    def getDeploymentTree(self):
        r"""getDeploymentTree(Scheduler self) -> DeploymentTree"""
        return _pilot.Scheduler_getDeploymentTree(self)

    def isPlacementPredictableB4Run(self):
        r"""isPlacementPredictableB4Run(Scheduler self) -> bool"""
        return _pilot.Scheduler_isPlacementPredictableB4Run(self)

    def isMultiplicitySpecified(self, value):
        r"""isMultiplicitySpecified(Scheduler self, unsigned int & value) -> bool"""
        return _pilot.Scheduler_isMultiplicitySpecified(self, value)

    def forceMultiplicity(self, value):
        r"""forceMultiplicity(Scheduler self, unsigned int value)"""
        return _pilot.Scheduler_forceMultiplicity(self, value)

    def setProperty(self, name, value):
        r"""setProperty(Scheduler self, std::string const & name, std::string const & value)"""
        return _pilot.Scheduler_setProperty(self, name, value)

    def getProperty(self, name):
        r"""getProperty(Scheduler self, std::string const & name) -> std::string"""
        return _pilot.Scheduler_getProperty(self, name)
    __swig_destroy__ = _pilot.delete_Scheduler

# Register Scheduler in _pilot:
_pilot.Scheduler_swigregister(Scheduler)

class Task(object):
    r"""Proxy of C++ YACS::ENGINE::Task class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def begin(self):
        r"""begin(Task self)"""
        return _pilot.Task_begin(self)

    def isReady(self):
        r"""isReady(Task self) -> bool"""
        return _pilot.Task_isReady(self)

    def execute(self):
        r"""execute(Task self)"""
        return _pilot.Task_execute(self)

    def load(self):
        r"""load(Task self)"""
        return _pilot.Task_load(self)

    def loaded(self):
        r"""loaded(Task self)"""
        return _pilot.Task_loaded(self)

    def connected(self):
        r"""connected(Task self)"""
        return _pilot.Task_connected(self)

    def initService(self):
        r"""initService(Task self)"""
        return _pilot.Task_initService(self)

    def connectService(self):
        r"""connectService(Task self)"""
        return _pilot.Task_connectService(self)

    def disconnectService(self):
        r"""disconnectService(Task self)"""
        return _pilot.Task_disconnectService(self)

    def getCoupledTasks(self, coupledSet):
        r"""getCoupledTasks(Task self, std::set< YACS::ENGINE::Task *,std::less< YACS::ENGINE::Task * >,std::allocator< YACS::ENGINE::Task * > > & coupledSet)"""
        return _pilot.Task_getCoupledTasks(self, coupledSet)

    def isDeployable(self):
        r"""isDeployable(Task self) -> bool"""
        return _pilot.Task_isDeployable(self)

    def getComponent(self, *args):
        r"""
        getComponent(Task self) -> ComponentInstance
        getComponent(Task self) -> ComponentInstance
        """
        return _pilot.Task_getComponent(self, *args)

    def getContainer(self):
        r"""getContainer(Task self) -> Container"""
        return _pilot.Task_getContainer(self)

    def getState(self):
        r"""getState(Task self) -> YACS::StatesForNode"""
        return _pilot.Task_getState(self)

    def finished(self):
        r"""finished(Task self)"""
        return _pilot.Task_finished(self)

    def aborted(self):
        r"""aborted(Task self)"""
        return _pilot.Task_aborted(self)

    def imposeResource(self, resource_name, container_name):
        r"""imposeResource(Task self, std::string const & resource_name, std::string const & container_name)"""
        return _pilot.Task_imposeResource(self, resource_name, container_name)

    def canAcceptImposedResource(self):
        r"""canAcceptImposedResource(Task self) -> bool"""
        return _pilot.Task_canAcceptImposedResource(self)

    def hasImposedResource(self):
        r"""hasImposedResource(Task self) -> bool"""
        return _pilot.Task_hasImposedResource(self)
    __swig_destroy__ = _pilot.delete_Task

# Register Task in _pilot:
_pilot.Task_swigregister(Task)

class Observer(object):
    r"""Proxy of C++ YACS::ENGINE::Observer class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def notifyObserver(self, object, event):
        r"""notifyObserver(Observer self, Node object, std::string const & event)"""
        return _pilot.Observer_notifyObserver(self, object, event)

    def notifyObserver2(self, object, event, something):
        r"""notifyObserver2(Observer self, Node object, std::string const & event, void * something)"""
        return _pilot.Observer_notifyObserver2(self, object, event, something)

    def notifyObserverFromClone(self, originalInstance, event, clonedInstanceGeneratingEvent):
        r"""notifyObserverFromClone(Observer self, Node originalInstance, std::string const & event, Node clonedInstanceGeneratingEvent)"""
        return _pilot.Observer_notifyObserverFromClone(self, originalInstance, event, clonedInstanceGeneratingEvent)
    __swig_destroy__ = _pilot.delete_Observer

    def __init__(self):
        r"""__init__(Observer self) -> Observer"""
        _pilot.Observer_swiginit(self, _pilot.new_Observer())

# Register Observer in _pilot:
_pilot.Observer_swigregister(Observer)

class Dispatcher(object):
    r"""Proxy of C++ YACS::ENGINE::Dispatcher class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def dispatch(self, object, event):
        r"""dispatch(Dispatcher self, Node object, std::string const & event)"""
        return _pilot.Dispatcher_dispatch(self, object, event)

    def dispatch2(self, object, event, something):
        r"""dispatch2(Dispatcher self, Node object, std::string const & event, void * something)"""
        return _pilot.Dispatcher_dispatch2(self, object, event, something)

    def dispatchFromClone(self, originalInstance, event, clonedInstanceGeneratingEvent):
        r"""dispatchFromClone(Dispatcher self, Node originalInstance, std::string const & event, Node clonedInstanceGeneratingEvent)"""
        return _pilot.Dispatcher_dispatchFromClone(self, originalInstance, event, clonedInstanceGeneratingEvent)

    def addObserver(self, observer, object, event):
        r"""addObserver(Dispatcher self, Observer observer, Node object, std::string const & event)"""
        return _pilot.Dispatcher_addObserver(self, observer, object, event)

    def removeObserver(self, observer, object, event):
        r"""removeObserver(Dispatcher self, Observer observer, Node object, std::string const & event)"""
        return _pilot.Dispatcher_removeObserver(self, observer, object, event)

    def printObservers(self):
        r"""printObservers(Dispatcher self)"""
        return _pilot.Dispatcher_printObservers(self)

    @staticmethod
    def getDispatcher():
        r"""getDispatcher() -> Dispatcher"""
        return _pilot.Dispatcher_getDispatcher()

    @staticmethod
    def setDispatcher(dispatcher):
        r"""setDispatcher(Dispatcher dispatcher)"""
        return _pilot.Dispatcher_setDispatcher(dispatcher)
    __swig_destroy__ = _pilot.delete_Dispatcher

    def __init__(self):
        r"""__init__(Dispatcher self) -> Dispatcher"""
        _pilot.Dispatcher_swiginit(self, _pilot.new_Dispatcher())

# Register Dispatcher in _pilot:
_pilot.Dispatcher_swigregister(Dispatcher)

def Dispatcher_getDispatcher():
    r"""Dispatcher_getDispatcher() -> Dispatcher"""
    return _pilot.Dispatcher_getDispatcher()

def Dispatcher_setDispatcher(dispatcher):
    r"""Dispatcher_setDispatcher(Dispatcher dispatcher)"""
    return _pilot.Dispatcher_setDispatcher(dispatcher)

class DeploymentTreeOnHeap(object):
    r"""Proxy of C++ YACS::ENGINE::DeploymentTreeOnHeap class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""__init__(DeploymentTreeOnHeap self) -> DeploymentTreeOnHeap"""
        _pilot.DeploymentTreeOnHeap_swiginit(self, _pilot.new_DeploymentTreeOnHeap())
    __swig_destroy__ = _pilot.delete_DeploymentTreeOnHeap

    def decrRef(self):
        r"""decrRef(DeploymentTreeOnHeap self) -> bool"""
        return _pilot.DeploymentTreeOnHeap_decrRef(self)

    def incrRef(self):
        r"""incrRef(DeploymentTreeOnHeap self)"""
        return _pilot.DeploymentTreeOnHeap_incrRef(self)

    def appendTask(self, task, cloner):
        r"""appendTask(DeploymentTreeOnHeap self, Task task, Scheduler cloner) -> unsigned char"""
        return _pilot.DeploymentTreeOnHeap_appendTask(self, task, cloner)

    def getNumberOfCTDefContainer(self):
        r"""getNumberOfCTDefContainer(DeploymentTreeOnHeap self) -> unsigned int"""
        return _pilot.DeploymentTreeOnHeap_getNumberOfCTDefContainer(self)

    def getNumberOfRTODefContainer(self):
        r"""getNumberOfRTODefContainer(DeploymentTreeOnHeap self) -> unsigned int"""
        return _pilot.DeploymentTreeOnHeap_getNumberOfRTODefContainer(self)

    def getNumberOfCTDefComponentInstances(self):
        r"""getNumberOfCTDefComponentInstances(DeploymentTreeOnHeap self) -> unsigned int"""
        return _pilot.DeploymentTreeOnHeap_getNumberOfCTDefComponentInstances(self)

    def getNumberOfRTODefComponentInstances(self):
        r"""getNumberOfRTODefComponentInstances(DeploymentTreeOnHeap self) -> unsigned int"""
        return _pilot.DeploymentTreeOnHeap_getNumberOfRTODefComponentInstances(self)

    def getAllContainers(self):
        r"""getAllContainers(DeploymentTreeOnHeap self) -> std::vector< YACS::ENGINE::Container *,std::allocator< YACS::ENGINE::Container * > >"""
        return _pilot.DeploymentTreeOnHeap_getAllContainers(self)

    def getAllCTDefContainers(self):
        r"""getAllCTDefContainers(DeploymentTreeOnHeap self) -> std::vector< YACS::ENGINE::Container *,std::allocator< YACS::ENGINE::Container * > >"""
        return _pilot.DeploymentTreeOnHeap_getAllCTDefContainers(self)

    def getAllRTODefContainers(self):
        r"""getAllRTODefContainers(DeploymentTreeOnHeap self) -> std::vector< YACS::ENGINE::Container *,std::allocator< YACS::ENGINE::Container * > >"""
        return _pilot.DeploymentTreeOnHeap_getAllRTODefContainers(self)

    def getTasksLinkedToComponent(self, comp):
        r"""getTasksLinkedToComponent(DeploymentTreeOnHeap self, ComponentInstance comp) -> std::vector< YACS::ENGINE::Task *,std::allocator< YACS::ENGINE::Task * > >"""
        return _pilot.DeploymentTreeOnHeap_getTasksLinkedToComponent(self, comp)

    def getTasksLinkedToContainer(self, cont):
        r"""getTasksLinkedToContainer(DeploymentTreeOnHeap self, Container cont) -> std::vector< YACS::ENGINE::Task *,std::allocator< YACS::ENGINE::Task * > >"""
        return _pilot.DeploymentTreeOnHeap_getTasksLinkedToContainer(self, cont)

    def getComponentsLinkedToContainer(self, cont):
        r"""getComponentsLinkedToContainer(DeploymentTreeOnHeap self, Container cont) -> std::vector< YACS::ENGINE::ComponentInstance *,std::allocator< YACS::ENGINE::ComponentInstance * > >"""
        return _pilot.DeploymentTreeOnHeap_getComponentsLinkedToContainer(self, cont)

    def presenceOfDefaultContainer(self):
        r"""presenceOfDefaultContainer(DeploymentTreeOnHeap self) -> bool"""
        return _pilot.DeploymentTreeOnHeap_presenceOfDefaultContainer(self)

    def getFreeDeployableTasks(self):
        r"""getFreeDeployableTasks(DeploymentTreeOnHeap self) -> std::vector< YACS::ENGINE::Task *,std::allocator< YACS::ENGINE::Task * > >"""
        return _pilot.DeploymentTreeOnHeap_getFreeDeployableTasks(self)

# Register DeploymentTreeOnHeap in _pilot:
_pilot.DeploymentTreeOnHeap_swigregister(DeploymentTreeOnHeap)

class DeploymentTree(object):
    r"""Proxy of C++ YACS::ENGINE::DeploymentTree class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _pilot.delete_DeploymentTree

    def __init__(self, *args):
        r"""
        __init__(DeploymentTree self) -> DeploymentTree
        __init__(DeploymentTree self, DeploymentTree other) -> DeploymentTree
        """
        _pilot.DeploymentTree_swiginit(self, _pilot.new_DeploymentTree(*args))

    def appendTask(self, task, cloner):
        r"""appendTask(DeploymentTree self, Task task, Scheduler cloner) -> unsigned char"""
        return _pilot.DeploymentTree_appendTask(self, task, cloner)

    def getNumberOfCTDefContainer(self):
        r"""getNumberOfCTDefContainer(DeploymentTree self) -> unsigned int"""
        return _pilot.DeploymentTree_getNumberOfCTDefContainer(self)

    def getNumberOfRTODefContainer(self):
        r"""getNumberOfRTODefContainer(DeploymentTree self) -> unsigned int"""
        return _pilot.DeploymentTree_getNumberOfRTODefContainer(self)

    def getNumberOfCTDefComponentInstances(self):
        r"""getNumberOfCTDefComponentInstances(DeploymentTree self) -> unsigned int"""
        return _pilot.DeploymentTree_getNumberOfCTDefComponentInstances(self)

    def getNumberOfRTODefComponentInstances(self):
        r"""getNumberOfRTODefComponentInstances(DeploymentTree self) -> unsigned int"""
        return _pilot.DeploymentTree_getNumberOfRTODefComponentInstances(self)

    def presenceOfDefaultContainer(self):
        r"""presenceOfDefaultContainer(DeploymentTree self) -> bool"""
        return _pilot.DeploymentTree_presenceOfDefaultContainer(self)

    def getAllContainers(self):
        r"""getAllContainers(DeploymentTree self) -> std::vector< YACS::ENGINE::Container *,std::allocator< YACS::ENGINE::Container * > >"""
        return _pilot.DeploymentTree_getAllContainers(self)

    def getAllCTDefContainers(self):
        r"""getAllCTDefContainers(DeploymentTree self) -> std::vector< YACS::ENGINE::Container *,std::allocator< YACS::ENGINE::Container * > >"""
        return _pilot.DeploymentTree_getAllCTDefContainers(self)

    def getAllRTODefContainers(self):
        r"""getAllRTODefContainers(DeploymentTree self) -> std::vector< YACS::ENGINE::Container *,std::allocator< YACS::ENGINE::Container * > >"""
        return _pilot.DeploymentTree_getAllRTODefContainers(self)

    def getTasksLinkedToComponent(self, comp):
        r"""getTasksLinkedToComponent(DeploymentTree self, ComponentInstance comp) -> std::vector< YACS::ENGINE::Task *,std::allocator< YACS::ENGINE::Task * > >"""
        return _pilot.DeploymentTree_getTasksLinkedToComponent(self, comp)

    def getTasksLinkedToContainer(self, cont):
        r"""getTasksLinkedToContainer(DeploymentTree self, Container cont) -> std::vector< YACS::ENGINE::Task *,std::allocator< YACS::ENGINE::Task * > >"""
        return _pilot.DeploymentTree_getTasksLinkedToContainer(self, cont)

    def getComponentsLinkedToContainer(self, cont):
        r"""getComponentsLinkedToContainer(DeploymentTree self, Container cont) -> std::vector< YACS::ENGINE::ComponentInstance *,std::allocator< YACS::ENGINE::ComponentInstance * > >"""
        return _pilot.DeploymentTree_getComponentsLinkedToContainer(self, cont)

    def isNull(self):
        r"""isNull(DeploymentTree self) -> bool"""
        return _pilot.DeploymentTree_isNull(self)

    def getFreeDeployableTasks(self):
        r"""getFreeDeployableTasks(DeploymentTree self) -> std::vector< YACS::ENGINE::Task *,std::allocator< YACS::ENGINE::Task * > >"""
        return _pilot.DeploymentTree_getFreeDeployableTasks(self)
    NULL_TASK = _pilot.DeploymentTree_NULL_TASK
    
    APPEND_OK = _pilot.DeploymentTree_APPEND_OK
    
    NULL_TREE = _pilot.DeploymentTree_NULL_TREE
    
    ALREADY_IN_TREE = _pilot.DeploymentTree_ALREADY_IN_TREE
    
    NOT_DEPLOYABLE_TASK = _pilot.DeploymentTree_NOT_DEPLOYABLE_TASK
    
    DEPLOYABLE_BUT_NOT_SPECIFIED = _pilot.DeploymentTree_DEPLOYABLE_BUT_NOT_SPECIFIED
    
    DUP_TASK_NOT_COMPATIBLE_WITH_EXISTING_TREE = _pilot.DeploymentTree_DUP_TASK_NOT_COMPATIBLE_WITH_EXISTING_TREE
    

# Register DeploymentTree in _pilot:
_pilot.DeploymentTree_swigregister(DeploymentTree)

class Port(object):
    r"""Proxy of C++ YACS::ENGINE::Port class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _pilot.delete_Port

    def getNode(self):
        r"""getNode(Port self) -> Node"""
        return _pilot.Port_getNode(self)

    def getNameOfTypeOfCurrentInstance(self):
        r"""getNameOfTypeOfCurrentInstance(Port self) -> std::string"""
        return _pilot.Port_getNameOfTypeOfCurrentInstance(self)

    def getNumId(self):
        r"""getNumId(Port self) -> int"""
        return _pilot.Port_getNumId(self)

    def typeName(self):
        r"""typeName(Port self) -> std::string"""
        return _pilot.Port_typeName(self)

    def modified(self):
        r"""modified(Port self)"""
        return _pilot.Port_modified(self)

    def __lt__(self, other):
        r"""__lt__(Port self, Port other) -> int"""
        return _pilot.Port___lt__(self, other)

    def __gt__(self, other):
        r"""__gt__(Port self, Port other) -> int"""
        return _pilot.Port___gt__(self, other)

    def __ne__(self, other):
        r"""__ne__(Port self, Port other) -> int"""
        return _pilot.Port___ne__(self, other)

    def __eq__(self, other):
        r"""__eq__(Port self, Port other) -> int"""
        return _pilot.Port___eq__(self, other)

    def __le__(self, other):
        r"""__le__(Port self, Port other) -> int"""
        return _pilot.Port___le__(self, other)

    def __ge__(self, other):
        r"""__ge__(Port self, Port other) -> int"""
        return _pilot.Port___ge__(self, other)

    def ptr(self):
        r"""ptr(Port self) -> long"""
        return _pilot.Port_ptr(self)

# Register Port in _pilot:
_pilot.Port_swigregister(Port)

DATAFLOW = _pilot.DATAFLOW

DATASTREAM = _pilot.DATASTREAM

class DataPort(Port):
    r"""Proxy of C++ YACS::ENGINE::DataPort class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def edGetType(self):
        r"""edGetType(DataPort self) -> TypeCode"""
        return _pilot.DataPort_edGetType(self)

    def edSetType(self, type):
        r"""edSetType(DataPort self, TypeCode type)"""
        return _pilot.DataPort_edSetType(self, type)

    def getName(self):
        r"""getName(DataPort self) -> std::string"""
        return _pilot.DataPort_getName(self)

    def setName(self, theName):
        r"""setName(DataPort self, std::string theName)"""
        return _pilot.DataPort_setName(self, theName)

    def getNameOfTypeOfCurrentInstance(self):
        r"""getNameOfTypeOfCurrentInstance(DataPort self) -> std::string"""
        return _pilot.DataPort_getNameOfTypeOfCurrentInstance(self)

    def getTypeOfChannel(self):
        r"""getTypeOfChannel(DataPort self) -> YACS::ENGINE::TypeOfChannel"""
        return _pilot.DataPort_getTypeOfChannel(self)

    def isDifferentTypeOf(self, other):
        r"""isDifferentTypeOf(DataPort self, DataPort other) -> bool"""
        return _pilot.DataPort_isDifferentTypeOf(self, other)

    def edRemoveAllLinksLinkedWithMe(self):
        r"""edRemoveAllLinksLinkedWithMe(DataPort self)"""
        return _pilot.DataPort_edRemoveAllLinksLinkedWithMe(self)

    def typeName(self):
        r"""typeName(DataPort self) -> std::string"""
        return _pilot.DataPort_typeName(self)

    def getAsString(self):
        r"""getAsString(DataPort self) -> std::string"""
        return _pilot.DataPort_getAsString(self)

    @staticmethod
    def isCrossingType(historyOfLink):
        r"""isCrossingType(std::vector< YACS::ENGINE::DataPort *,std::allocator< YACS::ENGINE::DataPort * > > const & historyOfLink) -> DataPort"""
        return _pilot.DataPort_isCrossingType(historyOfLink)

# Register DataPort in _pilot:
_pilot.DataPort_swigregister(DataPort)
DataPort.NAME = _pilot.cvar.DataPort_NAME

def DataPort_isCrossingType(historyOfLink):
    r"""DataPort_isCrossingType(std::vector< YACS::ENGINE::DataPort *,std::allocator< YACS::ENGINE::DataPort * > > const & historyOfLink) -> DataPort"""
    return _pilot.DataPort_isCrossingType(historyOfLink)

class InPort(DataPort):
    r"""Proxy of C++ YACS::ENGINE::InPort class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getPublicRepresentant(self):
        r"""getPublicRepresentant(InPort self) -> InPort"""
        return _pilot.InPort_getPublicRepresentant(self)

    def edGetNumberOfLinks(self):
        r"""edGetNumberOfLinks(InPort self) -> int"""
        return _pilot.InPort_edGetNumberOfLinks(self)

    def edSetOutPort(self):
        r"""edSetOutPort(InPort self) -> std::set< YACS::ENGINE::OutPort *,std::less< YACS::ENGINE::OutPort * >,std::allocator< YACS::ENGINE::OutPort * > >"""
        return _pilot.InPort_edSetOutPort(self)

    def canSafelySqueezeMemory(self):
        r"""canSafelySqueezeMemory(InPort self) -> bool"""
        return _pilot.InPort_canSafelySqueezeMemory(self)

    def isBackLinked(self):
        r"""isBackLinked(InPort self) -> bool"""
        return _pilot.InPort_isBackLinked(self)
    __swig_destroy__ = _pilot.delete_InPort

    def typeName(self):
        r"""typeName(InPort self) -> std::string"""
        return _pilot.InPort_typeName(self)

# Register InPort in _pilot:
_pilot.InPort_swigregister(InPort)

class OutPort(DataPort):
    r"""Proxy of C++ YACS::ENGINE::OutPort class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def checkConsistency(self, info):
        r"""checkConsistency(OutPort self, LinkInfo info)"""
        return _pilot.OutPort_checkConsistency(self, info)

    def edGetNumberOfOutLinks(self):
        r"""edGetNumberOfOutLinks(OutPort self) -> int"""
        return _pilot.OutPort_edGetNumberOfOutLinks(self)

    def edSetInPort(self):
        r"""edSetInPort(OutPort self) -> std::set< YACS::ENGINE::InPort *,std::less< YACS::ENGINE::InPort * >,std::allocator< YACS::ENGINE::InPort * > >"""
        return _pilot.OutPort_edSetInPort(self)

    def isAlreadyLinkedWith(self, withp):
        r"""isAlreadyLinkedWith(OutPort self, InPort withp) -> bool"""
        return _pilot.OutPort_isAlreadyLinkedWith(self, withp)

    def getAllRepresented(self, represented):
        r"""getAllRepresented(OutPort self, std::set< YACS::ENGINE::OutPort *,std::less< YACS::ENGINE::OutPort * >,std::allocator< YACS::ENGINE::OutPort * > > & represented)"""
        return _pilot.OutPort_getAllRepresented(self, represented)

    def addInPort(self, inPort):
        r"""addInPort(OutPort self, InPort inPort) -> bool"""
        return _pilot.OutPort_addInPort(self, inPort)

    def removeInPort(self, inPort, forward):
        r"""removeInPort(OutPort self, InPort inPort, bool forward) -> int"""
        return _pilot.OutPort_removeInPort(self, inPort, forward)
    __swig_destroy__ = _pilot.delete_OutPort

    def calculateHistoryOfLinkWith(self, end):
        r"""calculateHistoryOfLinkWith(OutPort self, InPort end) -> std::vector< YACS::ENGINE::DataPort *,std::allocator< YACS::ENGINE::DataPort * > >"""
        return _pilot.OutPort_calculateHistoryOfLinkWith(self, end)

    def typeName(self):
        r"""typeName(OutPort self) -> std::string"""
        return _pilot.OutPort_typeName(self)

# Register OutPort in _pilot:
_pilot.OutPort_swigregister(OutPort)

class InGate(Port):
    r"""Proxy of C++ YACS::ENGINE::InGate class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, node):
        r"""__init__(InGate self, Node node) -> InGate"""
        _pilot.InGate_swiginit(self, _pilot.new_InGate(node))
    __swig_destroy__ = _pilot.delete_InGate

    def getNameOfTypeOfCurrentInstance(self):
        r"""getNameOfTypeOfCurrentInstance(InGate self) -> std::string"""
        return _pilot.InGate_getNameOfTypeOfCurrentInstance(self)

    def exNotifyFromPrecursor(self, fromgate):
        r"""exNotifyFromPrecursor(InGate self, OutGate fromgate)"""
        return _pilot.InGate_exNotifyFromPrecursor(self, fromgate)

    def edMapOutGate(self):
        r"""edMapOutGate(InGate self) -> std::list< std::pair< YACS::ENGINE::OutGate *,bool >,std::allocator< std::pair< YACS::ENGINE::OutGate *,bool > > > &"""
        return _pilot.InGate_edMapOutGate(self)

    def edAppendPrecursor(self, fromgate):
        r"""edAppendPrecursor(InGate self, OutGate fromgate)"""
        return _pilot.InGate_edAppendPrecursor(self, fromgate)

    def edRemovePrecursor(self, fromgate):
        r"""edRemovePrecursor(InGate self, OutGate fromgate)"""
        return _pilot.InGate_edRemovePrecursor(self, fromgate)

    def getNumberOfBackLinks(self):
        r"""getNumberOfBackLinks(InGate self) -> int"""
        return _pilot.InGate_getNumberOfBackLinks(self)

    def edDisconnectAllLinksToMe(self):
        r"""edDisconnectAllLinksToMe(InGate self)"""
        return _pilot.InGate_edDisconnectAllLinksToMe(self)

    def exNotifyFailed(self):
        r"""exNotifyFailed(InGate self)"""
        return _pilot.InGate_exNotifyFailed(self)

    def exNotifyDisabled(self):
        r"""exNotifyDisabled(InGate self)"""
        return _pilot.InGate_exNotifyDisabled(self)

    def exReset(self):
        r"""exReset(InGate self)"""
        return _pilot.InGate_exReset(self)

    def exIsReady(self):
        r"""exIsReady(InGate self) -> bool"""
        return _pilot.InGate_exIsReady(self)

    def getBackLinks(self):
        r"""getBackLinks(InGate self) -> std::list< YACS::ENGINE::OutGate *,std::allocator< YACS::ENGINE::OutGate * > >"""
        return _pilot.InGate_getBackLinks(self)

    def setPrecursorDone(self, fromgate):
        r"""setPrecursorDone(InGate self, OutGate fromgate)"""
        return _pilot.InGate_setPrecursorDone(self, fromgate)

    def typeName(self):
        r"""typeName(InGate self) -> std::string"""
        return _pilot.InGate_typeName(self)

# Register InGate in _pilot:
_pilot.InGate_swigregister(InGate)

class OutGate(Port):
    r"""Proxy of C++ YACS::ENGINE::OutGate class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, node):
        r"""__init__(OutGate self, Node node) -> OutGate"""
        _pilot.OutGate_swiginit(self, _pilot.new_OutGate(node))

    def getNameOfTypeOfCurrentInstance(self):
        r"""getNameOfTypeOfCurrentInstance(OutGate self) -> std::string"""
        return _pilot.OutGate_getNameOfTypeOfCurrentInstance(self)

    def exReset(self):
        r"""exReset(OutGate self)"""
        return _pilot.OutGate_exReset(self)

    def exNotifyDone(self):
        r"""exNotifyDone(OutGate self)"""
        return _pilot.OutGate_exNotifyDone(self)

    def exNotifyFailed(self):
        r"""exNotifyFailed(OutGate self)"""
        return _pilot.OutGate_exNotifyFailed(self)

    def exNotifyDisabled(self):
        r"""exNotifyDisabled(OutGate self)"""
        return _pilot.OutGate_exNotifyDisabled(self)

    def edDisconnectAllLinksFromMe(self):
        r"""edDisconnectAllLinksFromMe(OutGate self)"""
        return _pilot.OutGate_edDisconnectAllLinksFromMe(self)

    def edAddInGate(self, inGate):
        r"""edAddInGate(OutGate self, InGate inGate) -> bool"""
        return _pilot.OutGate_edAddInGate(self, inGate)

    def edMapInGate(self):
        r"""edMapInGate(OutGate self) -> listpairingatebool"""
        return _pilot.OutGate_edMapInGate(self)

    def edSetInGate(self):
        r"""edSetInGate(OutGate self) -> std::list< YACS::ENGINE::InGate *,std::allocator< YACS::ENGINE::InGate * > >"""
        return _pilot.OutGate_edSetInGate(self)

    def edRemoveInGate(self, inGate, coherenceWithInGate=True):
        r"""edRemoveInGate(OutGate self, InGate inGate, bool coherenceWithInGate=True)"""
        return _pilot.OutGate_edRemoveInGate(self, inGate, coherenceWithInGate)

    def getNbOfInGatesConnected(self):
        r"""getNbOfInGatesConnected(OutGate self) -> int"""
        return _pilot.OutGate_getNbOfInGatesConnected(self)

    def isAlreadyInSet(self, inGate):
        r"""isAlreadyInSet(OutGate self, InGate inGate) -> bool"""
        return _pilot.OutGate_isAlreadyInSet(self, inGate)

    def typeName(self):
        r"""typeName(OutGate self) -> std::string"""
        return _pilot.OutGate_typeName(self)
    __swig_destroy__ = _pilot.delete_OutGate

# Register OutGate in _pilot:
_pilot.OutGate_swigregister(OutGate)
OutGate.NAME = _pilot.cvar.OutGate_NAME

class DataFlowPort(DataPort):
    r"""Proxy of C++ YACS::ENGINE::DataFlowPort class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getNameOfTypeOfCurrentInstance(self):
        r"""getNameOfTypeOfCurrentInstance(DataFlowPort self) -> std::string"""
        return _pilot.DataFlowPort_getNameOfTypeOfCurrentInstance(self)

    def getTypeOfChannel(self):
        r"""getTypeOfChannel(DataFlowPort self) -> YACS::ENGINE::TypeOfChannel"""
        return _pilot.DataFlowPort_getTypeOfChannel(self)
    __swig_destroy__ = _pilot.delete_DataFlowPort

    def typeName(self):
        r"""typeName(DataFlowPort self) -> std::string"""
        return _pilot.DataFlowPort_typeName(self)

    def valToStr(self):
        r"""valToStr(DataFlowPort self) -> std::string"""
        return _pilot.DataFlowPort_valToStr(self)

    def valFromStr(self, valstr):
        r"""valFromStr(DataFlowPort self, std::string valstr)"""
        return _pilot.DataFlowPort_valFromStr(self, valstr)

# Register DataFlowPort in _pilot:
_pilot.DataFlowPort_swigregister(DataFlowPort)
DataFlowPort.NAME = _pilot.cvar.DataFlowPort_NAME

class DataStreamPort(DataPort):
    r"""Proxy of C++ YACS::ENGINE::DataStreamPort class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getNameOfTypeOfCurrentInstance(self):
        r"""getNameOfTypeOfCurrentInstance(DataStreamPort self) -> std::string"""
        return _pilot.DataStreamPort_getNameOfTypeOfCurrentInstance(self)

    def getTypeOfChannel(self):
        r"""getTypeOfChannel(DataStreamPort self) -> YACS::ENGINE::TypeOfChannel"""
        return _pilot.DataStreamPort_getTypeOfChannel(self)

    def setProperty(self, name, value):
        r"""setProperty(DataStreamPort self, std::string const & name, std::string const & value)"""
        return _pilot.DataStreamPort_setProperty(self, name, value)

    def setProperties(self, properties):
        r"""setProperties(DataStreamPort self, propmap properties)"""
        return _pilot.DataStreamPort_setProperties(self, properties)

    def getProperty(self, name):
        r"""getProperty(DataStreamPort self, std::string const & name) -> std::string"""
        return _pilot.DataStreamPort_getProperty(self, name)

    def getProperties(self):
        r"""getProperties(DataStreamPort self) -> propmap"""
        return _pilot.DataStreamPort_getProperties(self)

    def initPortProperties(self):
        r"""initPortProperties(DataStreamPort self)"""
        return _pilot.DataStreamPort_initPortProperties(self)
    __swig_destroy__ = _pilot.delete_DataStreamPort

    def typeName(self):
        r"""typeName(DataStreamPort self) -> std::string"""
        return _pilot.DataStreamPort_typeName(self)

# Register DataStreamPort in _pilot:
_pilot.DataStreamPort_swigregister(DataStreamPort)
DataStreamPort.NAME = _pilot.cvar.DataStreamPort_NAME

I_CF_USELESS = _pilot.I_CF_USELESS

I_USELESS = _pilot.I_USELESS

I_BACK = _pilot.I_BACK

I_BACK_USELESS = _pilot.I_BACK_USELESS

I_BACK_CRAZY = _pilot.I_BACK_CRAZY

I_DFDS = _pilot.I_DFDS

I_ALL = _pilot.I_ALL

W_COLLAPSE = _pilot.W_COLLAPSE

W_COLLAPSE_AND_USELESS = _pilot.W_COLLAPSE_AND_USELESS

W_COLLAPSE_EL = _pilot.W_COLLAPSE_EL

W_COLLAPSE_EL_AND_USELESS = _pilot.W_COLLAPSE_EL_AND_USELESS

W_BACK_COLLAPSE = _pilot.W_BACK_COLLAPSE

W_BACK_COLLAPSE_AND_USELESS = _pilot.W_BACK_COLLAPSE_AND_USELESS

W_BACK_COLLAPSE_EL = _pilot.W_BACK_COLLAPSE_EL

W_BACK_COLLAPSE_EL_AND_USELESS = _pilot.W_BACK_COLLAPSE_EL_AND_USELESS

W_ALL = _pilot.W_ALL

E_NEVER_SET_INPUTPORT = _pilot.E_NEVER_SET_INPUTPORT

E_ONLY_BACKWARD_DEFINED = _pilot.E_ONLY_BACKWARD_DEFINED

E_DS_LINK_UNESTABLISHABLE = _pilot.E_DS_LINK_UNESTABLISHABLE

E_COLLAPSE_DFDS = _pilot.E_COLLAPSE_DFDS

E_COLLAPSE_DS = _pilot.E_COLLAPSE_DS

E_UNPREDICTABLE_FED = _pilot.E_UNPREDICTABLE_FED

E_UNCOMPLETE_SW = _pilot.E_UNCOMPLETE_SW

E_ALL = _pilot.E_ALL

class LinkInfo(object):
    r"""Proxy of C++ YACS::ENGINE::LinkInfo class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, level):
        r"""__init__(LinkInfo self, unsigned char level) -> LinkInfo"""
        _pilot.LinkInfo_swiginit(self, _pilot.new_LinkInfo(level))

    def clearAll(self):
        r"""clearAll(LinkInfo self)"""
        return _pilot.LinkInfo_clearAll(self)

    def startCollapseTransac(self):
        r"""startCollapseTransac(LinkInfo self)"""
        return _pilot.LinkInfo_startCollapseTransac(self)

    def endCollapseTransac(self):
        r"""endCollapseTransac(LinkInfo self)"""
        return _pilot.LinkInfo_endCollapseTransac(self)

    def setPointOfView(self, pov):
        r"""setPointOfView(LinkInfo self, ComposedNode pov)"""
        return _pilot.LinkInfo_setPointOfView(self, pov)

    def pushInfoLink(self, semStart, end, reason):
        r"""pushInfoLink(LinkInfo self, OutPort semStart, InPort end, YACS::ENGINE::InfoReason reason)"""
        return _pilot.LinkInfo_pushInfoLink(self, semStart, end, reason)

    def pushWarnLink(self, semStart, end, reason):
        r"""pushWarnLink(LinkInfo self, OutPort semStart, InPort end, YACS::ENGINE::WarnReason reason)"""
        return _pilot.LinkInfo_pushWarnLink(self, semStart, end, reason)

    def pushErrLink(self, semStart, end, reason):
        r"""pushErrLink(LinkInfo self, OutPort semStart, InPort end, YACS::ENGINE::ErrReason reason)"""
        return _pilot.LinkInfo_pushErrLink(self, semStart, end, reason)

    def pushErrSwitch(self, collector):
        r"""pushErrSwitch(LinkInfo self, CollectorSwOutPort collector)"""
        return _pilot.LinkInfo_pushErrSwitch(self, collector)

    def pushUselessCFLink(self, start, end):
        r"""pushUselessCFLink(LinkInfo self, Node start, Node end)"""
        return _pilot.LinkInfo_pushUselessCFLink(self, start, end)

    def takeDecision(self):
        r"""takeDecision(LinkInfo self)"""
        return _pilot.LinkInfo_takeDecision(self)

    def getGlobalRepr(self):
        r"""getGlobalRepr(LinkInfo self) -> std::string"""
        return _pilot.LinkInfo_getGlobalRepr(self)

    def getInfoRepr(self):
        r"""getInfoRepr(LinkInfo self) -> std::string"""
        return _pilot.LinkInfo_getInfoRepr(self)

    def getWarnRepr(self):
        r"""getWarnRepr(LinkInfo self) -> std::string"""
        return _pilot.LinkInfo_getWarnRepr(self)

    def getErrRepr(self):
        r"""getErrRepr(LinkInfo self) -> std::string"""
        return _pilot.LinkInfo_getErrRepr(self)

    def areWarningsOrErrors(self):
        r"""areWarningsOrErrors(LinkInfo self) -> bool"""
        return _pilot.LinkInfo_areWarningsOrErrors(self)

    def getNumberOfInfoLinks(self, reason):
        r"""getNumberOfInfoLinks(LinkInfo self, YACS::ENGINE::InfoReason reason) -> unsigned int"""
        return _pilot.LinkInfo_getNumberOfInfoLinks(self, reason)

    def getNumberOfWarnLinksGrp(self, reason):
        r"""getNumberOfWarnLinksGrp(LinkInfo self, YACS::ENGINE::WarnReason reason) -> unsigned int"""
        return _pilot.LinkInfo_getNumberOfWarnLinksGrp(self, reason)

    def getNumberOfErrLinks(self, reason):
        r"""getNumberOfErrLinks(LinkInfo self, YACS::ENGINE::ErrReason reason) -> unsigned int"""
        return _pilot.LinkInfo_getNumberOfErrLinks(self, reason)

    def getInfoUselessLinks(self):
        r"""getInfoUselessLinks(LinkInfo self) -> std::set< std::pair< YACS::ENGINE::Node *,YACS::ENGINE::Node * >,std::less< std::pair< YACS::ENGINE::Node *,YACS::ENGINE::Node * > >,std::allocator< std::pair< YACS::ENGINE::Node *,YACS::ENGINE::Node * > > >"""
        return _pilot.LinkInfo_getInfoUselessLinks(self)

    def getInfoLink(self, id, reason):
        r"""getInfoLink(LinkInfo self, unsigned int id, YACS::ENGINE::InfoReason reason) -> std::pair< YACS::ENGINE::OutPort *,YACS::ENGINE::InPort * >"""
        return _pilot.LinkInfo_getInfoLink(self, id, reason)

    def getWarnLink(self, id, reason):
        r"""getWarnLink(LinkInfo self, unsigned int id, YACS::ENGINE::WarnReason reason) -> linksvec"""
        return _pilot.LinkInfo_getWarnLink(self, id, reason)

    def getErrLink(self, id, reason):
        r"""getErrLink(LinkInfo self, unsigned int id, YACS::ENGINE::ErrReason reason) -> std::pair< YACS::ENGINE::OutPort *,YACS::ENGINE::InPort * >"""
        return _pilot.LinkInfo_getErrLink(self, id, reason)
    ALL_STOP_ASAP = _pilot.LinkInfo_ALL_STOP_ASAP
    
    ALL_DONT_STOP = _pilot.LinkInfo_ALL_DONT_STOP
    
    WARN_ONLY_DONT_STOP = _pilot.LinkInfo_WARN_ONLY_DONT_STOP
    
    __swig_destroy__ = _pilot.delete_LinkInfo

# Register LinkInfo in _pilot:
_pilot.LinkInfo_swigregister(LinkInfo)

class Logger(object):
    r"""Proxy of C++ YACS::ENGINE::Logger class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, name):
        r"""__init__(Logger self, std::string const & name) -> Logger"""
        _pilot.Logger_swiginit(self, _pilot.new_Logger(name))
    __swig_destroy__ = _pilot.delete_Logger

    def getName(self):
        r"""getName(Logger self) -> std::string const &"""
        return _pilot.Logger_getName(self)

    def log(self, level, message, filename, line):
        r"""log(Logger self, int level, std::string const & message, char const * filename, int line)"""
        return _pilot.Logger_log(self, level, message, filename, line)

    def error(self, message, filename, line):
        r"""error(Logger self, std::string const & message, char const * filename, int line)"""
        return _pilot.Logger_error(self, message, filename, line)

    def fatal(self, message, filename, line):
        r"""fatal(Logger self, std::string const & message, char const * filename, int line)"""
        return _pilot.Logger_fatal(self, message, filename, line)

    def warning(self, message, filename, line):
        r"""warning(Logger self, std::string const & message, char const * filename, int line)"""
        return _pilot.Logger_warning(self, message, filename, line)

    def makeRecord(self, name, level, message, filename, line):
        r"""makeRecord(Logger self, std::string const & name, int level, std::string const & message, char const * filename, int line) -> YACS::ENGINE::LogRecord *"""
        return _pilot.Logger_makeRecord(self, name, level, message, filename, line)

    def handle(self, record):
        r"""handle(Logger self, YACS::ENGINE::LogRecord * record)"""
        return _pilot.Logger_handle(self, record)

    def reset(self):
        r"""reset(Logger self)"""
        return _pilot.Logger_reset(self)

    def getStr(self):
        r"""getStr(Logger self) -> std::string"""
        return _pilot.Logger_getStr(self)

    def isEmpty(self):
        r"""isEmpty(Logger self) -> bool"""
        return _pilot.Logger_isEmpty(self)

    def hasErrors(self):
        r"""hasErrors(Logger self) -> bool"""
        return _pilot.Logger_hasErrors(self)

# Register Logger in _pilot:
_pilot.Logger_swigregister(Logger)

class ComponentInstance(PropertyInterface, RefCounter):
    r"""Proxy of C++ YACS::ENGINE::ComponentInstance class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pilot.delete_ComponentInstance

    def getCompoName(self):
        r"""getCompoName(ComponentInstance self) -> std::string const &"""
        return _pilot.ComponentInstance_getCompoName(self)

    def getInstanceName(self):
        r"""getInstanceName(ComponentInstance self) -> std::string const &"""
        return _pilot.ComponentInstance_getInstanceName(self)

    def setName(self, name):
        r"""setName(ComponentInstance self, std::string const & name)"""
        return _pilot.ComponentInstance_setName(self, name)

    def setAnonymous(self, anon):
        r"""setAnonymous(ComponentInstance self, bool anon)"""
        return _pilot.ComponentInstance_setAnonymous(self, anon)

    def isAnonymous(self):
        r"""isAnonymous(ComponentInstance self) -> bool"""
        return _pilot.ComponentInstance_isAnonymous(self)

    def getNumId(self):
        r"""getNumId(ComponentInstance self) -> int"""
        return _pilot.ComponentInstance_getNumId(self)

    def setContainer(self, cont):
        r"""setContainer(ComponentInstance self, Container cont) -> bool"""
        return _pilot.ComponentInstance_setContainer(self, cont)

    def getContainer(self):
        r"""getContainer(ComponentInstance self) -> Container"""
        return _pilot.ComponentInstance_getContainer(self)

    def load(self, askingNode):
        r"""load(ComponentInstance self, Task askingNode)"""
        return _pilot.ComponentInstance_load(self, askingNode)

    def unload(self, askingNode):
        r"""unload(ComponentInstance self, Task askingNode)"""
        return _pilot.ComponentInstance_unload(self, askingNode)

    def isLoaded(self, askingNode):
        r"""isLoaded(ComponentInstance self, Task askingNode) -> bool"""
        return _pilot.ComponentInstance_isLoaded(self, askingNode)

    def attachOnCloning(self):
        r"""attachOnCloning(ComponentInstance self)"""
        return _pilot.ComponentInstance_attachOnCloning(self)

    def dettachOnCloning(self):
        r"""dettachOnCloning(ComponentInstance self)"""
        return _pilot.ComponentInstance_dettachOnCloning(self)

    def isAttachedOnCloning(self):
        r"""isAttachedOnCloning(ComponentInstance self) -> bool"""
        return _pilot.ComponentInstance_isAttachedOnCloning(self)

    def getFileRepr(self):
        r"""getFileRepr(ComponentInstance self) -> std::string"""
        return _pilot.ComponentInstance_getFileRepr(self)

    def createNode(self, name):
        r"""createNode(ComponentInstance self, std::string const & name) -> ServiceNode"""
        return _pilot.ComponentInstance_createNode(self, name)

    def clone(self):
        r"""clone(ComponentInstance self) -> ComponentInstance"""
        return _pilot.ComponentInstance_clone(self)

    def cloneAlways(self):
        r"""cloneAlways(ComponentInstance self) -> ComponentInstance"""
        return _pilot.ComponentInstance_cloneAlways(self)

    def getKind(self):
        r"""getKind(ComponentInstance self) -> std::string"""
        return _pilot.ComponentInstance_getKind(self)

    def getKindForNode(self):
        r"""getKindForNode(ComponentInstance self) -> std::string"""
        return _pilot.ComponentInstance_getKindForNode(self)

    def shutdown(self, level):
        r"""shutdown(ComponentInstance self, int level)"""
        return _pilot.ComponentInstance_shutdown(self, level)

# Register ComponentInstance in _pilot:
_pilot.ComponentInstance_swigregister(ComponentInstance)
ComponentInstance.KIND = _pilot.cvar.ComponentInstance_KIND

class Container(RefCounter):
    r"""Proxy of C++ YACS::ENGINE::Container class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getKind(self):
        r"""getKind(Container self) -> std::string"""
        return _pilot.Container_getKind(self)

    def getDiscreminantStrOfThis(self, askingNode):
        r"""getDiscreminantStrOfThis(Container self, Task askingNode) -> std::string"""
        return _pilot.Container_getDiscreminantStrOfThis(self, askingNode)

    def isAlreadyStarted(self, askingNode):
        r"""isAlreadyStarted(Container self, Task askingNode) -> bool"""
        return _pilot.Container_isAlreadyStarted(self, askingNode)

    def start(self, *args):
        r"""
        start(Container self, Task askingNode)
        start(Container self, Task askingNode, std::string const & resource_name, std::string const & container_name)
        """
        return _pilot.Container_start(self, *args)

    def canAcceptImposedResource(self):
        r"""canAcceptImposedResource(Container self) -> bool"""
        return _pilot.Container_canAcceptImposedResource(self)

    def isUsingPythonCache(self):
        r"""isUsingPythonCache(Container self) -> bool"""
        return _pilot.Container_isUsingPythonCache(self)

    def usePythonCache(self, v):
        r"""usePythonCache(Container self, bool v)"""
        return _pilot.Container_usePythonCache(self, v)

    def getPlacementId(self, askingNode):
        r"""getPlacementId(Container self, Task askingNode) -> std::string"""
        return _pilot.Container_getPlacementId(self, askingNode)

    def getFullPlacementId(self, askingNode):
        r"""getFullPlacementId(Container self, Task askingNode) -> std::string"""
        return _pilot.Container_getFullPlacementId(self, askingNode)

    def setAttachOnCloningStatus(self, val):
        r"""setAttachOnCloningStatus(Container self, bool val)"""
        return _pilot.Container_setAttachOnCloningStatus(self, val)

    def attachOnCloning(self):
        r"""attachOnCloning(Container self)"""
        return _pilot.Container_attachOnCloning(self)

    def dettachOnCloning(self):
        r"""dettachOnCloning(Container self)"""
        return _pilot.Container_dettachOnCloning(self)

    def isAttachedOnCloning(self):
        r"""isAttachedOnCloning(Container self) -> bool"""
        return _pilot.Container_isAttachedOnCloning(self)

    def lock(self):
        r"""lock(Container self)"""
        return _pilot.Container_lock(self)

    def unLock(self):
        r"""unLock(Container self)"""
        return _pilot.Container_unLock(self)

    def clone(self):
        r"""clone(Container self) -> Container"""
        return _pilot.Container_clone(self)

    def cloneAlways(self):
        r"""cloneAlways(Container self) -> Container"""
        return _pilot.Container_cloneAlways(self)

    def isSupportingRTODefNbOfComp(self):
        r"""isSupportingRTODefNbOfComp(Container self) -> bool"""
        return _pilot.Container_isSupportingRTODefNbOfComp(self)

    def checkCapabilityToDealWith(self, inst):
        r"""checkCapabilityToDealWith(Container self, ComponentInstance inst)"""
        return _pilot.Container_checkCapabilityToDealWith(self, inst)

    def setProperty(self, name, value):
        r"""setProperty(Container self, std::string const & name, std::string const & value)"""
        return _pilot.Container_setProperty(self, name, value)

    def getProperty(self, name):
        r"""getProperty(Container self, std::string const & name) -> std::string"""
        return _pilot.Container_getProperty(self, name)

    def clearProperties(self):
        r"""clearProperties(Container self)"""
        return _pilot.Container_clearProperties(self)

    def addComponentName(self, name):
        r"""addComponentName(Container self, std::string const & name)"""
        return _pilot.Container_addComponentName(self, name)

    def getProperties(self):
        r"""getProperties(Container self) -> propmap"""
        return _pilot.Container_getProperties(self)

    def getResourceProperties(self, name):
        r"""getResourceProperties(Container self, std::string const & name) -> propmap"""
        return _pilot.Container_getResourceProperties(self, name)

    def setProperties(self, properties):
        r"""setProperties(Container self, propmap properties)"""
        return _pilot.Container_setProperties(self, properties)

    def getName(self):
        r"""getName(Container self) -> std::string"""
        return _pilot.Container_getName(self)

    def setName(self, name):
        r"""setName(Container self, std::string name)"""
        return _pilot.Container_setName(self, name)

    def setProc(self, proc):
        r"""setProc(Container self, Proc proc)"""
        return _pilot.Container_setProc(self, proc)

    def getProc(self):
        r"""getProc(Container self) -> Proc"""
        return _pilot.Container_getProc(self)

    def shutdown(self, level):
        r"""shutdown(Container self, int level)"""
        return _pilot.Container_shutdown(self, level)
    __swig_destroy__ = _pilot.delete_Container

# Register Container in _pilot:
_pilot.Container_swigregister(Container)
Container.KIND_ENTRY = _pilot.cvar.Container_KIND_ENTRY
Container.AOC_ENTRY = _pilot.cvar.Container_AOC_ENTRY
Container.USE_PYCACHE_PROPERTY = _pilot.cvar.Container_USE_PYCACHE_PROPERTY

class HomogeneousPoolContainer(Container):
    r"""Proxy of C++ YACS::ENGINE::HomogeneousPoolContainer class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def attachOnCloning(self):
        r"""attachOnCloning(HomogeneousPoolContainer self)"""
        return _pilot.HomogeneousPoolContainer_attachOnCloning(self)

    def dettachOnCloning(self):
        r"""dettachOnCloning(HomogeneousPoolContainer self)"""
        return _pilot.HomogeneousPoolContainer_dettachOnCloning(self)

    def isAttachedOnCloning(self):
        r"""isAttachedOnCloning(HomogeneousPoolContainer self) -> bool"""
        return _pilot.HomogeneousPoolContainer_isAttachedOnCloning(self)

    def setAttachOnCloningStatus(self, val):
        r"""setAttachOnCloningStatus(HomogeneousPoolContainer self, bool val)"""
        return _pilot.HomogeneousPoolContainer_setAttachOnCloningStatus(self, val)

    def assignPG(self, pg):
        r"""assignPG(HomogeneousPoolContainer self, PlayGround const * pg)"""
        return _pilot.HomogeneousPoolContainer_assignPG(self, pg)

    def getLocker(self):
        r"""getLocker(HomogeneousPoolContainer self) -> std::mutex &"""
        return _pilot.HomogeneousPoolContainer_getLocker(self)

    def setSizeOfPool(self, sz):
        r"""setSizeOfPool(HomogeneousPoolContainer self, int sz)"""
        return _pilot.HomogeneousPoolContainer_setSizeOfPool(self, sz)

    def getSizeOfPool(self):
        r"""getSizeOfPool(HomogeneousPoolContainer self) -> int"""
        return _pilot.HomogeneousPoolContainer_getSizeOfPool(self)

    def getNumberOfFreePlace(self):
        r"""getNumberOfFreePlace(HomogeneousPoolContainer self) -> std::size_t"""
        return _pilot.HomogeneousPoolContainer_getNumberOfFreePlace(self)

    def allocateFor(self, nodes):
        r"""allocateFor(HomogeneousPoolContainer self, std::vector< YACS::ENGINE::Task const *,std::allocator< YACS::ENGINE::Task const * > > const & nodes)"""
        return _pilot.HomogeneousPoolContainer_allocateFor(self, nodes)

    def release(self, node):
        r"""release(HomogeneousPoolContainer self, Task node)"""
        return _pilot.HomogeneousPoolContainer_release(self, node)

    def getNumberOfCoresPerWorker(self):
        r"""getNumberOfCoresPerWorker(HomogeneousPoolContainer self) -> int"""
        return _pilot.HomogeneousPoolContainer_getNumberOfCoresPerWorker(self)
    __swig_destroy__ = _pilot.delete_HomogeneousPoolContainer

# Register HomogeneousPoolContainer in _pilot:
_pilot.HomogeneousPoolContainer_swigregister(HomogeneousPoolContainer)
HomogeneousPoolContainer.SIZE_OF_POOL_KEY = _pilot.cvar.HomogeneousPoolContainer_SIZE_OF_POOL_KEY
HomogeneousPoolContainer.INITIALIZE_SCRIPT_KEY = _pilot.cvar.HomogeneousPoolContainer_INITIALIZE_SCRIPT_KEY

class InputPort(DataFlowPort, InPort):
    r"""Proxy of C++ YACS::ENGINE::InputPort class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pilot.delete_InputPort

    def getNameOfTypeOfCurrentInstance(self):
        r"""getNameOfTypeOfCurrentInstance(InputPort self) -> std::string"""
        return _pilot.InputPort_getNameOfTypeOfCurrentInstance(self)

    def getPublicRepresentant(self):
        r"""getPublicRepresentant(InputPort self) -> InputPort"""
        return _pilot.InputPort_getPublicRepresentant(self)

    def isIntermediate(self):
        r"""isIntermediate(InputPort self) -> bool"""
        return _pilot.InputPort_isIntermediate(self)

    def edIsManuallyInitialized(self):
        r"""edIsManuallyInitialized(InputPort self) -> bool"""
        return _pilot.InputPort_edIsManuallyInitialized(self)

    def edIsInitialized(self):
        r"""edIsInitialized(InputPort self) -> bool"""
        return _pilot.InputPort_edIsInitialized(self)

    def edInit(self, *args):
        r"""
        edInit(InputPort self, Any value)
        edInit(InputPort self, std::string const & impl, void const * value)
        """
        return _pilot.InputPort_edInit(self, *args)

    def edRemoveManInit(self):
        r"""edRemoveManInit(InputPort self)"""
        return _pilot.InputPort_edRemoveManInit(self)

    def checkBasicConsistency(self):
        r"""checkBasicConsistency(InputPort self)"""
        return _pilot.InputPort_checkBasicConsistency(self)

    def exInit(self, start):
        r"""exInit(InputPort self, bool start)"""
        return _pilot.InputPort_exInit(self, start)

    def exSaveInit(self):
        r"""exSaveInit(InputPort self)"""
        return _pilot.InputPort_exSaveInit(self)

    def exRestoreInit(self):
        r"""exRestoreInit(InputPort self)"""
        return _pilot.InputPort_exRestoreInit(self)

    def clone(self, newHelder):
        r"""clone(InputPort self, Node newHelder) -> InputPort"""
        return _pilot.InputPort_clone(self, newHelder)

    def isEmpty(self):
        r"""isEmpty(InputPort self) -> bool"""
        return _pilot.InputPort_isEmpty(self)

    def get(self):
        r"""get(InputPort self) -> void *"""
        return _pilot.InputPort_get(self)

    def releaseData(self):
        r"""releaseData(InputPort self)"""
        return _pilot.InputPort_releaseData(self)

    def put(self, data):
        r"""put(InputPort self, void const * data)"""
        return _pilot.InputPort_put(self, data)

    def dump(self):
        r"""dump(InputPort self) -> std::string"""
        return _pilot.InputPort_dump(self)

    def getHumanRepr(self):
        r"""getHumanRepr(InputPort self) -> std::string"""
        return _pilot.InputPort_getHumanRepr(self)

    def setStringRef(self, strRef):
        r"""setStringRef(InputPort self, std::string strRef)"""
        return _pilot.InputPort_setStringRef(self, strRef)

    def typeName(self):
        r"""typeName(InputPort self) -> std::string"""
        return _pilot.InputPort_typeName(self)

    def canBeNull(self):
        r"""canBeNull(InputPort self) -> bool"""
        return _pilot.InputPort_canBeNull(self)

    def edInitXML(self, s):
        r"""edInitXML(InputPort self, char const * s)"""
        return _pilot.InputPort_edInitXML(self, s)

    def edInitPy(self, ob):
        r"""edInitPy(InputPort self, PyObject * ob)"""
        return _pilot.InputPort_edInitPy(self, ob)

    def edInitInt(self, value):
        r"""edInitInt(InputPort self, int value)"""
        return _pilot.InputPort_edInitInt(self, value)

    def edInitBool(self, value):
        r"""edInitBool(InputPort self, bool value)"""
        return _pilot.InputPort_edInitBool(self, value)

    def edInitString(self, value):
        r"""edInitString(InputPort self, std::string value)"""
        return _pilot.InputPort_edInitString(self, value)

    def edInitDbl(self, value):
        r"""edInitDbl(InputPort self, double value)"""
        return _pilot.InputPort_edInitDbl(self, value)

# Register InputPort in _pilot:
_pilot.InputPort_swigregister(InputPort)
InputPort.NAME = _pilot.cvar.InputPort_NAME

class ProxyPort(InputPort):
    r"""Proxy of C++ YACS::ENGINE::ProxyPort class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, p):
        r"""__init__(ProxyPort self, InputPort p) -> ProxyPort"""
        _pilot.ProxyPort_swiginit(self, _pilot.new_ProxyPort(p))
    __swig_destroy__ = _pilot.delete_ProxyPort

    def edRemoveAllLinksLinkedWithMe(self):
        r"""edRemoveAllLinksLinkedWithMe(ProxyPort self)"""
        return _pilot.ProxyPort_edRemoveAllLinksLinkedWithMe(self)

    def clone(self, newHelder):
        r"""clone(ProxyPort self, Node newHelder) -> InputPort"""
        return _pilot.ProxyPort_clone(self, newHelder)

    def edNotifyReferencedBy(self, fromPort, isLoopProof=True):
        r"""edNotifyReferencedBy(ProxyPort self, OutPort fromPort, bool isLoopProof=True)"""
        return _pilot.ProxyPort_edNotifyReferencedBy(self, fromPort, isLoopProof)

    def edNotifyDereferencedBy(self, fromPort):
        r"""edNotifyDereferencedBy(ProxyPort self, OutPort fromPort)"""
        return _pilot.ProxyPort_edNotifyDereferencedBy(self, fromPort)

    def edSetOutPort(self):
        r"""edSetOutPort(ProxyPort self) -> std::set< YACS::ENGINE::OutPort *,std::less< YACS::ENGINE::OutPort * >,std::allocator< YACS::ENGINE::OutPort * > >"""
        return _pilot.ProxyPort_edSetOutPort(self)

    def getPublicRepresentant(self):
        r"""getPublicRepresentant(ProxyPort self) -> InputPort"""
        return _pilot.ProxyPort_getPublicRepresentant(self)

    def get(self):
        r"""get(ProxyPort self) -> void *"""
        return _pilot.ProxyPort_get(self)

    def put(self, data):
        r"""put(ProxyPort self, void const * data)"""
        return _pilot.ProxyPort_put(self, data)

    def releaseData(self):
        r"""releaseData(ProxyPort self)"""
        return _pilot.ProxyPort_releaseData(self)

    def edGetNumberOfLinks(self):
        r"""edGetNumberOfLinks(ProxyPort self) -> int"""
        return _pilot.ProxyPort_edGetNumberOfLinks(self)

    def isIntermediate(self):
        r"""isIntermediate(ProxyPort self) -> bool"""
        return _pilot.ProxyPort_isIntermediate(self)

    def exRestoreInit(self):
        r"""exRestoreInit(ProxyPort self)"""
        return _pilot.ProxyPort_exRestoreInit(self)

    def exSaveInit(self):
        r"""exSaveInit(ProxyPort self)"""
        return _pilot.ProxyPort_exSaveInit(self)

    def getAllRepresentants(self, repr):
        r"""getAllRepresentants(ProxyPort self, std::set< YACS::ENGINE::InPort *,std::less< YACS::ENGINE::InPort * >,std::allocator< YACS::ENGINE::InPort * > > & repr)"""
        return _pilot.ProxyPort_getAllRepresentants(self, repr)

    def typeName(self):
        r"""typeName(ProxyPort self) -> std::string"""
        return _pilot.ProxyPort_typeName(self)

# Register ProxyPort in _pilot:
_pilot.ProxyPort_swigregister(ProxyPort)

class InPropertyPort(InputPort):
    r"""Proxy of C++ YACS::ENGINE::InPropertyPort class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _pilot.delete_InPropertyPort

    def getNameOfTypeOfCurrentInstance(self):
        r"""getNameOfTypeOfCurrentInstance(InPropertyPort self) -> std::string"""
        return _pilot.InPropertyPort_getNameOfTypeOfCurrentInstance(self)

    def getPublicRepresentant(self):
        r"""getPublicRepresentant(InPropertyPort self) -> InPropertyPort"""
        return _pilot.InPropertyPort_getPublicRepresentant(self)

    def typeName(self):
        r"""typeName(InPropertyPort self) -> std::string"""
        return _pilot.InPropertyPort_typeName(self)

    def exNewPropertyValue(self, name, value):
        r"""exNewPropertyValue(InPropertyPort self, std::string const & name, std::string const & value)"""
        return _pilot.InPropertyPort_exNewPropertyValue(self, name, value)

    def exSaveInit(self):
        r"""exSaveInit(InPropertyPort self)"""
        return _pilot.InPropertyPort_exSaveInit(self)

    def exRestoreInit(self):
        r"""exRestoreInit(InPropertyPort self)"""
        return _pilot.InPropertyPort_exRestoreInit(self)

    def clone(self, newHelder):
        r"""clone(InPropertyPort self, Node newHelder) -> InPropertyPort"""
        return _pilot.InPropertyPort_clone(self, newHelder)

    def get(self):
        r"""get(InPropertyPort self) -> void *"""
        return _pilot.InPropertyPort_get(self)

    def put(self, *args):
        r"""
        put(InPropertyPort self, void const * data)
        put(InPropertyPort self, Any data)
        """
        return _pilot.InPropertyPort_put(self, *args)

    def releaseData(self):
        r"""releaseData(InPropertyPort self)"""
        return _pilot.InPropertyPort_releaseData(self)

    def edInitXML(self, s):
        r"""edInitXML(InPropertyPort self, char const * s)"""
        return _pilot.InPropertyPort_edInitXML(self, s)

    def edInitPy(self, ob):
        r"""edInitPy(InPropertyPort self, PyObject * ob)"""
        return _pilot.InPropertyPort_edInitPy(self, ob)

# Register InPropertyPort in _pilot:
_pilot.InPropertyPort_swigregister(InPropertyPort)
InPropertyPort.NAME = _pilot.cvar.InPropertyPort_NAME

class AnyInputPort(InputPort):
    r"""Proxy of C++ YACS::ENGINE::AnyInputPort class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(AnyInputPort self, std::string const & name, Node node, TypeCode type, bool canBeNull=False) -> AnyInputPort
        __init__(AnyInputPort self, AnyInputPort other, Node newHelder) -> AnyInputPort
        """
        _pilot.AnyInputPort_swiginit(self, _pilot.new_AnyInputPort(*args))
    __swig_destroy__ = _pilot.delete_AnyInputPort

    def exSaveInit(self):
        r"""exSaveInit(AnyInputPort self)"""
        return _pilot.AnyInputPort_exSaveInit(self)

    def exRestoreInit(self):
        r"""exRestoreInit(AnyInputPort self)"""
        return _pilot.AnyInputPort_exRestoreInit(self)

    def getValue(self):
        r"""getValue(AnyInputPort self) -> Any"""
        return _pilot.AnyInputPort_getValue(self)

    def getIntValue(self):
        r"""getIntValue(AnyInputPort self) -> int"""
        return _pilot.AnyInputPort_getIntValue(self)

    def releaseData(self):
        r"""releaseData(AnyInputPort self)"""
        return _pilot.AnyInputPort_releaseData(self)

    def get(self):
        r"""get(AnyInputPort self) -> void *"""
        return _pilot.AnyInputPort_get(self)

    def getAsString(self):
        r"""getAsString(AnyInputPort self) -> std::string"""
        return _pilot.AnyInputPort_getAsString(self)

    def isEmpty(self):
        r"""isEmpty(AnyInputPort self) -> bool"""
        return _pilot.AnyInputPort_isEmpty(self)

    def put(self, *args):
        r"""
        put(AnyInputPort self, Any data)
        put(AnyInputPort self, void const * data)
        """
        return _pilot.AnyInputPort_put(self, *args)

    def clone(self, newHelder):
        r"""clone(AnyInputPort self, Node newHelder) -> InputPort"""
        return _pilot.AnyInputPort_clone(self, newHelder)

    def dump(self):
        r"""dump(AnyInputPort self) -> std::string"""
        return _pilot.AnyInputPort_dump(self)

    def typeName(self):
        r"""typeName(AnyInputPort self) -> std::string"""
        return _pilot.AnyInputPort_typeName(self)

    def getPyObj(self):
        r"""getPyObj(AnyInputPort self) -> PyObject *"""
        return _pilot.AnyInputPort_getPyObj(self)

# Register AnyInputPort in _pilot:
_pilot.AnyInputPort_swigregister(AnyInputPort)

class ConditionInputPort(InputPort):
    r"""Proxy of C++ YACS::ENGINE::ConditionInputPort class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def exSaveInit(self):
        r"""exSaveInit(ConditionInputPort self)"""
        return _pilot.ConditionInputPort_exSaveInit(self)

    def exRestoreInit(self):
        r"""exRestoreInit(ConditionInputPort self)"""
        return _pilot.ConditionInputPort_exRestoreInit(self)

    def isLinkedOutOfScope(self):
        r"""isLinkedOutOfScope(ConditionInputPort self) -> bool"""
        return _pilot.ConditionInputPort_isLinkedOutOfScope(self)

    def edNotifyReferencedBy(self, fromPort, isLoopProof):
        r"""edNotifyReferencedBy(ConditionInputPort self, OutPort fromPort, bool isLoopProof)"""
        return _pilot.ConditionInputPort_edNotifyReferencedBy(self, fromPort, isLoopProof)

    def edNotifyDereferencedBy(self, fromPort):
        r"""edNotifyDereferencedBy(ConditionInputPort self, OutPort fromPort)"""
        return _pilot.ConditionInputPort_edNotifyDereferencedBy(self, fromPort)

    def get(self):
        r"""get(ConditionInputPort self) -> void *"""
        return _pilot.ConditionInputPort_get(self)

    def put(self, *args):
        r"""
        put(ConditionInputPort self, void const * data)
        put(ConditionInputPort self, Any data)
        """
        return _pilot.ConditionInputPort_put(self, *args)

    def releaseData(self):
        r"""releaseData(ConditionInputPort self)"""
        return _pilot.ConditionInputPort_releaseData(self)

    def dump(self):
        r"""dump(ConditionInputPort self) -> std::string"""
        return _pilot.ConditionInputPort_dump(self)

    def getAsString(self):
        r"""getAsString(ConditionInputPort self) -> std::string"""
        return _pilot.ConditionInputPort_getAsString(self)

    def getValue(self):
        r"""getValue(ConditionInputPort self) -> bool"""
        return _pilot.ConditionInputPort_getValue(self)

    def typeName(self):
        r"""typeName(ConditionInputPort self) -> std::string"""
        return _pilot.ConditionInputPort_typeName(self)

    def getPyObj(self):
        r"""getPyObj(ConditionInputPort self) -> bool"""
        return _pilot.ConditionInputPort_getPyObj(self)

# Register ConditionInputPort in _pilot:
_pilot.ConditionInputPort_swigregister(ConditionInputPort)

class OutputPort(DataFlowPort, OutPort):
    r"""Proxy of C++ YACS::ENGINE::OutputPort class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pilot.delete_OutputPort

    def edSetInPort(self):
        r"""edSetInPort(OutputPort self) -> std::set< YACS::ENGINE::InPort *,std::less< YACS::ENGINE::InPort * >,std::allocator< YACS::ENGINE::InPort * > >"""
        return _pilot.OutputPort_edSetInPort(self)

    def isAlreadyLinkedWith(self, withp):
        r"""isAlreadyLinkedWith(OutputPort self, InPort withp) -> bool"""
        return _pilot.OutputPort_isAlreadyLinkedWith(self, withp)

    def isAlreadyInSet(self, inputPort):
        r"""isAlreadyInSet(OutputPort self, InputPort inputPort) -> bool"""
        return _pilot.OutputPort_isAlreadyInSet(self, inputPort)

    def isConnected(self):
        r"""isConnected(OutputPort self) -> bool"""
        return _pilot.OutputPort_isConnected(self)

    def getNameOfTypeOfCurrentInstance(self):
        r"""getNameOfTypeOfCurrentInstance(OutputPort self) -> std::string"""
        return _pilot.OutputPort_getNameOfTypeOfCurrentInstance(self)

    def removeInPort(self, inPort, forward):
        r"""removeInPort(OutputPort self, InPort inPort, bool forward) -> int"""
        return _pilot.OutputPort_removeInPort(self, inPort, forward)

    def edAddInputPort(self, phyPort):
        r"""edAddInputPort(OutputPort self, InputPort phyPort) -> bool"""
        return _pilot.OutputPort_edAddInputPort(self, phyPort)

    def edAddInPropertyPort(self, phyPort):
        r"""edAddInPropertyPort(OutputPort self, InPropertyPort phyPort) -> bool"""
        return _pilot.OutputPort_edAddInPropertyPort(self, phyPort)

    def edRemoveInputPort(self, inputPort, forward):
        r"""edRemoveInputPort(OutputPort self, InputPort inputPort, bool forward) -> int"""
        return _pilot.OutputPort_edRemoveInputPort(self, inputPort, forward)

    def addInPort(self, inPort):
        r"""addInPort(OutputPort self, InPort inPort) -> bool"""
        return _pilot.OutputPort_addInPort(self, inPort)

    def edRemoveAllLinksLinkedWithMe(self):
        r"""edRemoveAllLinksLinkedWithMe(OutputPort self)"""
        return _pilot.OutputPort_edRemoveAllLinksLinkedWithMe(self)

    def exInit(self):
        r"""exInit(OutputPort self)"""
        return _pilot.OutputPort_exInit(self)

    def checkBasicConsistency(self):
        r"""checkBasicConsistency(OutputPort self)"""
        return _pilot.OutputPort_checkBasicConsistency(self)

    def clone(self, newHelder):
        r"""clone(OutputPort self, Node newHelder) -> OutputPort"""
        return _pilot.OutputPort_clone(self, newHelder)

    def dump(self):
        r"""dump(OutputPort self) -> std::string"""
        return _pilot.OutputPort_dump(self)

    def put(self, data):
        r"""put(OutputPort self, void const * data)"""
        return _pilot.OutputPort_put(self, data)

    def typeName(self):
        r"""typeName(OutputPort self) -> std::string"""
        return _pilot.OutputPort_typeName(self)

# Register OutputPort in _pilot:
_pilot.OutputPort_swigregister(OutputPort)
OutputPort.NAME = _pilot.cvar.OutputPort_NAME

class AnyOutputPort(OutputPort):
    r"""Proxy of C++ YACS::ENGINE::AnyOutputPort class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(AnyOutputPort self, std::string const & name, Node node, TypeCode type) -> AnyOutputPort
        __init__(AnyOutputPort self, AnyOutputPort other, Node newHelder) -> AnyOutputPort
        """
        _pilot.AnyOutputPort_swiginit(self, _pilot.new_AnyOutputPort(*args))
    __swig_destroy__ = _pilot.delete_AnyOutputPort

    def setValue(self, data):
        r"""setValue(AnyOutputPort self, Any data)"""
        return _pilot.AnyOutputPort_setValue(self, data)

    def put(self, *args):
        r"""
        put(AnyOutputPort self, void const * data)
        put(AnyOutputPort self, Any data)
        """
        return _pilot.AnyOutputPort_put(self, *args)

    def getValue(self):
        r"""getValue(AnyOutputPort self) -> Any"""
        return _pilot.AnyOutputPort_getValue(self)

    def getAsString(self):
        r"""getAsString(AnyOutputPort self) -> std::string"""
        return _pilot.AnyOutputPort_getAsString(self)

    def typeName(self):
        r"""typeName(AnyOutputPort self) -> std::string"""
        return _pilot.AnyOutputPort_typeName(self)

    def getPyObj(self):
        r"""getPyObj(AnyOutputPort self) -> PyObject *"""
        return _pilot.AnyOutputPort_getPyObj(self)

# Register AnyOutputPort in _pilot:
_pilot.AnyOutputPort_swigregister(AnyOutputPort)

class InputDataStreamPort(DataStreamPort, InPort):
    r"""Proxy of C++ YACS::ENGINE::InputDataStreamPort class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(InputDataStreamPort self, InputDataStreamPort other, Node newHelder) -> InputDataStreamPort
        __init__(InputDataStreamPort self, std::string const & name, Node node, TypeCode type) -> InputDataStreamPort
        """
        _pilot.InputDataStreamPort_swiginit(self, _pilot.new_InputDataStreamPort(*args))
    __swig_destroy__ = _pilot.delete_InputDataStreamPort

    def getNameOfTypeOfCurrentInstance(self):
        r"""getNameOfTypeOfCurrentInstance(InputDataStreamPort self) -> std::string"""
        return _pilot.InputDataStreamPort_getNameOfTypeOfCurrentInstance(self)

    def clone(self, newHelder):
        r"""clone(InputDataStreamPort self, Node newHelder) -> InputDataStreamPort"""
        return _pilot.InputDataStreamPort_clone(self, newHelder)

    def typeName(self):
        r"""typeName(InputDataStreamPort self) -> std::string"""
        return _pilot.InputDataStreamPort_typeName(self)

    def edAddOutputDataStreamPort(self, port):
        r"""edAddOutputDataStreamPort(InputDataStreamPort self, OutputDataStreamPort port)"""
        return _pilot.InputDataStreamPort_edAddOutputDataStreamPort(self, port)

    def getConnectedOutputDataStreamPort(self):
        r"""getConnectedOutputDataStreamPort(InputDataStreamPort self) -> std::set< YACS::ENGINE::OutputDataStreamPort *,std::less< YACS::ENGINE::OutputDataStreamPort * >,std::allocator< YACS::ENGINE::OutputDataStreamPort * > >"""
        return _pilot.InputDataStreamPort_getConnectedOutputDataStreamPort(self)

# Register InputDataStreamPort in _pilot:
_pilot.InputDataStreamPort_swigregister(InputDataStreamPort)
InputDataStreamPort.NAME = _pilot.cvar.InputDataStreamPort_NAME

class OutputDataStreamPort(DataStreamPort, OutPort):
    r"""Proxy of C++ YACS::ENGINE::OutputDataStreamPort class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(OutputDataStreamPort self, OutputDataStreamPort other, Node newHelder) -> OutputDataStreamPort
        __init__(OutputDataStreamPort self, std::string const & name, Node node, TypeCode type) -> OutputDataStreamPort
        """
        _pilot.OutputDataStreamPort_swiginit(self, _pilot.new_OutputDataStreamPort(*args))
    __swig_destroy__ = _pilot.delete_OutputDataStreamPort

    def clone(self, newHelder):
        r"""clone(OutputDataStreamPort self, Node newHelder) -> OutputDataStreamPort"""
        return _pilot.OutputDataStreamPort_clone(self, newHelder)

    def edSetInPort(self):
        r"""edSetInPort(OutputDataStreamPort self) -> std::set< YACS::ENGINE::InPort *,std::less< YACS::ENGINE::InPort * >,std::allocator< YACS::ENGINE::InPort * > >"""
        return _pilot.OutputDataStreamPort_edSetInPort(self)

    def isAlreadyLinkedWith(self, withp):
        r"""isAlreadyLinkedWith(OutputDataStreamPort self, InPort withp) -> bool"""
        return _pilot.OutputDataStreamPort_isAlreadyLinkedWith(self, withp)

    def getNameOfTypeOfCurrentInstance(self):
        r"""getNameOfTypeOfCurrentInstance(OutputDataStreamPort self) -> std::string"""
        return _pilot.OutputDataStreamPort_getNameOfTypeOfCurrentInstance(self)

    def addInPort(self, inPort):
        r"""addInPort(OutputDataStreamPort self, InPort inPort) -> bool"""
        return _pilot.OutputDataStreamPort_addInPort(self, inPort)

    def edAddInputDataStreamPort(self, port):
        r"""edAddInputDataStreamPort(OutputDataStreamPort self, InputDataStreamPort port) -> bool"""
        return _pilot.OutputDataStreamPort_edAddInputDataStreamPort(self, port)

    def edRemoveInputDataStreamPort(self, inPort, forward):
        r"""edRemoveInputDataStreamPort(OutputDataStreamPort self, InputDataStreamPort inPort, bool forward) -> int"""
        return _pilot.OutputDataStreamPort_edRemoveInputDataStreamPort(self, inPort, forward)

    def edRemoveAllLinksLinkedWithMe(self):
        r"""edRemoveAllLinksLinkedWithMe(OutputDataStreamPort self)"""
        return _pilot.OutputDataStreamPort_edRemoveAllLinksLinkedWithMe(self)

    def removeInPort(self, inPort, forward):
        r"""removeInPort(OutputDataStreamPort self, InPort inPort, bool forward) -> int"""
        return _pilot.OutputDataStreamPort_removeInPort(self, inPort, forward)

    def typeName(self):
        r"""typeName(OutputDataStreamPort self) -> std::string"""
        return _pilot.OutputDataStreamPort_typeName(self)

# Register OutputDataStreamPort in _pilot:
_pilot.OutputDataStreamPort_swigregister(OutputDataStreamPort)
OutputDataStreamPort.NAME = _pilot.cvar.OutputDataStreamPort_NAME


def StateLoader(node, state):
    r"""StateLoader(Node node, YACS::StatesForNode state)"""
    return _pilot.StateLoader(node, state)
class ProgressWeight(object):
    r"""Proxy of C++ YACS::ENGINE::ProgressWeight class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    weightDone = property(_pilot.ProgressWeight_weightDone_get, _pilot.ProgressWeight_weightDone_set, doc=r"""weightDone : int""")
    weightTotal = property(_pilot.ProgressWeight_weightTotal_get, _pilot.ProgressWeight_weightTotal_set, doc=r"""weightTotal : int""")

    def __init__(self):
        r"""__init__(ProgressWeight self) -> ProgressWeight"""
        _pilot.ProgressWeight_swiginit(self, _pilot.new_ProgressWeight())
    __swig_destroy__ = _pilot.delete_ProgressWeight

# Register ProgressWeight in _pilot:
_pilot.ProgressWeight_swigregister(ProgressWeight)

class NodeStateNameMap(object):
    r"""Proxy of C++ YACS::ENGINE::NodeStateNameMap class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""__init__(NodeStateNameMap self) -> NodeStateNameMap"""
        _pilot.NodeStateNameMap_swiginit(self, _pilot.new_NodeStateNameMap())
    __swig_destroy__ = _pilot.delete_NodeStateNameMap

# Register NodeStateNameMap in _pilot:
_pilot.NodeStateNameMap_swigregister(NodeStateNameMap)

class Node(object):
    r"""Proxy of C++ YACS::ENGINE::Node class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    _colour = property(_pilot.Node__colour_get, _pilot.Node__colour_set, doc=r"""_colour : YACS::Colour""")
    __swig_destroy__ = _pilot.delete_Node

    def init(self, start=True):
        r"""init(Node self, bool start=True)"""
        return _pilot.Node_init(self, start)

    def shutdown(self, level):
        r"""shutdown(Node self, int level)"""
        return _pilot.Node_shutdown(self, level)

    def resetState(self, level):
        r"""resetState(Node self, int level)"""
        return _pilot.Node_resetState(self, level)

    def clone(self, father, editionOnly=True):
        r"""clone(Node self, ComposedNode father, bool editionOnly=True) -> Node"""
        return _pilot.Node_clone(self, father, editionOnly)

    def cloneWithoutCompAndContDeepCpy(self, father, editionOnly=True):
        r"""cloneWithoutCompAndContDeepCpy(Node self, ComposedNode father, bool editionOnly=True) -> Node"""
        return _pilot.Node_cloneWithoutCompAndContDeepCpy(self, father, editionOnly)

    def setState(self, theState):
        r"""setState(Node self, YACS::StatesForNode theState)"""
        return _pilot.Node_setState(self, theState)

    def getState(self):
        r"""getState(Node self) -> YACS::StatesForNode"""
        return _pilot.Node_getState(self)

    def getEffectiveState(self, *args):
        r"""
        getEffectiveState(Node self) -> YACS::StatesForNode
        getEffectiveState(Node self, Node arg2) -> YACS::StatesForNode
        """
        return _pilot.Node_getEffectiveState(self, *args)

    def getColorState(self, state):
        r"""getColorState(Node self, YACS::StatesForNode state) -> std::string"""
        return _pilot.Node_getColorState(self, state)

    @staticmethod
    def getStateName(state):
        r"""getStateName(YACS::StatesForNode state) -> std::string"""
        return _pilot.Node_getStateName(state)

    def getInGate(self):
        r"""getInGate(Node self) -> InGate"""
        return _pilot.Node_getInGate(self)

    def getOutGate(self):
        r"""getOutGate(Node self) -> OutGate"""
        return _pilot.Node_getOutGate(self)

    def getName(self):
        r"""getName(Node self) -> std::string const &"""
        return _pilot.Node_getName(self)

    def setName(self, name):
        r"""setName(Node self, std::string const & name)"""
        return _pilot.Node_setName(self, name)

    def getFather(self):
        r"""getFather(Node self) -> ComposedNode"""
        return _pilot.Node_getFather(self)

    def getId(self):
        r"""getId(Node self) -> std::string const"""
        return _pilot.Node_getId(self)

    def exIsControlReady(self):
        r"""exIsControlReady(Node self) -> bool"""
        return _pilot.Node_exIsControlReady(self)

    def getOutNodes(self):
        r"""getOutNodes(Node self) -> std::list< YACS::ENGINE::Node *,std::allocator< YACS::ENGINE::Node * > >"""
        return _pilot.Node_getOutNodes(self)

    def writeDot(self, os):
        r"""writeDot(Node self, std::ostream & os)"""
        return _pilot.Node_writeDot(self, os)

    def writeDotInFile(self, fileName):
        r"""writeDotInFile(Node self, std::string const & fileName)"""
        return _pilot.Node_writeDotInFile(self, fileName)

    def exUpdateState(self):
        r"""exUpdateState(Node self)"""
        return _pilot.Node_exUpdateState(self)

    def exFailedState(self):
        r"""exFailedState(Node self)"""
        return _pilot.Node_exFailedState(self)

    def exDisabledState(self):
        r"""exDisabledState(Node self)"""
        return _pilot.Node_exDisabledState(self)

    def getReadyTasks(self, tasks):
        r"""getReadyTasks(Node self, std::vector< YACS::ENGINE::Task *,std::allocator< YACS::ENGINE::Task * > > & tasks)"""
        return _pilot.Node_getReadyTasks(self, tasks)

    def getRecursiveConstituents(self):
        r"""getRecursiveConstituents(Node self) -> std::list< YACS::ENGINE::ElementaryNode *,std::allocator< YACS::ENGINE::ElementaryNode * > >"""
        return _pilot.Node_getRecursiveConstituents(self)

    def getProgressWeight(self):
        r"""getProgressWeight(Node self) -> std::list< YACS::ENGINE::ProgressWeight,std::allocator< YACS::ENGINE::ProgressWeight > >"""
        return _pilot.Node_getProgressWeight(self)

    def getNumberOfInputPorts(self):
        r"""getNumberOfInputPorts(Node self) -> int"""
        return _pilot.Node_getNumberOfInputPorts(self)

    def getNumberOfOutputPorts(self):
        r"""getNumberOfOutputPorts(Node self) -> int"""
        return _pilot.Node_getNumberOfOutputPorts(self)

    def getSetOfInPort(self):
        r"""getSetOfInPort(Node self) -> std::list< YACS::ENGINE::InPort *,std::allocator< YACS::ENGINE::InPort * > >"""
        return _pilot.Node_getSetOfInPort(self)

    def getSetOfOutPort(self):
        r"""getSetOfOutPort(Node self) -> std::list< YACS::ENGINE::OutPort *,std::allocator< YACS::ENGINE::OutPort * > >"""
        return _pilot.Node_getSetOfOutPort(self)

    def getSetOfInputPort(self):
        r"""getSetOfInputPort(Node self) -> std::list< YACS::ENGINE::InputPort *,std::allocator< YACS::ENGINE::InputPort * > >"""
        return _pilot.Node_getSetOfInputPort(self)

    def getSetOfOutputPort(self):
        r"""getSetOfOutputPort(Node self) -> std::list< YACS::ENGINE::OutputPort *,std::allocator< YACS::ENGINE::OutputPort * > >"""
        return _pilot.Node_getSetOfOutputPort(self)

    def getLocalInputPorts(self):
        r"""getLocalInputPorts(Node self) -> std::list< YACS::ENGINE::InputPort *,std::allocator< YACS::ENGINE::InputPort * > >"""
        return _pilot.Node_getLocalInputPorts(self)

    def getLocalOutputPorts(self):
        r"""getLocalOutputPorts(Node self) -> std::list< YACS::ENGINE::OutputPort *,std::allocator< YACS::ENGINE::OutputPort * > >"""
        return _pilot.Node_getLocalOutputPorts(self)

    def edGetSetOfUnitializedInputPort(self):
        r"""edGetSetOfUnitializedInputPort(Node self) -> std::set< YACS::ENGINE::InputPort *,std::less< YACS::ENGINE::InputPort * >,std::allocator< YACS::ENGINE::InputPort * > >"""
        return _pilot.Node_edGetSetOfUnitializedInputPort(self)

    def edAreAllInputPortInitialized(self):
        r"""edAreAllInputPortInitialized(Node self) -> bool"""
        return _pilot.Node_edAreAllInputPortInitialized(self)

    def getInPortName(self, arg2):
        r"""getInPortName(Node self, InPort arg2) -> std::string"""
        return _pilot.Node_getInPortName(self, arg2)

    def getOutPortName(self, arg2):
        r"""getOutPortName(Node self, OutPort arg2) -> std::string"""
        return _pilot.Node_getOutPortName(self, arg2)

    def getSetOfInputDataStreamPort(self):
        r"""getSetOfInputDataStreamPort(Node self) -> instreamlist"""
        return _pilot.Node_getSetOfInputDataStreamPort(self)

    def getSetOfOutputDataStreamPort(self):
        r"""getSetOfOutputDataStreamPort(Node self) -> outstreamlist"""
        return _pilot.Node_getSetOfOutputDataStreamPort(self)

    def getInPort(self, name):
        r"""getInPort(Node self, std::string const & name) -> InPort"""
        return _pilot.Node_getInPort(self, name)

    def getInPropertyPort(self):
        r"""getInPropertyPort(Node self) -> InPropertyPort"""
        return _pilot.Node_getInPropertyPort(self)

    def getOutPort(self, name):
        r"""getOutPort(Node self, std::string const & name) -> OutPort"""
        return _pilot.Node_getOutPort(self, name)

    def getAllOutPortsLeavingCurrentScope(self):
        r"""getAllOutPortsLeavingCurrentScope(Node self) -> std::set< YACS::ENGINE::OutPort *,std::less< YACS::ENGINE::OutPort * >,std::allocator< YACS::ENGINE::OutPort * > >"""
        return _pilot.Node_getAllOutPortsLeavingCurrentScope(self)

    def getAllInPortsComingFromOutsideOfCurrentScope(self):
        r"""getAllInPortsComingFromOutsideOfCurrentScope(Node self) -> std::set< YACS::ENGINE::InPort *,std::less< YACS::ENGINE::InPort * >,std::allocator< YACS::ENGINE::InPort * > >"""
        return _pilot.Node_getAllInPortsComingFromOutsideOfCurrentScope(self)

    def getSetOfLinksLeavingCurrentScope(self):
        r"""getSetOfLinksLeavingCurrentScope(Node self) -> linksvec"""
        return _pilot.Node_getSetOfLinksLeavingCurrentScope(self)

    def getSetOfLinksComingInCurrentScope(self):
        r"""getSetOfLinksComingInCurrentScope(Node self) -> linkvec"""
        return _pilot.Node_getSetOfLinksComingInCurrentScope(self)

    def getInputPort(self, name):
        r"""getInputPort(Node self, std::string const & name) -> InputPort"""
        return _pilot.Node_getInputPort(self, name)

    def getOutputPort(self, name):
        r"""getOutputPort(Node self, std::string const & name) -> OutputPort"""
        return _pilot.Node_getOutputPort(self, name)

    def getInputDataStreamPort(self, name):
        r"""getInputDataStreamPort(Node self, std::string const & name) -> InputDataStreamPort"""
        return _pilot.Node_getInputDataStreamPort(self, name)

    def getOutputDataStreamPort(self, name):
        r"""getOutputDataStreamPort(Node self, std::string const & name) -> OutputDataStreamPort"""
        return _pilot.Node_getOutputDataStreamPort(self, name)

    def getAllAscendanceOf(self, levelToStop=None):
        r"""getAllAscendanceOf(Node self, ComposedNode levelToStop=None) -> std::list< YACS::ENGINE::ComposedNode *,std::allocator< YACS::ENGINE::ComposedNode * > >"""
        return _pilot.Node_getAllAscendanceOf(self, levelToStop)

    def getImplementation(self):
        r"""getImplementation(Node self) -> std::string"""
        return _pilot.Node_getImplementation(self)

    def getClosestDPLAmongAncestors(self):
        r"""getClosestDPLAmongAncestors(Node self) -> DynParaLoop"""
        return _pilot.Node_getClosestDPLAmongAncestors(self)

    def getRootNode(self):
        r"""getRootNode(Node self) -> ComposedNode"""
        return _pilot.Node_getRootNode(self)

    def setProperty(self, name, value):
        r"""setProperty(Node self, std::string const & name, std::string const & value)"""
        return _pilot.Node_setProperty(self, name, value)

    def getProperty(self, name):
        r"""getProperty(Node self, std::string const & name) -> std::string"""
        return _pilot.Node_getProperty(self, name)

    def getProperties(self):
        r"""getProperties(Node self) -> propmap"""
        return _pilot.Node_getProperties(self)

    def getPropertyMap(self):
        r"""getPropertyMap(Node self) -> propmap"""
        return _pilot.Node_getPropertyMap(self)

    def setProperties(self, properties):
        r"""setProperties(Node self, propmap properties)"""
        return _pilot.Node_setProperties(self, properties)

    def getChildByName(self, name):
        r"""getChildByName(Node self, std::string const & name) -> Node"""
        return _pilot.Node_getChildByName(self, name)

    def getProc(self, *args):
        r"""
        getProc(Node self) -> Proc
        getProc(Node self) -> Proc
        """
        return _pilot.Node_getProc(self, *args)

    def accept(self, visitor):
        r"""accept(Node self, Visitor visitor)"""
        return _pilot.Node_accept(self, visitor)

    def getMaxLevelOfParallelism(self):
        r"""getMaxLevelOfParallelism(Node self) -> int"""
        return _pilot.Node_getMaxLevelOfParallelism(self)

    def getWeightRegardingDPL(self, weight):
        r"""getWeightRegardingDPL(Node self, ComplexWeight * weight)"""
        return _pilot.Node_getWeightRegardingDPL(self, weight)

    def partitionRegardingDPL(self, pd, zeMap):
        r"""partitionRegardingDPL(Node self, PartDefinition const * pd, std::map< YACS::ENGINE::ComposedNode *,YACS::BASES::AutoRefCnt< PartDefinition >,std::less< YACS::ENGINE::ComposedNode * >,std::allocator< std::pair< YACS::ENGINE::ComposedNode *const,YACS::BASES::AutoRefCnt< YACS::ENGINE::PartDefinition > > > > & zeMap)"""
        return _pilot.Node_partitionRegardingDPL(self, pd, zeMap)

    def getQualifiedName(self):
        r"""getQualifiedName(Node self) -> std::string"""
        return _pilot.Node_getQualifiedName(self)

    def getNumId(self):
        r"""getNumId(Node self) -> int"""
        return _pilot.Node_getNumId(self)

    def getDPLScopeInfo(self, gfn):
        r"""getDPLScopeInfo(Node self, ComposedNode gfn) -> vpsi"""
        return _pilot.Node_getDPLScopeInfo(self, gfn)

    def applyDPLScope(self, gfn):
        r"""applyDPLScope(Node self, ComposedNode gfn)"""
        return _pilot.Node_applyDPLScope(self, gfn)

    def sendEvent(self, event):
        r"""sendEvent(Node self, std::string const & event)"""
        return _pilot.Node_sendEvent(self, event)

    def sendEvent2(self, event, something):
        r"""sendEvent2(Node self, std::string const & event, void * something)"""
        return _pilot.Node_sendEvent2(self, event, something)
    idMap = property(_pilot.Node_idMap_get, _pilot.Node_idMap_set, doc=r"""idMap : std::map<(int,p.YACS::ENGINE::Node,std::less<(int)>,std::allocator<(std::pair<(q(const).int,p.YACS::ENGINE::Node)>)>)>""")

    def typeName(self):
        r"""typeName(Node self) -> std::string"""
        return _pilot.Node_typeName(self)

    def getErrorDetails(self):
        r"""getErrorDetails(Node self) -> std::string"""
        return _pilot.Node_getErrorDetails(self)

    def setErrorDetails(self, error):
        r"""setErrorDetails(Node self, std::string const & error)"""
        return _pilot.Node_setErrorDetails(self, error)

    def modified(self):
        r"""modified(Node self)"""
        return _pilot.Node_modified(self)

    def isModified(self):
        r"""isModified(Node self) -> int"""
        return _pilot.Node_isModified(self)

    def isValid(self):
        r"""isValid(Node self) -> int"""
        return _pilot.Node_isValid(self)

    def edUpdateState(self):
        r"""edUpdateState(Node self)"""
        return _pilot.Node_edUpdateState(self)

    def getErrorReport(self):
        r"""getErrorReport(Node self) -> std::string"""
        return _pilot.Node_getErrorReport(self)

    def getContainerLog(self):
        r"""getContainerLog(Node self) -> std::string"""
        return _pilot.Node_getContainerLog(self)

    def ensureLoading(self):
        r"""ensureLoading(Node self)"""
        return _pilot.Node_ensureLoading(self)

    def getCoupledNodes(self, coupledNodes):
        r"""getCoupledNodes(Node self, std::set< YACS::ENGINE::Task *,std::less< YACS::ENGINE::Task * >,std::allocator< YACS::ENGINE::Task * > > & coupledNodes)"""
        return _pilot.Node_getCoupledNodes(self, coupledNodes)

    def cleanNodes(self):
        r"""cleanNodes(Node self)"""
        return _pilot.Node_cleanNodes(self)

    @staticmethod
    def checkValidityOfNodeName(name):
        r"""checkValidityOfNodeName(std::string const & name)"""
        return _pilot.Node_checkValidityOfNodeName(name)

    def __lt__(self, *args):
        r"""
        __lt__(Node self, Node other) -> bool
        __lt__(Node self, Node other) -> int
        """
        return _pilot.Node___lt__(self, *args)

    def __gt__(self, *args):
        r"""
        __gt__(Node self, Node other) -> bool
        __gt__(Node self, Node other) -> int
        """
        return _pilot.Node___gt__(self, *args)

    def __ne__(self, other):
        r"""__ne__(Node self, Node other) -> int"""
        return _pilot.Node___ne__(self, other)

    def __eq__(self, other):
        r"""__eq__(Node self, Node other) -> int"""
        return _pilot.Node___eq__(self, other)

    def __le__(self, other):
        r"""__le__(Node self, Node other) -> int"""
        return _pilot.Node___le__(self, other)

    def __ge__(self, other):
        r"""__ge__(Node self, Node other) -> int"""
        return _pilot.Node___ge__(self, other)

    def ptr(self):
        r"""ptr(Node self) -> long"""
        return _pilot.Node_ptr(self)

# Register Node in _pilot:
_pilot.Node_swigregister(Node)

def Node_getStateName(state):
    r"""Node_getStateName(YACS::StatesForNode state) -> std::string"""
    return _pilot.Node_getStateName(state)

def Node_checkValidityOfNodeName(name):
    r"""Node_checkValidityOfNodeName(std::string const & name)"""
    return _pilot.Node_checkValidityOfNodeName(name)

class ComplexWeight(object):
    r"""Proxy of C++ YACS::ENGINE::ComplexWeight class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(ComplexWeight self) -> ComplexWeight
        __init__(ComplexWeight self, double elementaryWeight, double loopWeight, int nbCoresByIteration) -> ComplexWeight
        __init__(ComplexWeight self, ComplexWeight other) -> ComplexWeight
        """
        _pilot.ComplexWeight_swiginit(self, _pilot.new_ComplexWeight(*args))
    __swig_destroy__ = _pilot.delete_ComplexWeight

    def getLoopWeight(self):
        r"""getLoopWeight(ComplexWeight self) -> std::vector< std::pair< double,int >,std::allocator< std::pair< double,int > > >"""
        return _pilot.ComplexWeight_getLoopWeight(self)

    def getSimpleLoopWeight(self):
        r"""getSimpleLoopWeight(ComplexWeight self) -> double"""
        return _pilot.ComplexWeight_getSimpleLoopWeight(self)

    def getElementaryWeight(self):
        r"""getElementaryWeight(ComplexWeight self) -> double"""
        return _pilot.ComplexWeight_getElementaryWeight(self)

    def calculateTotalLength(self, nbOfCoresAllocated):
        r"""calculateTotalLength(ComplexWeight self, int nbOfCoresAllocated) -> double"""
        return _pilot.ComplexWeight_calculateTotalLength(self, nbOfCoresAllocated)

    def setDefaultElementary(self):
        r"""setDefaultElementary(ComplexWeight self)"""
        return _pilot.ComplexWeight_setDefaultElementary(self)

    def setDefaultLoop(self):
        r"""setDefaultLoop(ComplexWeight self)"""
        return _pilot.ComplexWeight_setDefaultLoop(self)

    def isDefaultValue(self):
        r"""isDefaultValue(ComplexWeight self) -> bool"""
        return _pilot.ComplexWeight_isDefaultValue(self)

    def isUnsetLoopWeight(self):
        r"""isUnsetLoopWeight(ComplexWeight self) -> bool"""
        return _pilot.ComplexWeight_isUnsetLoopWeight(self)

    def isUnsetElementaryWeight(self):
        r"""isUnsetElementaryWeight(ComplexWeight self) -> bool"""
        return _pilot.ComplexWeight_isUnsetElementaryWeight(self)

    def hasValidLoopWeight(self):
        r"""hasValidLoopWeight(ComplexWeight self) -> bool"""
        return _pilot.ComplexWeight_hasValidLoopWeight(self)

    def hasValidElementaryWeight(self):
        r"""hasValidElementaryWeight(ComplexWeight self) -> bool"""
        return _pilot.ComplexWeight_hasValidElementaryWeight(self)

    def setLoopWeight(self, loopWeight, nbCoresByIteration):
        r"""setLoopWeight(ComplexWeight self, double loopWeight, int nbCoresByIteration)"""
        return _pilot.ComplexWeight_setLoopWeight(self, loopWeight, nbCoresByIteration)

    def setElementaryWeight(self, elementaryWeight):
        r"""setElementaryWeight(ComplexWeight self, double elementaryWeight)"""
        return _pilot.ComplexWeight_setElementaryWeight(self, elementaryWeight)

    def setToZero(self):
        r"""setToZero(ComplexWeight self)"""
        return _pilot.ComplexWeight_setToZero(self)

    def getNbCoresConsoLoopMax(self):
        r"""getNbCoresConsoLoopMax(ComplexWeight self) -> int"""
        return _pilot.ComplexWeight_getNbCoresConsoLoopMax(self)

    def max(self, other):
        r"""max(ComplexWeight self, ComplexWeight other)"""
        return _pilot.ComplexWeight_max(self, other)

    def addWeight(self, other):
        r"""addWeight(ComplexWeight self, ComplexWeight other)"""
        return _pilot.ComplexWeight_addWeight(self, other)

# Register ComplexWeight in _pilot:
_pilot.ComplexWeight_swigregister(ComplexWeight)

class ElementaryNode(Node, Task):
    r"""Proxy of C++ YACS::ENGINE::ElementaryNode class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pilot.delete_ElementaryNode

    def exUpdateState(self):
        r"""exUpdateState(ElementaryNode self)"""
        return _pilot.ElementaryNode_exUpdateState(self)

    def init(self, start=True):
        r"""init(ElementaryNode self, bool start=True)"""
        return _pilot.ElementaryNode_init(self, start)

    def isDeployable(self):
        r"""isDeployable(ElementaryNode self) -> bool"""
        return _pilot.ElementaryNode_isDeployable(self)

    def getComponent(self, *args):
        r"""
        getComponent(ElementaryNode self) -> ComponentInstance
        getComponent(ElementaryNode self) -> ComponentInstance
        """
        return _pilot.ElementaryNode_getComponent(self, *args)

    def getContainer(self):
        r"""getContainer(ElementaryNode self) -> Container"""
        return _pilot.ElementaryNode_getContainer(self)

    def getState(self):
        r"""getState(ElementaryNode self) -> YACS::StatesForNode"""
        return _pilot.ElementaryNode_getState(self)

    def getReadyTasks(self, tasks):
        r"""getReadyTasks(ElementaryNode self, std::vector< YACS::ENGINE::Task *,std::allocator< YACS::ENGINE::Task * > > & tasks)"""
        return _pilot.ElementaryNode_getReadyTasks(self, tasks)

    def edRemovePort(self, port):
        r"""edRemovePort(ElementaryNode self, Port port)"""
        return _pilot.ElementaryNode_edRemovePort(self, port)

    def getRecursiveConstituents(self):
        r"""getRecursiveConstituents(ElementaryNode self) -> std::list< YACS::ENGINE::ElementaryNode *,std::allocator< YACS::ENGINE::ElementaryNode * > >"""
        return _pilot.ElementaryNode_getRecursiveConstituents(self)

    def getProgressWeight(self):
        r"""getProgressWeight(ElementaryNode self) -> std::list< YACS::ENGINE::ProgressWeight,std::allocator< YACS::ENGINE::ProgressWeight > >"""
        return _pilot.ElementaryNode_getProgressWeight(self)

    def getChildByName(self, name):
        r"""getChildByName(ElementaryNode self, std::string const & name) -> Node"""
        return _pilot.ElementaryNode_getChildByName(self, name)

    def checkBasicConsistency(self):
        r"""checkBasicConsistency(ElementaryNode self)"""
        return _pilot.ElementaryNode_checkBasicConsistency(self)

    def getDynClonerIfExists(self, levelToStop):
        r"""getDynClonerIfExists(ElementaryNode self, ComposedNode levelToStop) -> ComposedNode"""
        return _pilot.ElementaryNode_getDynClonerIfExists(self, levelToStop)

    def getNumberOfInputPorts(self):
        r"""getNumberOfInputPorts(ElementaryNode self) -> int"""
        return _pilot.ElementaryNode_getNumberOfInputPorts(self)

    def getNumberOfOutputPorts(self):
        r"""getNumberOfOutputPorts(ElementaryNode self) -> int"""
        return _pilot.ElementaryNode_getNumberOfOutputPorts(self)

    def getInPortName(self, arg2):
        r"""getInPortName(ElementaryNode self, InPort arg2) -> std::string"""
        return _pilot.ElementaryNode_getInPortName(self, arg2)

    def getOutPortName(self, arg2):
        r"""getOutPortName(ElementaryNode self, OutPort arg2) -> std::string"""
        return _pilot.ElementaryNode_getOutPortName(self, arg2)

    def getInputPort(self, name):
        r"""getInputPort(ElementaryNode self, std::string const & name) -> InputPort"""
        return _pilot.ElementaryNode_getInputPort(self, name)

    def getOutputPort(self, name):
        r"""getOutputPort(ElementaryNode self, std::string const & name) -> OutputPort"""
        return _pilot.ElementaryNode_getOutputPort(self, name)

    def getSetOfInputPort(self):
        r"""getSetOfInputPort(ElementaryNode self) -> std::list< YACS::ENGINE::InputPort *,std::allocator< YACS::ENGINE::InputPort * > >"""
        return _pilot.ElementaryNode_getSetOfInputPort(self)

    def getSetOfOutputPort(self):
        r"""getSetOfOutputPort(ElementaryNode self) -> std::list< YACS::ENGINE::OutputPort *,std::allocator< YACS::ENGINE::OutputPort * > >"""
        return _pilot.ElementaryNode_getSetOfOutputPort(self)

    def getLocalInputPorts(self):
        r"""getLocalInputPorts(ElementaryNode self) -> std::list< YACS::ENGINE::InputPort *,std::allocator< YACS::ENGINE::InputPort * > >"""
        return _pilot.ElementaryNode_getLocalInputPorts(self)

    def getLocalOutputPorts(self):
        r"""getLocalOutputPorts(ElementaryNode self) -> std::list< YACS::ENGINE::OutputPort *,std::allocator< YACS::ENGINE::OutputPort * > >"""
        return _pilot.ElementaryNode_getLocalOutputPorts(self)

    def getAllOutPortsLeavingCurrentScope(self):
        r"""getAllOutPortsLeavingCurrentScope(ElementaryNode self) -> std::set< YACS::ENGINE::OutPort *,std::less< YACS::ENGINE::OutPort * >,std::allocator< YACS::ENGINE::OutPort * > >"""
        return _pilot.ElementaryNode_getAllOutPortsLeavingCurrentScope(self)

    def getAllInPortsComingFromOutsideOfCurrentScope(self):
        r"""getAllInPortsComingFromOutsideOfCurrentScope(ElementaryNode self) -> std::set< YACS::ENGINE::InPort *,std::less< YACS::ENGINE::InPort * >,std::allocator< YACS::ENGINE::InPort * > >"""
        return _pilot.ElementaryNode_getAllInPortsComingFromOutsideOfCurrentScope(self)

    def getSetOfLinksLeavingCurrentScope(self):
        r"""getSetOfLinksLeavingCurrentScope(ElementaryNode self) -> linksvec"""
        return _pilot.ElementaryNode_getSetOfLinksLeavingCurrentScope(self)

    def getSetOfLinksComingInCurrentScope(self):
        r"""getSetOfLinksComingInCurrentScope(ElementaryNode self) -> linkvec"""
        return _pilot.ElementaryNode_getSetOfLinksComingInCurrentScope(self)

    def getSetOfInputDataStreamPort(self):
        r"""getSetOfInputDataStreamPort(ElementaryNode self) -> instreamlist"""
        return _pilot.ElementaryNode_getSetOfInputDataStreamPort(self)

    def getSetOfOutputDataStreamPort(self):
        r"""getSetOfOutputDataStreamPort(ElementaryNode self) -> outstreamlist"""
        return _pilot.ElementaryNode_getSetOfOutputDataStreamPort(self)

    def getInputDataStreamPort(self, name):
        r"""getInputDataStreamPort(ElementaryNode self, std::string const & name) -> InputDataStreamPort"""
        return _pilot.ElementaryNode_getInputDataStreamPort(self, name)

    def getOutputDataStreamPort(self, name):
        r"""getOutputDataStreamPort(ElementaryNode self, std::string const & name) -> OutputDataStreamPort"""
        return _pilot.ElementaryNode_getOutputDataStreamPort(self, name)

    def createInputPort(self, inputPortName, type):
        r"""createInputPort(ElementaryNode self, std::string const & inputPortName, TypeCode type) -> InputPort"""
        return _pilot.ElementaryNode_createInputPort(self, inputPortName, type)

    def createOutputPort(self, outputPortName, type):
        r"""createOutputPort(ElementaryNode self, std::string const & outputPortName, TypeCode type) -> OutputPort"""
        return _pilot.ElementaryNode_createOutputPort(self, outputPortName, type)

    def createInputDataStreamPort(self, inputPortDSName, type):
        r"""createInputDataStreamPort(ElementaryNode self, std::string const & inputPortDSName, TypeCode type) -> InputDataStreamPort"""
        return _pilot.ElementaryNode_createInputDataStreamPort(self, inputPortDSName, type)

    def createOutputDataStreamPort(self, outputPortDSName, type):
        r"""createOutputDataStreamPort(ElementaryNode self, std::string const & outputPortDSName, TypeCode type) -> OutputDataStreamPort"""
        return _pilot.ElementaryNode_createOutputDataStreamPort(self, outputPortDSName, type)

    def edAddInputPort(self, inputPortName, type):
        r"""edAddInputPort(ElementaryNode self, std::string const & inputPortName, TypeCode type) -> InputPort"""
        return _pilot.ElementaryNode_edAddInputPort(self, inputPortName, type)

    def edAddOutputPort(self, outputPortName, type):
        r"""edAddOutputPort(ElementaryNode self, std::string const & outputPortName, TypeCode type) -> OutputPort"""
        return _pilot.ElementaryNode_edAddOutputPort(self, outputPortName, type)

    def edAddInputDataStreamPort(self, inputPortDSName, type):
        r"""edAddInputDataStreamPort(ElementaryNode self, std::string const & inputPortDSName, TypeCode type) -> InputDataStreamPort"""
        return _pilot.ElementaryNode_edAddInputDataStreamPort(self, inputPortDSName, type)

    def edAddOutputDataStreamPort(self, outputPortDSName, type):
        r"""edAddOutputDataStreamPort(ElementaryNode self, std::string const & outputPortDSName, TypeCode type) -> OutputDataStreamPort"""
        return _pilot.ElementaryNode_edAddOutputDataStreamPort(self, outputPortDSName, type)

    def edOrderInputPorts(self, ports):
        r"""edOrderInputPorts(ElementaryNode self, std::list< YACS::ENGINE::InputPort *,std::allocator< YACS::ENGINE::InputPort * > > const & ports)"""
        return _pilot.ElementaryNode_edOrderInputPorts(self, ports)

    def edOrderOutputPorts(self, ports):
        r"""edOrderOutputPorts(ElementaryNode self, std::list< YACS::ENGINE::OutputPort *,std::allocator< YACS::ENGINE::OutputPort * > > const & ports)"""
        return _pilot.ElementaryNode_edOrderOutputPorts(self, ports)

    def typeName(self):
        r"""typeName(ElementaryNode self) -> std::string"""
        return _pilot.ElementaryNode_typeName(self)

    def edUpdateState(self):
        r"""edUpdateState(ElementaryNode self)"""
        return _pilot.ElementaryNode_edUpdateState(self)

    def ensureLoading(self):
        r"""ensureLoading(ElementaryNode self)"""
        return _pilot.ElementaryNode_ensureLoading(self)

    def getMaxLevelOfParallelism(self):
        r"""getMaxLevelOfParallelism(ElementaryNode self) -> int"""
        return _pilot.ElementaryNode_getMaxLevelOfParallelism(self)

    def getWeight(self):
        r"""getWeight(ElementaryNode self) -> ComplexWeight"""
        return _pilot.ElementaryNode_getWeight(self)

    def setWeight(self, elementaryWeight):
        r"""setWeight(ElementaryNode self, double elementaryWeight)"""
        return _pilot.ElementaryNode_setWeight(self, elementaryWeight)

    def getWeightRegardingDPL(self, weight):
        r"""getWeightRegardingDPL(ElementaryNode self, ComplexWeight weight)"""
        return _pilot.ElementaryNode_getWeightRegardingDPL(self, weight)

    def partitionRegardingDPL(self, pd, zeMap):
        r"""partitionRegardingDPL(ElementaryNode self, PartDefinition const * pd, std::map< YACS::ENGINE::ComposedNode *,YACS::BASES::AutoRefCnt< PartDefinition >,std::less< YACS::ENGINE::ComposedNode * >,std::allocator< std::pair< YACS::ENGINE::ComposedNode *const,YACS::BASES::AutoRefCnt< YACS::ENGINE::PartDefinition > > > > & zeMap)"""
        return _pilot.ElementaryNode_partitionRegardingDPL(self, pd, zeMap)

    def begin(self):
        r"""begin(ElementaryNode self)"""
        return _pilot.ElementaryNode_begin(self)

    def isReady(self):
        r"""isReady(ElementaryNode self) -> bool"""
        return _pilot.ElementaryNode_isReady(self)

    def finished(self):
        r"""finished(ElementaryNode self)"""
        return _pilot.ElementaryNode_finished(self)

    def aborted(self):
        r"""aborted(ElementaryNode self)"""
        return _pilot.ElementaryNode_aborted(self)

    def loaded(self):
        r"""loaded(ElementaryNode self)"""
        return _pilot.ElementaryNode_loaded(self)

    def connected(self):
        r"""connected(ElementaryNode self)"""
        return _pilot.ElementaryNode_connected(self)

    def getErrorDetails(self):
        r"""getErrorDetails(ElementaryNode self) -> std::string"""
        return _pilot.ElementaryNode_getErrorDetails(self)

    def initService(self):
        r"""initService(ElementaryNode self)"""
        return _pilot.ElementaryNode_initService(self)

    def connectService(self):
        r"""connectService(ElementaryNode self)"""
        return _pilot.ElementaryNode_connectService(self)

    def disconnectService(self):
        r"""disconnectService(ElementaryNode self)"""
        return _pilot.ElementaryNode_disconnectService(self)

    def load(self):
        r"""load(ElementaryNode self)"""
        return _pilot.ElementaryNode_load(self)

    def getCoupledTasks(self, coupledSet):
        r"""getCoupledTasks(ElementaryNode self, std::set< YACS::ENGINE::Task *,std::less< YACS::ENGINE::Task * >,std::allocator< YACS::ENGINE::Task * > > & coupledSet)"""
        return _pilot.ElementaryNode_getCoupledTasks(self, coupledSet)

    def getCoupledNodes(self, coupledSet):
        r"""getCoupledNodes(ElementaryNode self, std::set< YACS::ENGINE::Task *,std::less< YACS::ENGINE::Task * >,std::allocator< YACS::ENGINE::Task * > > & coupledSet)"""
        return _pilot.ElementaryNode_getCoupledNodes(self, coupledSet)

    def accept(self, visitor):
        r"""accept(ElementaryNode self, Visitor visitor)"""
        return _pilot.ElementaryNode_accept(self, visitor)

    def addDatastreamPortToInitMultiService(self, port_name, number):
        r"""addDatastreamPortToInitMultiService(ElementaryNode self, std::string const & port_name, int number)"""
        return _pilot.ElementaryNode_addDatastreamPortToInitMultiService(self, port_name, number)

# Register ElementaryNode in _pilot:
_pilot.ElementaryNode_swigregister(ElementaryNode)

class InlineNode(ElementaryNode):
    r"""Proxy of C++ YACS::ENGINE::InlineNode class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setScript(self, script):
        r"""setScript(InlineNode self, std::string const & script)"""
        return _pilot.InlineNode_setScript(self, script)

    def getScript(self):
        r"""getScript(InlineNode self) -> std::string"""
        return _pilot.InlineNode_getScript(self)

    def cloneNode(self, name):
        r"""cloneNode(InlineNode self, std::string const & name) -> InlineNode"""
        return _pilot.InlineNode_cloneNode(self, name)

    def accept(self, visitor):
        r"""accept(InlineNode self, Visitor visitor)"""
        return _pilot.InlineNode_accept(self, visitor)
    __swig_destroy__ = _pilot.delete_InlineNode

    def typeName(self):
        r"""typeName(InlineNode self) -> std::string"""
        return _pilot.InlineNode_typeName(self)

    def setExecutionMode(self, mode):
        r"""setExecutionMode(InlineNode self, std::string const & mode)"""
        return _pilot.InlineNode_setExecutionMode(self, mode)

    def getExecutionMode(self):
        r"""getExecutionMode(InlineNode self) -> std::string"""
        return _pilot.InlineNode_getExecutionMode(self)

    def setContainer(self, container):
        r"""setContainer(InlineNode self, Container container)"""
        return _pilot.InlineNode_setContainer(self, container)

    def getContainer(self):
        r"""getContainer(InlineNode self) -> Container"""
        return _pilot.InlineNode_getContainer(self)

    def performDuplicationOfPlacement(self, other):
        r"""performDuplicationOfPlacement(InlineNode self, Node other)"""
        return _pilot.InlineNode_performDuplicationOfPlacement(self, other)

    def performShallowDuplicationOfPlacement(self, other):
        r"""performShallowDuplicationOfPlacement(InlineNode self, Node other)"""
        return _pilot.InlineNode_performShallowDuplicationOfPlacement(self, other)

    def isDeployable(self):
        r"""isDeployable(InlineNode self) -> bool"""
        return _pilot.InlineNode_isDeployable(self)

    def getMaxLevelOfParallelism(self):
        r"""getMaxLevelOfParallelism(InlineNode self) -> int"""
        return _pilot.InlineNode_getMaxLevelOfParallelism(self)

# Register InlineNode in _pilot:
_pilot.InlineNode_swigregister(InlineNode)
InlineNode.LOCAL_STR = _pilot.cvar.InlineNode_LOCAL_STR
InlineNode.REMOTE_STR = _pilot.cvar.InlineNode_REMOTE_STR

class InlineFuncNode(InlineNode):
    r"""Proxy of C++ YACS::ENGINE::InlineFuncNode class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setFname(self, fname):
        r"""setFname(InlineFuncNode self, std::string const & fname)"""
        return _pilot.InlineFuncNode_setFname(self, fname)

    def getFname(self):
        r"""getFname(InlineFuncNode self) -> std::string"""
        return _pilot.InlineFuncNode_getFname(self)

    def accept(self, visitor):
        r"""accept(InlineFuncNode self, Visitor visitor)"""
        return _pilot.InlineFuncNode_accept(self, visitor)
    __swig_destroy__ = _pilot.delete_InlineFuncNode

    def typeName(self):
        r"""typeName(InlineFuncNode self) -> std::string"""
        return _pilot.InlineFuncNode_typeName(self)

    def checkBasicConsistency(self):
        r"""checkBasicConsistency(InlineFuncNode self)"""
        return _pilot.InlineFuncNode_checkBasicConsistency(self)

# Register InlineFuncNode in _pilot:
_pilot.InlineFuncNode_swigregister(InlineFuncNode)

class ServiceNode(ElementaryNode):
    r"""Proxy of C++ YACS::ENGINE::ServiceNode class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def load(self):
        r"""load(ServiceNode self)"""
        return _pilot.ServiceNode_load(self)

    def isDeployable(self):
        r"""isDeployable(ServiceNode self) -> bool"""
        return _pilot.ServiceNode_isDeployable(self)

    def setComponent(self, compo):
        r"""setComponent(ServiceNode self, ComponentInstance compo)"""
        return _pilot.ServiceNode_setComponent(self, compo)

    def getComponent(self, *args):
        r"""
        getComponent(ServiceNode self) -> ComponentInstance
        getComponent(ServiceNode self) -> ComponentInstance
        """
        return _pilot.ServiceNode_getComponent(self, *args)

    def getContainer(self):
        r"""getContainer(ServiceNode self) -> Container"""
        return _pilot.ServiceNode_getContainer(self)

    def setRef(self, ref):
        r"""setRef(ServiceNode self, std::string const & ref)"""
        return _pilot.ServiceNode_setRef(self, ref)

    def getRef(self):
        r"""getRef(ServiceNode self) -> std::string"""
        return _pilot.ServiceNode_getRef(self)

    def setMethod(self, method):
        r"""setMethod(ServiceNode self, std::string const & method)"""
        return _pilot.ServiceNode_setMethod(self, method)

    def getMethod(self):
        r"""getMethod(ServiceNode self) -> std::string"""
        return _pilot.ServiceNode_getMethod(self)

    def createNode(self, name):
        r"""createNode(ServiceNode self, std::string const & name) -> ServiceNode"""
        return _pilot.ServiceNode_createNode(self, name)
    __swig_destroy__ = _pilot.delete_ServiceNode

    def accept(self, visitor):
        r"""accept(ServiceNode self, Visitor visitor)"""
        return _pilot.ServiceNode_accept(self, visitor)

    def getKind(self):
        r"""getKind(ServiceNode self) -> std::string"""
        return _pilot.ServiceNode_getKind(self)

    def typeName(self):
        r"""typeName(ServiceNode self) -> std::string"""
        return _pilot.ServiceNode_typeName(self)

# Register ServiceNode in _pilot:
_pilot.ServiceNode_swigregister(ServiceNode)
ServiceNode.KIND = _pilot.cvar.ServiceNode_KIND

class ServiceInlineNode(ServiceNode):
    r"""Proxy of C++ YACS::ENGINE::ServiceInlineNode class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setScript(self, script):
        r"""setScript(ServiceInlineNode self, std::string const & script)"""
        return _pilot.ServiceInlineNode_setScript(self, script)

    def getScript(self):
        r"""getScript(ServiceInlineNode self) -> std::string"""
        return _pilot.ServiceInlineNode_getScript(self)

    def accept(self, visitor):
        r"""accept(ServiceInlineNode self, Visitor visitor)"""
        return _pilot.ServiceInlineNode_accept(self, visitor)

    def typeName(self):
        r"""typeName(ServiceInlineNode self) -> std::string"""
        return _pilot.ServiceInlineNode_typeName(self)
    __swig_destroy__ = _pilot.delete_ServiceInlineNode

# Register ServiceInlineNode in _pilot:
_pilot.ServiceInlineNode_swigregister(ServiceInlineNode)

class ServerNode(InlineFuncNode):
    r"""Proxy of C++ YACS::ENGINE::ServerNode class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def load(self):
        r"""load(ServerNode self)"""
        return _pilot.ServerNode_load(self)

    def accept(self, visitor):
        r"""accept(ServerNode self, Visitor visitor)"""
        return _pilot.ServerNode_accept(self, visitor)

    def createNode(self, name):
        r"""createNode(ServerNode self, std::string const & name) -> ServerNode"""
        return _pilot.ServerNode_createNode(self, name)

    def isDeployable(self):
        r"""isDeployable(ServerNode self) -> bool"""
        return _pilot.ServerNode_isDeployable(self)

    def getEffectiveKindOfServer(self):
        r"""getEffectiveKindOfServer(ServerNode self) -> std::string"""
        return _pilot.ServerNode_getEffectiveKindOfServer(self)
    __swig_destroy__ = _pilot.delete_ServerNode

    def typeName(self):
        r"""typeName(ServerNode self) -> std::string"""
        return _pilot.ServerNode_typeName(self)

# Register ServerNode in _pilot:
_pilot.ServerNode_swigregister(ServerNode)

class DataNode(ElementaryNode):
    r"""Proxy of C++ YACS::ENGINE::DataNode class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setData(self, *args):
        r"""
        setData(DataNode self, InputPort port, std::string const & data)
        setData(DataNode self, OutputPort port, std::string const & data)
        """
        return _pilot.DataNode_setData(self, *args)

    def setRef(self, ref):
        r"""setRef(DataNode self, std::string const & ref)"""
        return _pilot.DataNode_setRef(self, ref)

    def getRef(self):
        r"""getRef(DataNode self) -> std::string"""
        return _pilot.DataNode_getRef(self)
    __swig_destroy__ = _pilot.delete_DataNode

    def typeName(self):
        r"""typeName(DataNode self) -> std::string"""
        return _pilot.DataNode_typeName(self)

# Register DataNode in _pilot:
_pilot.DataNode_swigregister(DataNode)

class ComposedNode(Node, Scheduler):
    r"""Proxy of C++ YACS::ENGINE::ComposedNode class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pilot.delete_ComposedNode

    def isFinished(self):
        r"""isFinished(ComposedNode self) -> bool"""
        return _pilot.ComposedNode_isFinished(self)

    def init(self, start=True):
        r"""init(ComposedNode self, bool start=True)"""
        return _pilot.ComposedNode_init(self, start)

    def shutdown(self, level):
        r"""shutdown(ComposedNode self, int level)"""
        return _pilot.ComposedNode_shutdown(self, level)

    def resetState(self, level):
        r"""resetState(ComposedNode self, int level)"""
        return _pilot.ComposedNode_resetState(self, level)

    def getName(self):
        r"""getName(ComposedNode self) -> std::string"""
        return _pilot.ComposedNode_getName(self)

    def getTaskName(self, task):
        r"""getTaskName(ComposedNode self, Task task) -> std::string"""
        return _pilot.ComposedNode_getTaskName(self, task)

    def getDeploymentTree(self):
        r"""getDeploymentTree(ComposedNode self) -> DeploymentTree"""
        return _pilot.ComposedNode_getDeploymentTree(self)

    def checkDeploymentTree(self, deep):
        r"""checkDeploymentTree(ComposedNode self, bool deep) -> DeploymentTree"""
        return _pilot.ComposedNode_checkDeploymentTree(self, deep)

    def getNextTasks(self, isMore):
        r"""getNextTasks(ComposedNode self, bool & isMore) -> std::vector< YACS::ENGINE::Task *,std::allocator< YACS::ENGINE::Task * > >"""
        return _pilot.ComposedNode_getNextTasks(self, isMore)

    def isPlacementPredictableB4Run(self):
        r"""isPlacementPredictableB4Run(ComposedNode self) -> bool"""
        return _pilot.ComposedNode_isPlacementPredictableB4Run(self)

    def notifyFrom(self, sender, event, execInst):
        r"""notifyFrom(ComposedNode self, Task sender, YACS::Event event, Executor execInst)"""
        return _pilot.ComposedNode_notifyFrom(self, sender, event, execInst)

    def edAddDFLink(self, start, end):
        r"""edAddDFLink(ComposedNode self, OutPort start, InPort end) -> bool"""
        return _pilot.ComposedNode_edAddDFLink(self, start, end)

    def edAddChild(self, DISOWNnode):
        r"""edAddChild(ComposedNode self, Node DISOWNnode) -> bool"""
        return _pilot.ComposedNode_edAddChild(self, DISOWNnode)

    def edRemoveChild(self, node):
        r"""edRemoveChild(ComposedNode self, Node node)"""
        return _pilot.ComposedNode_edRemoveChild(self, node)

    def edAddLink(self, *args):
        r"""
        edAddLink(ComposedNode self, OutPort start, InPort end) -> bool
        edAddLink(ComposedNode self, OutGate start, InGate end) -> bool
        """
        return _pilot.ComposedNode_edAddLink(self, *args)

    def edAddCFLink(self, nodeS, nodeE):
        r"""edAddCFLink(ComposedNode self, Node nodeS, Node nodeE) -> bool"""
        return _pilot.ComposedNode_edAddCFLink(self, nodeS, nodeE)

    def edRemoveCFLink(self, nodeS, nodeE):
        r"""edRemoveCFLink(ComposedNode self, Node nodeS, Node nodeE)"""
        return _pilot.ComposedNode_edRemoveCFLink(self, nodeS, nodeE)

    def edRemoveLink(self, *args):
        r"""
        edRemoveLink(ComposedNode self, OutPort start, InPort end)
        edRemoveLink(ComposedNode self, OutGate start, InGate end)
        """
        return _pilot.ComposedNode_edRemoveLink(self, *args)

    def isRepeatedUnpredictablySeveralTimes(self):
        r"""isRepeatedUnpredictablySeveralTimes(ComposedNode self) -> bool"""
        return _pilot.ComposedNode_isRepeatedUnpredictablySeveralTimes(self)

    def isLoop(self):
        r"""isLoop(ComposedNode self) -> bool"""
        return _pilot.ComposedNode_isLoop(self)

    def edGetDirectDescendants(self):
        r"""edGetDirectDescendants(ComposedNode self) -> std::list< YACS::ENGINE::Node *,std::allocator< YACS::ENGINE::Node * > >"""
        return _pilot.ComposedNode_edGetDirectDescendants(self)

    def removeRecursivelyRedundantCL(self):
        r"""removeRecursivelyRedundantCL(ComposedNode self)"""
        return _pilot.ComposedNode_removeRecursivelyRedundantCL(self)

    def getRecursiveConstituents(self):
        r"""getRecursiveConstituents(ComposedNode self) -> std::list< YACS::ENGINE::ElementaryNode *,std::allocator< YACS::ENGINE::ElementaryNode * > >"""
        return _pilot.ComposedNode_getRecursiveConstituents(self)

    def getAllRecursiveNodes(self):
        r"""getAllRecursiveNodes(ComposedNode self) -> std::list< YACS::ENGINE::Node *,std::allocator< YACS::ENGINE::Node * > >"""
        return _pilot.ComposedNode_getAllRecursiveNodes(self)

    def getAllRecursiveConstituents(self):
        r"""getAllRecursiveConstituents(ComposedNode self) -> std::list< YACS::ENGINE::Node *,std::allocator< YACS::ENGINE::Node * > >"""
        return _pilot.ComposedNode_getAllRecursiveConstituents(self)

    def getProgressWeight(self):
        r"""getProgressWeight(ComposedNode self) -> std::list< YACS::ENGINE::ProgressWeight,std::allocator< YACS::ENGINE::ProgressWeight > >"""
        return _pilot.ComposedNode_getProgressWeight(self)

    def getInPortName(self, arg2):
        r"""getInPortName(ComposedNode self, InPort arg2) -> std::string"""
        return _pilot.ComposedNode_getInPortName(self, arg2)

    def getOutPortName(self, arg2):
        r"""getOutPortName(ComposedNode self, OutPort arg2) -> std::string"""
        return _pilot.ComposedNode_getOutPortName(self, arg2)

    def getNumberOfInputPorts(self):
        r"""getNumberOfInputPorts(ComposedNode self) -> int"""
        return _pilot.ComposedNode_getNumberOfInputPorts(self)

    def getNumberOfOutputPorts(self):
        r"""getNumberOfOutputPorts(ComposedNode self) -> int"""
        return _pilot.ComposedNode_getNumberOfOutputPorts(self)

    def getSetOfInputPort(self):
        r"""getSetOfInputPort(ComposedNode self) -> std::list< YACS::ENGINE::InputPort *,std::allocator< YACS::ENGINE::InputPort * > >"""
        return _pilot.ComposedNode_getSetOfInputPort(self)

    def getSetOfOutputPort(self):
        r"""getSetOfOutputPort(ComposedNode self) -> std::list< YACS::ENGINE::OutputPort *,std::allocator< YACS::ENGINE::OutputPort * > >"""
        return _pilot.ComposedNode_getSetOfOutputPort(self)

    def getLocalInputPorts(self):
        r"""getLocalInputPorts(ComposedNode self) -> std::list< YACS::ENGINE::InputPort *,std::allocator< YACS::ENGINE::InputPort * > >"""
        return _pilot.ComposedNode_getLocalInputPorts(self)

    def getLocalOutputPorts(self):
        r"""getLocalOutputPorts(ComposedNode self) -> std::list< YACS::ENGINE::OutputPort *,std::allocator< YACS::ENGINE::OutputPort * > >"""
        return _pilot.ComposedNode_getLocalOutputPorts(self)

    def getAllOutPortsLeavingCurrentScope(self):
        r"""getAllOutPortsLeavingCurrentScope(ComposedNode self) -> std::set< YACS::ENGINE::OutPort *,std::less< YACS::ENGINE::OutPort * >,std::allocator< YACS::ENGINE::OutPort * > >"""
        return _pilot.ComposedNode_getAllOutPortsLeavingCurrentScope(self)

    def getAllInPortsComingFromOutsideOfCurrentScope(self):
        r"""getAllInPortsComingFromOutsideOfCurrentScope(ComposedNode self) -> std::set< YACS::ENGINE::InPort *,std::less< YACS::ENGINE::InPort * >,std::allocator< YACS::ENGINE::InPort * > >"""
        return _pilot.ComposedNode_getAllInPortsComingFromOutsideOfCurrentScope(self)

    def getSetOfInputDataStreamPort(self):
        r"""getSetOfInputDataStreamPort(ComposedNode self) -> instreamlist"""
        return _pilot.ComposedNode_getSetOfInputDataStreamPort(self)

    def getSetOfOutputDataStreamPort(self):
        r"""getSetOfOutputDataStreamPort(ComposedNode self) -> outstreamlist"""
        return _pilot.ComposedNode_getSetOfOutputDataStreamPort(self)

    def getOutPort(self, name):
        r"""getOutPort(ComposedNode self, std::string const & name) -> OutPort"""
        return _pilot.ComposedNode_getOutPort(self, name)

    def getInputPort(self, name):
        r"""getInputPort(ComposedNode self, std::string const & name) -> InputPort"""
        return _pilot.ComposedNode_getInputPort(self, name)

    def getOutputPort(self, name):
        r"""getOutputPort(ComposedNode self, std::string const & name) -> OutputPort"""
        return _pilot.ComposedNode_getOutputPort(self, name)

    def getInputDataStreamPort(self, name):
        r"""getInputDataStreamPort(ComposedNode self, std::string const & name) -> InputDataStreamPort"""
        return _pilot.ComposedNode_getInputDataStreamPort(self, name)

    def getOutputDataStreamPort(self, name):
        r"""getOutputDataStreamPort(ComposedNode self, std::string const & name) -> OutputDataStreamPort"""
        return _pilot.ComposedNode_getOutputDataStreamPort(self, name)

    def getSetOfInternalLinks(self):
        r"""getSetOfInternalLinks(ComposedNode self) -> linksvec"""
        return _pilot.ComposedNode_getSetOfInternalLinks(self)

    def getSetOfLinksLeavingCurrentScope(self):
        r"""getSetOfLinksLeavingCurrentScope(ComposedNode self) -> linksvec"""
        return _pilot.ComposedNode_getSetOfLinksLeavingCurrentScope(self)

    def checkConsistency(self, info):
        r"""checkConsistency(ComposedNode self, LinkInfo info)"""
        return _pilot.ComposedNode_checkConsistency(self, info)

    def getSetOfLinksComingInCurrentScope(self):
        r"""getSetOfLinksComingInCurrentScope(ComposedNode self) -> linkvec"""
        return _pilot.ComposedNode_getSetOfLinksComingInCurrentScope(self)

    def typeName(self):
        r"""typeName(ComposedNode self) -> std::string"""
        return _pilot.ComposedNode_typeName(self)

    def edUpdateState(self):
        r"""edUpdateState(ComposedNode self)"""
        return _pilot.ComposedNode_edUpdateState(self)

    def checkBasicConsistency(self):
        r"""checkBasicConsistency(ComposedNode self)"""
        return _pilot.ComposedNode_checkBasicConsistency(self)

    def getErrorReport(self):
        r"""getErrorReport(ComposedNode self) -> std::string"""
        return _pilot.ComposedNode_getErrorReport(self)

    def getRootNode(self):
        r"""getRootNode(ComposedNode self) -> ComposedNode"""
        return _pilot.ComposedNode_getRootNode(self)

    def isNodeAlreadyAggregated(self, node):
        r"""isNodeAlreadyAggregated(ComposedNode self, Node node) -> bool"""
        return _pilot.ComposedNode_isNodeAlreadyAggregated(self, node)

    def isNameAlreadyUsed(self, name):
        r"""isNameAlreadyUsed(ComposedNode self, std::string const & name) -> bool"""
        return _pilot.ComposedNode_isNameAlreadyUsed(self, name)

    def isInMyDescendance(self, nodeToTest):
        r"""isInMyDescendance(ComposedNode self, Node nodeToTest) -> Node"""
        return _pilot.ComposedNode_isInMyDescendance(self, nodeToTest)

    def getChildName(self, node):
        r"""getChildName(ComposedNode self, Node node) -> std::string"""
        return _pilot.ComposedNode_getChildName(self, node)

    def getMyQualifiedName(self, directSon):
        r"""getMyQualifiedName(ComposedNode self, Node directSon) -> std::string"""
        return _pilot.ComposedNode_getMyQualifiedName(self, directSon)

    def getChildByName(self, name):
        r"""getChildByName(ComposedNode self, std::string const & name) -> Node"""
        return _pilot.ComposedNode_getChildByName(self, name)

    @staticmethod
    def getLowestCommonAncestor(node1, node2):
        r"""getLowestCommonAncestor(Node node1, Node node2) -> ComposedNode"""
        return _pilot.ComposedNode_getLowestCommonAncestor(node1, node2)

    @staticmethod
    def getLowestCommonAncestorStr(node1, node2):
        r"""getLowestCommonAncestorStr(std::string const & node1, std::string const & node2) -> std::string"""
        return _pilot.ComposedNode_getLowestCommonAncestorStr(node1, node2)

    def loaded(self):
        r"""loaded(ComposedNode self)"""
        return _pilot.ComposedNode_loaded(self)

    def connected(self):
        r"""connected(ComposedNode self)"""
        return _pilot.ComposedNode_connected(self)

    def accept(self, visitor):
        r"""accept(ComposedNode self, Visitor visitor)"""
        return _pilot.ComposedNode_accept(self, visitor)

    def cleanNodes(self):
        r"""cleanNodes(ComposedNode self)"""
        return _pilot.ComposedNode_cleanNodes(self)

    def getProgress(self):
        r"""getProgress(ComposedNode self) -> std::string"""
        return _pilot.ComposedNode_getProgress(self)

    def setProperty(self, name, value):
        r"""setProperty(ComposedNode self, std::string const & name, std::string const & value)"""
        return _pilot.ComposedNode_setProperty(self, name, value)

    def getProperty(self, name):
        r"""getProperty(ComposedNode self, std::string const & name) -> std::string"""
        return _pilot.ComposedNode_getProperty(self, name)

# Register ComposedNode in _pilot:
_pilot.ComposedNode_swigregister(ComposedNode)
ComposedNode.SEP_CHAR_BTW_LEVEL = _pilot.cvar.ComposedNode_SEP_CHAR_BTW_LEVEL

def ComposedNode_getLowestCommonAncestor(node1, node2):
    r"""ComposedNode_getLowestCommonAncestor(Node node1, Node node2) -> ComposedNode"""
    return _pilot.ComposedNode_getLowestCommonAncestor(node1, node2)

def ComposedNode_getLowestCommonAncestorStr(node1, node2):
    r"""ComposedNode_getLowestCommonAncestorStr(std::string const & node1, std::string const & node2) -> std::string"""
    return _pilot.ComposedNode_getLowestCommonAncestorStr(node1, node2)

class StaticDefinedComposedNode(ComposedNode):
    r"""Proxy of C++ YACS::ENGINE::StaticDefinedComposedNode class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def isPlacementPredictableB4Run(self):
        r"""isPlacementPredictableB4Run(StaticDefinedComposedNode self) -> bool"""
        return _pilot.StaticDefinedComposedNode_isPlacementPredictableB4Run(self)

    def isMultiplicitySpecified(self, value):
        r"""isMultiplicitySpecified(StaticDefinedComposedNode self, unsigned int & value) -> bool"""
        return _pilot.StaticDefinedComposedNode_isMultiplicitySpecified(self, value)

    def forceMultiplicity(self, value):
        r"""forceMultiplicity(StaticDefinedComposedNode self, unsigned int value)"""
        return _pilot.StaticDefinedComposedNode_forceMultiplicity(self, value)

    def selectRunnableTasks(self, tasks):
        r"""selectRunnableTasks(StaticDefinedComposedNode self, std::vector< YACS::ENGINE::Task *,std::allocator< YACS::ENGINE::Task * > > & tasks)"""
        return _pilot.StaticDefinedComposedNode_selectRunnableTasks(self, tasks)
    __swig_destroy__ = _pilot.delete_StaticDefinedComposedNode

# Register StaticDefinedComposedNode in _pilot:
_pilot.StaticDefinedComposedNode_swigregister(StaticDefinedComposedNode)

class Bloc(StaticDefinedComposedNode):
    r"""Proxy of C++ YACS::ENGINE::Bloc class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pilot.delete_Bloc

    def isFinished(self):
        r"""isFinished(Bloc self) -> bool"""
        return _pilot.Bloc_isFinished(self)

    def getNumberOfCFLinks(self):
        r"""getNumberOfCFLinks(Bloc self) -> int"""
        return _pilot.Bloc_getNumberOfCFLinks(self)

    def init(self, start=True):
        r"""init(Bloc self, bool start=True)"""
        return _pilot.Bloc_init(self, start)

    def getReadyTasks(self, tasks):
        r"""getReadyTasks(Bloc self, std::vector< YACS::ENGINE::Task *,std::allocator< YACS::ENGINE::Task * > > & tasks)"""
        return _pilot.Bloc_getReadyTasks(self, tasks)

    def exUpdateState(self):
        r"""exUpdateState(Bloc self)"""
        return _pilot.Bloc_exUpdateState(self)

    def edAddChild(self, DISOWNnode):
        r"""edAddChild(Bloc self, Node DISOWNnode) -> bool"""
        return _pilot.Bloc_edAddChild(self, DISOWNnode)

    def edRemoveChild(self, node):
        r"""edRemoveChild(Bloc self, Node node)"""
        val = _pilot.Bloc_edRemoveChild(self, node)

        args[1].thisown=1


        return val


    def getChildren(self):
        r"""getChildren(Bloc self) -> std::list< YACS::ENGINE::Node *,std::allocator< YACS::ENGINE::Node * > >"""
        return _pilot.Bloc_getChildren(self)

    def edGetDirectDescendants(self):
        r"""edGetDirectDescendants(Bloc self) -> std::list< YACS::ENGINE::Node *,std::allocator< YACS::ENGINE::Node * > >"""
        return _pilot.Bloc_edGetDirectDescendants(self)

    def splitIntoIndependantGraph(self):
        r"""splitIntoIndependantGraph(Bloc self) -> std::vector< std::list< YACS::ENGINE::Node *,std::allocator< YACS::ENGINE::Node * > >,std::allocator< std::list< YACS::ENGINE::Node *,std::allocator< YACS::ENGINE::Node * > > > >"""
        return _pilot.Bloc_splitIntoIndependantGraph(self)

    def getChildByShortName(self, name):
        r"""getChildByShortName(Bloc self, std::string const & name) -> Node"""
        return _pilot.Bloc_getChildByShortName(self, name)

    def writeDot(self, os):
        r"""writeDot(Bloc self, std::ostream & os)"""
        return _pilot.Bloc_writeDot(self, os)

    def accept(self, visitor):
        r"""accept(Bloc self, Visitor visitor)"""
        return _pilot.Bloc_accept(self, visitor)

    def typeName(self):
        r"""typeName(Bloc self) -> std::string"""
        return _pilot.Bloc_typeName(self)

    def getMaxLevelOfParallelism(self):
        r"""getMaxLevelOfParallelism(Bloc self) -> int"""
        return _pilot.Bloc_getMaxLevelOfParallelism(self)

    def getWeightRegardingDPL(self, weight):
        r"""getWeightRegardingDPL(Bloc self, ComplexWeight weight)"""
        return _pilot.Bloc_getWeightRegardingDPL(self, weight)

    def removeRecursivelyRedundantCL(self):
        r"""removeRecursivelyRedundantCL(Bloc self)"""
        return _pilot.Bloc_removeRecursivelyRedundantCL(self)

    def partitionRegardingDPL(self, pd, zeMap):
        r"""partitionRegardingDPL(Bloc self, PartDefinition pd, std::map< YACS::ENGINE::ComposedNode *,YACS::BASES::AutoRefCnt< YACS::ENGINE::PartDefinition >,std::less< YACS::ENGINE::ComposedNode * >,std::allocator< std::pair< YACS::ENGINE::ComposedNode *const,YACS::BASES::AutoRefCnt< YACS::ENGINE::PartDefinition > > > > & zeMap)"""
        return _pilot.Bloc_partitionRegardingDPL(self, pd, zeMap)

    def fitToPlayGround(self, pg):
        r"""fitToPlayGround(Bloc self, PlayGround pg)"""
        return _pilot.Bloc_fitToPlayGround(self, pg)

    def propagePlayGround(self, pg):
        r"""propagePlayGround(Bloc self, PlayGround pg)"""
        return _pilot.Bloc_propagePlayGround(self, pg)

# Register Bloc in _pilot:
_pilot.Bloc_swigregister(Bloc)

class Proc(Bloc):
    r"""Proxy of C++ YACS::ENGINE::Proc class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pilot.delete_Proc

    def createType(self, name, kind):
        r"""createType(Proc self, std::string const & name, std::string const & kind) -> TypeCode"""
        return _pilot.Proc_createType(self, name, kind)

    def createInterfaceTc(self, id, name, ltc):
        r"""createInterfaceTc(Proc self, std::string const & id, std::string const & name, std::list< YACS::ENGINE::TypeCodeObjref *,std::allocator< YACS::ENGINE::TypeCodeObjref * > > ltc) -> TypeCode"""
        return _pilot.Proc_createInterfaceTc(self, id, name, ltc)

    def createSequenceTc(self, id, name, content):
        r"""createSequenceTc(Proc self, std::string const & id, std::string const & name, TypeCode content) -> TypeCode"""
        return _pilot.Proc_createSequenceTc(self, id, name, content)

    def createStructTc(self, id, name):
        r"""createStructTc(Proc self, std::string const & id, std::string const & name) -> TypeCode"""
        return _pilot.Proc_createStructTc(self, id, name)

    def getTypeCode(self, name):
        r"""getTypeCode(Proc self, std::string const & name) -> TypeCode"""
        return _pilot.Proc_getTypeCode(self, name)

    def setTypeCode(self, name, t):
        r"""setTypeCode(Proc self, std::string const & name, TypeCode t)"""
        return _pilot.Proc_setTypeCode(self, name, t)

    def createContainer(self, *args):
        r"""createContainer(Proc self, std::string const & name, std::string const & kind="") -> Container"""
        return _pilot.Proc_createContainer(self, *args)

    def createComponentInstance(self, *args):
        r"""createComponentInstance(Proc self, std::string const & componame, std::string const & name="", std::string const & kind="") -> ComponentInstance"""
        return _pilot.Proc_createComponentInstance(self, *args)

    def addComponentInstance(self, *args):
        r"""addComponentInstance(Proc self, ComponentInstance inst, std::string const & name="", bool resetCtr=False)"""
        return _pilot.Proc_addComponentInstance(self, *args)

    def removeComponentInstance(self, inst):
        r"""removeComponentInstance(Proc self, ComponentInstance inst)"""
        return _pilot.Proc_removeComponentInstance(self, inst)

    def removeContainer(self, cont):
        r"""removeContainer(Proc self, Container cont)"""
        return _pilot.Proc_removeContainer(self, cont)

    def accept(self, visitor):
        r"""accept(Proc self, Visitor visitor)"""
        return _pilot.Proc_accept(self, visitor)

    def getProc(self, *args):
        r"""
        getProc(Proc self) -> Proc
        getProc(Proc self) -> Proc
        """
        return _pilot.Proc_getProc(self, *args)

    def updateContainersAndComponents(self):
        r"""updateContainersAndComponents(Proc self)"""
        return _pilot.Proc_updateContainersAndComponents(self)

    def getNodeState(self, numId):
        r"""getNodeState(Proc self, int numId) -> YACS::StatesForNode"""
        return _pilot.Proc_getNodeState(self, numId)

    def getNodeProgress(self, numId):
        r"""getNodeProgress(Proc self, int numId) -> std::string"""
        return _pilot.Proc_getNodeProgress(self, numId)

    def getGlobalProgressPercent(self):
        r"""getGlobalProgressPercent(Proc self) -> int"""
        return _pilot.Proc_getGlobalProgressPercent(self)

    def getInPortValue(self, nodeNumId, portName):
        r"""getInPortValue(Proc self, int nodeNumId, std::string portName) -> std::string"""
        return _pilot.Proc_getInPortValue(self, nodeNumId, portName)

    def setInPortValue(self, nodeName, portName, value):
        r"""setInPortValue(Proc self, std::string nodeName, std::string portName, std::string value) -> std::string"""
        return _pilot.Proc_setInPortValue(self, nodeName, portName, value)

    def getOutPortValue(self, nodeNumId, portName):
        r"""getOutPortValue(Proc self, int nodeNumId, std::string portName) -> std::string"""
        return _pilot.Proc_getOutPortValue(self, nodeNumId, portName)

    def getNodeErrorDetails(self, nodeNumId):
        r"""getNodeErrorDetails(Proc self, int nodeNumId) -> std::string"""
        return _pilot.Proc_getNodeErrorDetails(self, nodeNumId)

    def getNodeErrorReport(self, nodeNumId):
        r"""getNodeErrorReport(Proc self, int nodeNumId) -> std::string"""
        return _pilot.Proc_getNodeErrorReport(self, nodeNumId)

    def getNodeContainerLog(self, nodeNumId):
        r"""getNodeContainerLog(Proc self, int nodeNumId) -> std::string"""
        return _pilot.Proc_getNodeContainerLog(self, nodeNumId)

    def getXMLState(self, numId):
        r"""getXMLState(Proc self, int numId) -> std::string"""
        return _pilot.Proc_getXMLState(self, numId)

    def getNumIds(self):
        r"""getNumIds(Proc self) -> std::list< int,std::allocator< int > >"""
        return _pilot.Proc_getNumIds(self)

    def getIds(self):
        r"""getIds(Proc self) -> std::list< std::string,std::allocator< std::string > >"""
        return _pilot.Proc_getIds(self)

    def getLogger(self, name):
        r"""getLogger(Proc self, std::string const & name) -> Logger"""
        return _pilot.Proc_getLogger(self, name)

    def writeDot(self, os):
        r"""writeDot(Proc self, std::ostream & os)"""
        return _pilot.Proc_writeDot(self, os)

    def setName(self, name):
        r"""setName(Proc self, std::string const & name)"""
        return _pilot.Proc_setName(self, name)

    def typeName(self):
        r"""typeName(Proc self) -> std::string"""
        return _pilot.Proc_typeName(self)
    nodeMap = property(_pilot.Proc_nodeMap_get, _pilot.Proc_nodeMap_set, doc=r"""nodeMap : std::map<(std::string,p.YACS::ENGINE::Node,std::less<(std::string)>,std::allocator<(std::pair<(q(const).std::string,p.YACS::ENGINE::Node)>)>)>""")
    serviceMap = property(_pilot.Proc_serviceMap_get, _pilot.Proc_serviceMap_set, doc=r"""serviceMap : std::map<(std::string,p.YACS::ENGINE::ServiceNode,std::less<(std::string)>,std::allocator<(std::pair<(q(const).std::string,p.YACS::ENGINE::ServiceNode)>)>)>""")
    inlineMap = property(_pilot.Proc_inlineMap_get, _pilot.Proc_inlineMap_set, doc=r"""inlineMap : std::map<(std::string,p.YACS::ENGINE::InlineNode,std::less<(std::string)>,std::allocator<(std::pair<(q(const).std::string,p.YACS::ENGINE::InlineNode)>)>)>""")
    typeMap = property(_pilot.Proc_typeMap_get, _pilot.Proc_typeMap_set, doc=r"""typeMap : std::map<(std::string,p.YACS::ENGINE::TypeCode,std::less<(std::string)>,std::allocator<(std::pair<(q(const).std::string,p.YACS::ENGINE::TypeCode)>)>)>""")
    containerMap = property(_pilot.Proc_containerMap_get, _pilot.Proc_containerMap_set, doc=r"""containerMap : std::map<(std::string,p.YACS::ENGINE::Container,std::less<(std::string)>,std::allocator<(std::pair<(q(const).std::string,p.YACS::ENGINE::Container)>)>)>""")
    componentInstanceMap = property(_pilot.Proc_componentInstanceMap_get, _pilot.Proc_componentInstanceMap_set, doc=r"""componentInstanceMap : std::map<(std::string,p.YACS::ENGINE::ComponentInstance,std::less<(std::string)>,std::allocator<(std::pair<(q(const).std::string,p.YACS::ENGINE::ComponentInstance)>)>)>""")
    names = property(_pilot.Proc_names_get, _pilot.Proc_names_set, doc=r"""names : std::vector<(std::string,std::allocator<(std::string)>)>""")
    _loggers = property(_pilot.Proc__loggers_get, _pilot.Proc__loggers_set, doc=r"""_loggers : YACS::ENGINE::Proc::LoggerMap""")

    def getEdition(self):
        r"""getEdition(Proc self) -> bool"""
        return _pilot.Proc_getEdition(self)

    def setEdition(self, edition):
        r"""setEdition(Proc self, bool edition)"""
        return _pilot.Proc_setEdition(self, edition)

    def modified(self):
        r"""modified(Proc self)"""
        return _pilot.Proc_modified(self)

    def saveSchema(self, xmlSchemaFile):
        r"""saveSchema(Proc self, std::string const & xmlSchemaFile)"""
        return _pilot.Proc_saveSchema(self, xmlSchemaFile)

    def saveState(self, xmlStateFile):
        r"""saveState(Proc self, std::string const & xmlStateFile)"""
        return _pilot.Proc_saveState(self, xmlStateFile)

# Register Proc in _pilot:
_pilot.Proc_swigregister(Proc)


def NbDoneLoader(node, val):
    r"""NbDoneLoader(Loop node, int val)"""
    return _pilot.NbDoneLoader(node, val)
class InputPort4DF2DS(InputPort):
    r"""Proxy of C++ YACS::ENGINE::InputPort4DF2DS class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, node, type):
        r"""__init__(InputPort4DF2DS self, DFToDSForLoop node, TypeCode type) -> InputPort4DF2DS"""
        _pilot.InputPort4DF2DS_swiginit(self, _pilot.new_InputPort4DF2DS(node, type))

    def getAllRepresentants(self, repr):
        r"""getAllRepresentants(InputPort4DF2DS self, std::set< YACS::ENGINE::InPort *,std::less< YACS::ENGINE::InPort * >,std::allocator< YACS::ENGINE::InPort * > > & repr)"""
        return _pilot.InputPort4DF2DS_getAllRepresentants(self, repr)

    def releaseData(self):
        r"""releaseData(InputPort4DF2DS self)"""
        return _pilot.InputPort4DF2DS_releaseData(self)

    def clone(self, newHelder):
        r"""clone(InputPort4DF2DS self, Node newHelder) -> InputPort"""
        return _pilot.InputPort4DF2DS_clone(self, newHelder)

    def get(self):
        r"""get(InputPort4DF2DS self) -> void *"""
        return _pilot.InputPort4DF2DS_get(self)

    def exRestoreInit(self):
        r"""exRestoreInit(InputPort4DF2DS self)"""
        return _pilot.InputPort4DF2DS_exRestoreInit(self)

    def exSaveInit(self):
        r"""exSaveInit(InputPort4DF2DS self)"""
        return _pilot.InputPort4DF2DS_exSaveInit(self)

    def put(self, *args):
        r"""
        put(InputPort4DF2DS self, void const * data)
        put(InputPort4DF2DS self, Any data)
        """
        return _pilot.InputPort4DF2DS_put(self, *args)
    __swig_destroy__ = _pilot.delete_InputPort4DF2DS

# Register InputPort4DF2DS in _pilot:
_pilot.InputPort4DF2DS_swigregister(InputPort4DF2DS)

class DFToDSForLoop(ElementaryNode):
    r"""Proxy of C++ YACS::ENGINE::DFToDSForLoop class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pilot.delete_DFToDSForLoop

# Register DFToDSForLoop in _pilot:
_pilot.DFToDSForLoop_swigregister(DFToDSForLoop)

class OutputPort4DS2DF(OutputPort):
    r"""Proxy of C++ YACS::ENGINE::OutputPort4DS2DF class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, node, type):
        r"""__init__(OutputPort4DS2DF self, DSToDFForLoop node, TypeCode type) -> OutputPort4DS2DF"""
        _pilot.OutputPort4DS2DF_swiginit(self, _pilot.new_OutputPort4DS2DF(node, type))

    def getAllRepresented(self, represented):
        r"""getAllRepresented(OutputPort4DS2DF self, std::set< YACS::ENGINE::OutPort *,std::less< YACS::ENGINE::OutPort * >,std::allocator< YACS::ENGINE::OutPort * > > & represented)"""
        return _pilot.OutputPort4DS2DF_getAllRepresented(self, represented)

    def clone(self, newHelder):
        r"""clone(OutputPort4DS2DF self, Node newHelder) -> OutputPort"""
        return _pilot.OutputPort4DS2DF_clone(self, newHelder)

    def put(self, *args):
        r"""
        put(OutputPort4DS2DF self, void const * data)
        put(OutputPort4DS2DF self, Any data)
        """
        return _pilot.OutputPort4DS2DF_put(self, *args)
    __swig_destroy__ = _pilot.delete_OutputPort4DS2DF

# Register OutputPort4DS2DF in _pilot:
_pilot.OutputPort4DS2DF_swigregister(OutputPort4DS2DF)

class InputDataStreamPort4DS2DF(InputDataStreamPort):
    r"""Proxy of C++ YACS::ENGINE::InputDataStreamPort4DS2DF class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, node, type):
        r"""__init__(InputDataStreamPort4DS2DF self, DSToDFForLoop node, TypeCode type) -> InputDataStreamPort4DS2DF"""
        _pilot.InputDataStreamPort4DS2DF_swiginit(self, _pilot.new_InputDataStreamPort4DS2DF(node, type))

    def getAllRepresentants(self, repr):
        r"""getAllRepresentants(InputDataStreamPort4DS2DF self, std::set< YACS::ENGINE::InPort *,std::less< YACS::ENGINE::InPort * >,std::allocator< YACS::ENGINE::InPort * > > & repr)"""
        return _pilot.InputDataStreamPort4DS2DF_getAllRepresentants(self, repr)
    __swig_destroy__ = _pilot.delete_InputDataStreamPort4DS2DF

# Register InputDataStreamPort4DS2DF in _pilot:
_pilot.InputDataStreamPort4DS2DF_swigregister(InputDataStreamPort4DS2DF)

class DSToDFForLoop(ElementaryNode):
    r"""Proxy of C++ YACS::ENGINE::DSToDFForLoop class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pilot.delete_DSToDFForLoop

# Register DSToDFForLoop in _pilot:
_pilot.DSToDFForLoop_swigregister(DSToDFForLoop)

class FakeNodeForLoop(ElementaryNode):
    r"""Proxy of C++ YACS::ENGINE::FakeNodeForLoop class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pilot.delete_FakeNodeForLoop

# Register FakeNodeForLoop in _pilot:
_pilot.FakeNodeForLoop_swigregister(FakeNodeForLoop)

class Loop(StaticDefinedComposedNode):
    r"""Proxy of C++ YACS::ENGINE::Loop class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pilot.delete_Loop

    def init(self, start=True):
        r"""init(Loop self, bool start=True)"""
        return _pilot.Loop_init(self, start)

    def getNbOfTurns(self):
        r"""getNbOfTurns(Loop self) -> int"""
        return _pilot.Loop_getNbOfTurns(self)

    def edSetNode(self, DISOWNnode):
        r"""edSetNode(Loop self, Node DISOWNnode) -> Node"""
        return _pilot.Loop_edSetNode(self, DISOWNnode)

    def edAddChild(self, DISOWNnode):
        r"""edAddChild(Loop self, Node DISOWNnode) -> bool"""
        return _pilot.Loop_edAddChild(self, DISOWNnode)

    def isLoop(self):
        r"""isLoop(Loop self) -> bool"""
        return _pilot.Loop_isLoop(self)

    def edRemoveNode(self):
        r"""edRemoveNode(Loop self) -> Node"""
        return _pilot.Loop_edRemoveNode(self)

    def checkBasicConsistency(self):
        r"""checkBasicConsistency(Loop self)"""
        return _pilot.Loop_checkBasicConsistency(self)

    def getDecisionPort(self):
        r"""getDecisionPort(Loop self) -> InputPort"""
        return _pilot.Loop_getDecisionPort(self)

    def getReadyTasks(self, tasks):
        r"""getReadyTasks(Loop self, std::vector< YACS::ENGINE::Task *,std::allocator< YACS::ENGINE::Task * > > & tasks)"""
        return _pilot.Loop_getReadyTasks(self, tasks)

    def edRemoveChild(self, node):
        r"""edRemoveChild(Loop self, Node node)"""
        return _pilot.Loop_edRemoveChild(self, node)

    def isRepeatedUnpredictablySeveralTimes(self):
        r"""isRepeatedUnpredictablySeveralTimes(Loop self) -> bool"""
        return _pilot.Loop_isRepeatedUnpredictablySeveralTimes(self)

    def edGetDirectDescendants(self):
        r"""edGetDirectDescendants(Loop self) -> std::list< YACS::ENGINE::Node *,std::allocator< YACS::ENGINE::Node * > >"""
        return _pilot.Loop_edGetDirectDescendants(self)

    def getSetOfInputPort(self):
        r"""getSetOfInputPort(Loop self) -> std::list< YACS::ENGINE::InputPort *,std::allocator< YACS::ENGINE::InputPort * > >"""
        return _pilot.Loop_getSetOfInputPort(self)

    def getNumberOfInputPorts(self):
        r"""getNumberOfInputPorts(Loop self) -> int"""
        return _pilot.Loop_getNumberOfInputPorts(self)

    def getMaxLevelOfParallelism(self):
        r"""getMaxLevelOfParallelism(Loop self) -> int"""
        return _pilot.Loop_getMaxLevelOfParallelism(self)

    def getWeightRegardingDPL(self, weight):
        r"""getWeightRegardingDPL(Loop self, ComplexWeight weight)"""
        return _pilot.Loop_getWeightRegardingDPL(self, weight)

    def partitionRegardingDPL(self, pd, zeMap):
        r"""partitionRegardingDPL(Loop self, PartDefinition pd, std::map< YACS::ENGINE::ComposedNode *,YACS::BASES::AutoRefCnt< YACS::ENGINE::PartDefinition >,std::less< YACS::ENGINE::ComposedNode * >,std::allocator< std::pair< YACS::ENGINE::ComposedNode *const,YACS::BASES::AutoRefCnt< YACS::ENGINE::PartDefinition > > > > & zeMap)"""
        return _pilot.Loop_partitionRegardingDPL(self, pd, zeMap)

    def getChildByShortName(self, name):
        r"""getChildByShortName(Loop self, std::string const & name) -> Node"""
        return _pilot.Loop_getChildByShortName(self, name)

    @staticmethod
    def MappingDF2DS(type):
        r"""MappingDF2DS(TypeCode type) -> TypeCode"""
        return _pilot.Loop_MappingDF2DS(type)

    @staticmethod
    def MappingDS2DF(type):
        r"""MappingDS2DF(TypeCode type) -> TypeCode"""
        return _pilot.Loop_MappingDS2DF(type)

    def edAddDFLink(self, start, end):
        r"""edAddDFLink(Loop self, OutPort start, InPort end) -> bool"""
        return _pilot.Loop_edAddDFLink(self, start, end)

    def writeDot(self, os):
        r"""writeDot(Loop self, std::ostream & os)"""
        return _pilot.Loop_writeDot(self, os)

    def accept(self, visitor):
        r"""accept(Loop self, Visitor visitor)"""
        return _pilot.Loop_accept(self, visitor)

    def typeName(self):
        r"""typeName(Loop self) -> std::string"""
        return _pilot.Loop_typeName(self)

# Register Loop in _pilot:
_pilot.Loop_swigregister(Loop)

def Loop_MappingDF2DS(type):
    r"""Loop_MappingDF2DS(TypeCode type) -> TypeCode"""
    return _pilot.Loop_MappingDF2DS(type)

def Loop_MappingDS2DF(type):
    r"""Loop_MappingDS2DF(TypeCode type) -> TypeCode"""
    return _pilot.Loop_MappingDS2DF(type)

class ForLoop(Loop):
    r"""Proxy of C++ YACS::ENGINE::ForLoop class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def exUpdateState(self):
        r"""exUpdateState(ForLoop self)"""
        return _pilot.ForLoop_exUpdateState(self)

    def exUpdateProgress(self):
        r"""exUpdateProgress(ForLoop self)"""
        return _pilot.ForLoop_exUpdateProgress(self)

    def init(self, start=True):
        r"""init(ForLoop self, bool start=True)"""
        return _pilot.ForLoop_init(self, start)

    def edGetNbOfTimesInputPort(self):
        r"""edGetNbOfTimesInputPort(ForLoop self) -> InputPort"""
        return _pilot.ForLoop_edGetNbOfTimesInputPort(self)

    def simpleClone(self, father, editionOnly=True):
        r"""simpleClone(ForLoop self, ComposedNode father, bool editionOnly=True) -> Node"""
        return _pilot.ForLoop_simpleClone(self, father, editionOnly)

    def getInputPort(self, name):
        r"""getInputPort(ForLoop self, std::string const & name) -> InputPort"""
        return _pilot.ForLoop_getInputPort(self, name)

    def getOutPort(self, name):
        r"""getOutPort(ForLoop self, std::string const & name) -> OutPort"""
        return _pilot.ForLoop_getOutPort(self, name)

    def getOutputPort(self, name):
        r"""getOutputPort(ForLoop self, std::string const & name) -> OutputPort"""
        return _pilot.ForLoop_getOutputPort(self, name)

    def getLocalInputPorts(self):
        r"""getLocalInputPorts(ForLoop self) -> std::list< YACS::ENGINE::InputPort *,std::allocator< YACS::ENGINE::InputPort * > >"""
        return _pilot.ForLoop_getLocalInputPorts(self)

    def getLocalOutputPorts(self):
        r"""getLocalOutputPorts(ForLoop self) -> std::list< YACS::ENGINE::OutputPort *,std::allocator< YACS::ENGINE::OutputPort * > >"""
        return _pilot.ForLoop_getLocalOutputPorts(self)

    def getSetOfOutputPort(self):
        r"""getSetOfOutputPort(ForLoop self) -> std::list< YACS::ENGINE::OutputPort *,std::allocator< YACS::ENGINE::OutputPort * > >"""
        return _pilot.ForLoop_getSetOfOutputPort(self)

    def accept(self, visitor):
        r"""accept(ForLoop self, Visitor visitor)"""
        return _pilot.ForLoop_accept(self, visitor)

    def getDecisionPort(self):
        r"""getDecisionPort(ForLoop self) -> InputPort"""
        return _pilot.ForLoop_getDecisionPort(self)

    def edGetIndexPort(self):
        r"""edGetIndexPort(ForLoop self) -> OutputPort"""
        return _pilot.ForLoop_edGetIndexPort(self)

    def typeName(self):
        r"""typeName(ForLoop self) -> std::string"""
        return _pilot.ForLoop_typeName(self)

    def getProgress(self):
        r"""getProgress(ForLoop self) -> std::string"""
        return _pilot.ForLoop_getProgress(self)

    def getProgressWeight(self):
        r"""getProgressWeight(ForLoop self) -> std::list< YACS::ENGINE::ProgressWeight,std::allocator< YACS::ENGINE::ProgressWeight > >"""
        return _pilot.ForLoop_getProgressWeight(self)

    def getNbSteps(self):
        r"""getNbSteps(ForLoop self) -> int"""
        return _pilot.ForLoop_getNbSteps(self)
    __swig_destroy__ = _pilot.delete_ForLoop

# Register ForLoop in _pilot:
_pilot.ForLoop_swigregister(ForLoop)

class DynParaLoop(ComposedNode):
    r"""Proxy of C++ YACS::ENGINE::DynParaLoop class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def edRemoveNode(self):
        r"""edRemoveNode(DynParaLoop self) -> Node"""
        return _pilot.DynParaLoop_edRemoveNode(self)

    def edRemoveInitNode(self):
        r"""edRemoveInitNode(DynParaLoop self) -> Node"""
        return _pilot.DynParaLoop_edRemoveInitNode(self)

    def edRemoveFinalizeNode(self):
        r"""edRemoveFinalizeNode(DynParaLoop self) -> Node"""
        return _pilot.DynParaLoop_edRemoveFinalizeNode(self)

    def edSetNode(self, DISOWNnode):
        r"""edSetNode(DynParaLoop self, Node DISOWNnode) -> Node"""
        return _pilot.DynParaLoop_edSetNode(self, DISOWNnode)

    def edSetInitNode(self, DISOWNnode):
        r"""edSetInitNode(DynParaLoop self, Node DISOWNnode) -> Node"""
        return _pilot.DynParaLoop_edSetInitNode(self, DISOWNnode)

    def edSetFinalizeNode(self, DISOWNnode):
        r"""edSetFinalizeNode(DynParaLoop self, Node DISOWNnode) -> Node"""
        return _pilot.DynParaLoop_edSetFinalizeNode(self, DISOWNnode)

    def edAddDFLink(self, start, end):
        r"""edAddDFLink(DynParaLoop self, OutPort start, InPort end) -> bool"""
        return _pilot.DynParaLoop_edAddDFLink(self, start, end)

    def init(self, start=True):
        r"""init(DynParaLoop self, bool start=True)"""
        return _pilot.DynParaLoop_init(self, start)

    def edGetNbOfBranchesPort(self):
        r"""edGetNbOfBranchesPort(DynParaLoop self) -> InputPort"""
        return _pilot.DynParaLoop_edGetNbOfBranchesPort(self)

    def getNumberOfInputPorts(self):
        r"""getNumberOfInputPorts(DynParaLoop self) -> int"""
        return _pilot.DynParaLoop_getNumberOfInputPorts(self)

    def getNumberOfOutputPorts(self):
        r"""getNumberOfOutputPorts(DynParaLoop self) -> int"""
        return _pilot.DynParaLoop_getNumberOfOutputPorts(self)

    def getNumberOfEltsConsumed(self):
        r"""getNumberOfEltsConsumed(DynParaLoop self) -> unsigned int"""
        return _pilot.DynParaLoop_getNumberOfEltsConsumed(self)

    def getBranchIDOfNode(self, node):
        r"""getBranchIDOfNode(DynParaLoop self, Node node) -> int"""
        return _pilot.DynParaLoop_getBranchIDOfNode(self, node)

    def getSetOfOutputPort(self):
        r"""getSetOfOutputPort(DynParaLoop self) -> std::list< YACS::ENGINE::OutputPort *,std::allocator< YACS::ENGINE::OutputPort * > >"""
        return _pilot.DynParaLoop_getSetOfOutputPort(self)

    def getLocalOutputPorts(self):
        r"""getLocalOutputPorts(DynParaLoop self) -> std::list< YACS::ENGINE::OutputPort *,std::allocator< YACS::ENGINE::OutputPort * > >"""
        return _pilot.DynParaLoop_getLocalOutputPorts(self)

    def edGetSamplePort(self):
        r"""edGetSamplePort(DynParaLoop self) -> OutputPort"""
        return _pilot.DynParaLoop_edGetSamplePort(self)

    def getOutPort(self, name):
        r"""getOutPort(DynParaLoop self, std::string const & name) -> OutPort"""
        return _pilot.DynParaLoop_getOutPort(self, name)

    def getInputPort(self, name):
        r"""getInputPort(DynParaLoop self, std::string const & name) -> InputPort"""
        return _pilot.DynParaLoop_getInputPort(self, name)

    def getOutputPort(self, name):
        r"""getOutputPort(DynParaLoop self, std::string const & name) -> OutputPort"""
        return _pilot.DynParaLoop_getOutputPort(self, name)

    def isPlacementPredictableB4Run(self):
        r"""isPlacementPredictableB4Run(DynParaLoop self) -> bool"""
        return _pilot.DynParaLoop_isPlacementPredictableB4Run(self)

    def edRemoveChild(self, node):
        r"""edRemoveChild(DynParaLoop self, Node node)"""
        return _pilot.DynParaLoop_edRemoveChild(self, node)

    def isLoop(self):
        r"""isLoop(DynParaLoop self) -> bool"""
        return _pilot.DynParaLoop_isLoop(self)

    def edAddChild(self, DISOWNnode):
        r"""edAddChild(DynParaLoop self, Node DISOWNnode) -> bool"""
        return _pilot.DynParaLoop_edAddChild(self, DISOWNnode)

    def edGetDirectDescendants(self):
        r"""edGetDirectDescendants(DynParaLoop self) -> std::list< YACS::ENGINE::Node *,std::allocator< YACS::ENGINE::Node * > >"""
        return _pilot.DynParaLoop_edGetDirectDescendants(self)

    def getSetOfInputPort(self):
        r"""getSetOfInputPort(DynParaLoop self) -> std::list< YACS::ENGINE::InputPort *,std::allocator< YACS::ENGINE::InputPort * > >"""
        return _pilot.DynParaLoop_getSetOfInputPort(self)

    def getLocalInputPorts(self):
        r"""getLocalInputPorts(DynParaLoop self) -> std::list< YACS::ENGINE::InputPort *,std::allocator< YACS::ENGINE::InputPort * > >"""
        return _pilot.DynParaLoop_getLocalInputPorts(self)

    def getNumberOfBranchesCreatedDyn(self):
        r"""getNumberOfBranchesCreatedDyn(DynParaLoop self) -> unsigned int"""
        return _pilot.DynParaLoop_getNumberOfBranchesCreatedDyn(self)

    def getChildByShortName(self, name):
        r"""getChildByShortName(DynParaLoop self, std::string const & name) -> Node"""
        return _pilot.DynParaLoop_getChildByShortName(self, name)

    def getChildByNameExec(self, name, id):
        r"""getChildByNameExec(DynParaLoop self, std::string const & name, unsigned int id) -> Node"""
        return _pilot.DynParaLoop_getChildByNameExec(self, name, id)

    def getNodes(self):
        r"""getNodes(DynParaLoop self) -> std::vector< YACS::ENGINE::Node *,std::allocator< YACS::ENGINE::Node * > >"""
        return _pilot.DynParaLoop_getNodes(self)

    def getWeight(self):
        r"""getWeight(DynParaLoop self) -> ComplexWeight"""
        return _pilot.DynParaLoop_getWeight(self)

    def setWeight(self, loopWeight):
        r"""setWeight(DynParaLoop self, double loopWeight)"""
        return _pilot.DynParaLoop_setWeight(self, loopWeight)

    def getWeightRegardingDPL(self, weight):
        r"""getWeightRegardingDPL(DynParaLoop self, ComplexWeight weight)"""
        return _pilot.DynParaLoop_getWeightRegardingDPL(self, weight)

    def isMultiplicitySpecified(self, value):
        r"""isMultiplicitySpecified(DynParaLoop self, unsigned int & value) -> bool"""
        return _pilot.DynParaLoop_isMultiplicitySpecified(self, value)

    def forceMultiplicity(self, value):
        r"""forceMultiplicity(DynParaLoop self, unsigned int value)"""
        return _pilot.DynParaLoop_forceMultiplicity(self, value)

    def checkBasicConsistency(self):
        r"""checkBasicConsistency(DynParaLoop self)"""
        return _pilot.DynParaLoop_checkBasicConsistency(self)

    def getErrorReport(self):
        r"""getErrorReport(DynParaLoop self) -> std::string"""
        return _pilot.DynParaLoop_getErrorReport(self)

    def accept(self, visitor):
        r"""accept(DynParaLoop self, Visitor visitor)"""
        return _pilot.DynParaLoop_accept(self, visitor)

    def getInitNode(self):
        r"""getInitNode(DynParaLoop self) -> Node"""
        return _pilot.DynParaLoop_getInitNode(self)

    def getExecNode(self):
        r"""getExecNode(DynParaLoop self) -> Node"""
        return _pilot.DynParaLoop_getExecNode(self)

    def getFinalizeNode(self):
        r"""getFinalizeNode(DynParaLoop self) -> Node"""
        return _pilot.DynParaLoop_getFinalizeNode(self)

    def getMaxLevelOfParallelism(self):
        r"""getMaxLevelOfParallelism(DynParaLoop self) -> int"""
        return _pilot.DynParaLoop_getMaxLevelOfParallelism(self)

    def partitionRegardingDPL(self, pd, zeMap):
        r"""partitionRegardingDPL(DynParaLoop self, PartDefinition pd, std::map< YACS::ENGINE::ComposedNode *,YACS::BASES::AutoRefCnt< YACS::ENGINE::PartDefinition >,std::less< YACS::ENGINE::ComposedNode * >,std::allocator< std::pair< YACS::ENGINE::ComposedNode *const,YACS::BASES::AutoRefCnt< YACS::ENGINE::PartDefinition > > > > & zeMap)"""
        return _pilot.DynParaLoop_partitionRegardingDPL(self, pd, zeMap)

    def cleanDynGraph(self):
        r"""cleanDynGraph(DynParaLoop self)"""
        return _pilot.DynParaLoop_cleanDynGraph(self)

# Register DynParaLoop in _pilot:
_pilot.DynParaLoop_swigregister(DynParaLoop)

class WhileLoop(Loop):
    r"""Proxy of C++ YACS::ENGINE::WhileLoop class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def exUpdateState(self):
        r"""exUpdateState(WhileLoop self)"""
        return _pilot.WhileLoop_exUpdateState(self)

    def init(self, start=True):
        r"""init(WhileLoop self, bool start=True)"""
        return _pilot.WhileLoop_init(self, start)

    def edGetConditionPort(self):
        r"""edGetConditionPort(WhileLoop self) -> InputPort"""
        return _pilot.WhileLoop_edGetConditionPort(self)

    def getInputPort(self, name):
        r"""getInputPort(WhileLoop self, std::string const & name) -> InputPort"""
        return _pilot.WhileLoop_getInputPort(self, name)

    def getLocalInputPorts(self):
        r"""getLocalInputPorts(WhileLoop self) -> std::list< YACS::ENGINE::InputPort *,std::allocator< YACS::ENGINE::InputPort * > >"""
        return _pilot.WhileLoop_getLocalInputPorts(self)

    def accept(self, visitor):
        r"""accept(WhileLoop self, Visitor visitor)"""
        return _pilot.WhileLoop_accept(self, visitor)

    def getDecisionPort(self):
        r"""getDecisionPort(WhileLoop self) -> InputPort"""
        return _pilot.WhileLoop_getDecisionPort(self)

    def typeName(self):
        r"""typeName(WhileLoop self) -> std::string"""
        return _pilot.WhileLoop_typeName(self)
    __swig_destroy__ = _pilot.delete_WhileLoop

# Register WhileLoop in _pilot:
_pilot.WhileLoop_swigregister(WhileLoop)

class InterceptorInputPort(AnyInputPort):
    r"""Proxy of C++ YACS::ENGINE::InterceptorInputPort class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _pilot.delete_InterceptorInputPort

# Register InterceptorInputPort in _pilot:
_pilot.InterceptorInputPort_swigregister(InterceptorInputPort)

class AnySplitOutputPort(OutputPort):
    r"""Proxy of C++ YACS::ENGINE::AnySplitOutputPort class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _pilot.delete_AnySplitOutputPort

# Register AnySplitOutputPort in _pilot:
_pilot.AnySplitOutputPort_swigregister(AnySplitOutputPort)

class SeqAnyInputPort(AnyInputPort):
    r"""Proxy of C++ YACS::ENGINE::SeqAnyInputPort class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def getNumberOfElements(self):
        r"""getNumberOfElements(SeqAnyInputPort self) -> unsigned int"""
        return _pilot.SeqAnyInputPort_getNumberOfElements(self)

    def dump(self):
        r"""dump(SeqAnyInputPort self) -> std::string"""
        return _pilot.SeqAnyInputPort_dump(self)
    __swig_destroy__ = _pilot.delete_SeqAnyInputPort

# Register SeqAnyInputPort in _pilot:
_pilot.SeqAnyInputPort_swigregister(SeqAnyInputPort)

class SplitterNode(ElementaryNode):
    r"""Proxy of C++ YACS::ENGINE::SplitterNode class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pilot.delete_SplitterNode

# Register SplitterNode in _pilot:
_pilot.SplitterNode_swigregister(SplitterNode)

class FakeNodeForForEachLoop(ElementaryNode):
    r"""Proxy of C++ YACS::ENGINE::FakeNodeForForEachLoop class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pilot.delete_FakeNodeForForEachLoop

# Register FakeNodeForForEachLoop in _pilot:
_pilot.FakeNodeForForEachLoop_swigregister(FakeNodeForForEachLoop)

class ForEachLoopPassedData(object):
    r"""Proxy of C++ YACS::ENGINE::ForEachLoopPassedData class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(ForEachLoopPassedData self, uivec passedIds, std::vector< YACS::ENGINE::SequenceAny *,std::allocator< YACS::ENGINE::SequenceAny * > > const & passedOutputs, strvec nameOfOutputs) -> ForEachLoopPassedData
        __init__(ForEachLoopPassedData self, ForEachLoopPassedData copy) -> ForEachLoopPassedData
        """
        _pilot.ForEachLoopPassedData_swiginit(self, _pilot.new_ForEachLoopPassedData(*args))
    __swig_destroy__ = _pilot.delete_ForEachLoopPassedData

    def init(self):
        r"""init(ForEachLoopPassedData self)"""
        return _pilot.ForEachLoopPassedData_init(self)

    def checkCompatibilyWithNb(self, nbOfElts):
        r"""checkCompatibilyWithNb(ForEachLoopPassedData self, int nbOfElts)"""
        return _pilot.ForEachLoopPassedData_checkCompatibilyWithNb(self, nbOfElts)

    def checkLevel2(self, ports):
        r"""checkLevel2(ForEachLoopPassedData self, std::vector< YACS::ENGINE::AnyInputPort *,std::allocator< YACS::ENGINE::AnyInputPort * > > const & ports)"""
        return _pilot.ForEachLoopPassedData_checkLevel2(self, ports)

    def getNumberOfEltsAlreadyDone(self):
        r"""getNumberOfEltsAlreadyDone(ForEachLoopPassedData self) -> int"""
        return _pilot.ForEachLoopPassedData_getNumberOfEltsAlreadyDone(self)

    def toAbsId(self, localId):
        r"""toAbsId(ForEachLoopPassedData self, int localId) -> int"""
        return _pilot.ForEachLoopPassedData_toAbsId(self, localId)

    def toAbsIdNot(self, localId):
        r"""toAbsIdNot(ForEachLoopPassedData self, int localId) -> int"""
        return _pilot.ForEachLoopPassedData_toAbsIdNot(self, localId)

    def getNumberOfElementsToDo(self):
        r"""getNumberOfElementsToDo(ForEachLoopPassedData self) -> int"""
        return _pilot.ForEachLoopPassedData_getNumberOfElementsToDo(self)

    def assignAlreadyDone(self, execVals):
        r"""assignAlreadyDone(ForEachLoopPassedData self, std::vector< YACS::ENGINE::SequenceAny *,std::allocator< YACS::ENGINE::SequenceAny * > > const & execVals)"""
        return _pilot.ForEachLoopPassedData_assignAlreadyDone(self, execVals)

    def getIds(self):
        r"""getIds(ForEachLoopPassedData self) -> uivec"""
        return _pilot.ForEachLoopPassedData_getIds(self)

    def getOutputs(self):
        r"""getOutputs(ForEachLoopPassedData self) -> std::vector< YACS::ENGINE::SequenceAny *,std::allocator< YACS::ENGINE::SequenceAny * > > const &"""
        return _pilot.ForEachLoopPassedData_getOutputs(self)

    def getOutputNames(self):
        r"""getOutputNames(ForEachLoopPassedData self) -> strvec"""
        return _pilot.ForEachLoopPassedData_getOutputNames(self)

# Register ForEachLoopPassedData in _pilot:
_pilot.ForEachLoopPassedData_swigregister(ForEachLoopPassedData)

class ForEachLoopGen(DynParaLoop):
    r"""Proxy of C++ YACS::ENGINE::ForEachLoopGen class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pilot.delete_ForEachLoopGen

    def init(self, start=True):
        r"""init(ForEachLoopGen self, bool start=True)"""
        return _pilot.ForEachLoopGen_init(self, start)

    def exUpdateState(self):
        r"""exUpdateState(ForEachLoopGen self)"""
        return _pilot.ForEachLoopGen_exUpdateState(self)

    def exUpdateProgress(self):
        r"""exUpdateProgress(ForEachLoopGen self)"""
        return _pilot.ForEachLoopGen_exUpdateProgress(self)

    def getReadyTasks(self, tasks):
        r"""getReadyTasks(ForEachLoopGen self, std::vector< YACS::ENGINE::Task *,std::allocator< YACS::ENGINE::Task * > > & tasks)"""
        return _pilot.ForEachLoopGen_getReadyTasks(self, tasks)

    def getNumberOfInputPorts(self):
        r"""getNumberOfInputPorts(ForEachLoopGen self) -> int"""
        return _pilot.ForEachLoopGen_getNumberOfInputPorts(self)

    def checkNoCyclePassingThrough(self, node):
        r"""checkNoCyclePassingThrough(ForEachLoopGen self, Node node)"""
        return _pilot.ForEachLoopGen_checkNoCyclePassingThrough(self, node)

    def selectRunnableTasks(self, tasks):
        r"""selectRunnableTasks(ForEachLoopGen self, std::vector< YACS::ENGINE::Task *,std::allocator< YACS::ENGINE::Task * > > & tasks)"""
        return _pilot.ForEachLoopGen_selectRunnableTasks(self, tasks)

    def getExecCurrentId(self):
        r"""getExecCurrentId(ForEachLoopGen self) -> unsigned int"""
        return _pilot.ForEachLoopGen_getExecCurrentId(self)

    def getSetOfInputPort(self):
        r"""getSetOfInputPort(ForEachLoopGen self) -> std::list< YACS::ENGINE::InputPort *,std::allocator< YACS::ENGINE::InputPort * > >"""
        return _pilot.ForEachLoopGen_getSetOfInputPort(self)

    def getLocalInputPorts(self):
        r"""getLocalInputPorts(ForEachLoopGen self) -> std::list< YACS::ENGINE::InputPort *,std::allocator< YACS::ENGINE::InputPort * > >"""
        return _pilot.ForEachLoopGen_getLocalInputPorts(self)

    def edGetSeqOfSamplesPort(self):
        r"""edGetSeqOfSamplesPort(ForEachLoopGen self) -> InputPort"""
        return _pilot.ForEachLoopGen_edGetSeqOfSamplesPort(self)

    def getInputPort(self, name):
        r"""getInputPort(ForEachLoopGen self, std::string const & name) -> InputPort"""
        return _pilot.ForEachLoopGen_getInputPort(self, name)

    def getOutPort(self, name):
        r"""getOutPort(ForEachLoopGen self, std::string const & name) -> OutPort"""
        return _pilot.ForEachLoopGen_getOutPort(self, name)

    def getOutputPort(self, name):
        r"""getOutputPort(ForEachLoopGen self, std::string const & name) -> OutputPort"""
        return _pilot.ForEachLoopGen_getOutputPort(self, name)

    def getChildByShortName(self, name):
        r"""getChildByShortName(ForEachLoopGen self, std::string const & name) -> Node"""
        return _pilot.ForEachLoopGen_getChildByShortName(self, name)

    def getLocalOutputPorts(self):
        r"""getLocalOutputPorts(ForEachLoopGen self) -> std::list< YACS::ENGINE::OutputPort *,std::allocator< YACS::ENGINE::OutputPort * > >"""
        return _pilot.ForEachLoopGen_getLocalOutputPorts(self)

    def writeDot(self, os):
        r"""writeDot(ForEachLoopGen self, std::ostream & os)"""
        return _pilot.ForEachLoopGen_writeDot(self, os)

    def typeName(self):
        r"""typeName(ForEachLoopGen self) -> std::string"""
        return _pilot.ForEachLoopGen_typeName(self)

    def resetState(self, level):
        r"""resetState(ForEachLoopGen self, int level)"""
        return _pilot.ForEachLoopGen_resetState(self, level)

    def getProgress(self):
        r"""getProgress(ForEachLoopGen self) -> std::string"""
        return _pilot.ForEachLoopGen_getProgress(self)

    def getProgressWeight(self):
        r"""getProgressWeight(ForEachLoopGen self) -> std::list< YACS::ENGINE::ProgressWeight,std::allocator< YACS::ENGINE::ProgressWeight > >"""
        return _pilot.ForEachLoopGen_getProgressWeight(self)

    def getCurrentIndex(self):
        r"""getCurrentIndex(ForEachLoopGen self) -> int"""
        return _pilot.ForEachLoopGen_getCurrentIndex(self)

    def getNbOfElementsToBeProcessed(self):
        r"""getNbOfElementsToBeProcessed(ForEachLoopGen self) -> int"""
        return _pilot.ForEachLoopGen_getNbOfElementsToBeProcessed(self)

    @staticmethod
    def getFEDeltaBetween(start, end):
        r"""getFEDeltaBetween(OutPort start, InPort end) -> int"""
        return _pilot.ForEachLoopGen_getFEDeltaBetween(start, end)

    def getOutputPortType(self, portName):
        r"""getOutputPortType(ForEachLoopGen self, std::string const & portName) -> TypeCode"""
        return _pilot.ForEachLoopGen_getOutputPortType(self, portName)

    def cleanDynGraph(self):
        r"""cleanDynGraph(ForEachLoopGen self)"""
        return _pilot.ForEachLoopGen_cleanDynGraph(self)

    @staticmethod
    def InterceptorizeNameOfPort(portName):
        r"""InterceptorizeNameOfPort(std::string & portName)"""
        return _pilot.ForEachLoopGen_InterceptorizeNameOfPort(portName)

# Register ForEachLoopGen in _pilot:
_pilot.ForEachLoopGen_swigregister(ForEachLoopGen)
ForEachLoopGen.NAME_OF_SPLITTERNODE = _pilot.cvar.ForEachLoopGen_NAME_OF_SPLITTERNODE

def ForEachLoopGen_getFEDeltaBetween(start, end):
    r"""ForEachLoopGen_getFEDeltaBetween(OutPort start, InPort end) -> int"""
    return _pilot.ForEachLoopGen_getFEDeltaBetween(start, end)

def ForEachLoopGen_InterceptorizeNameOfPort(portName):
    r"""ForEachLoopGen_InterceptorizeNameOfPort(std::string & portName)"""
    return _pilot.ForEachLoopGen_InterceptorizeNameOfPort(portName)
ForEachLoopGen.INTERCEPTOR_STR = _pilot.cvar.ForEachLoopGen_INTERCEPTOR_STR

class ForEachLoop(ForEachLoopGen):
    r"""Proxy of C++ YACS::ENGINE::ForEachLoop class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pilot.delete_ForEachLoop

    def accept(self, visitor):
        r"""accept(ForEachLoop self, Visitor visitor)"""
        return _pilot.ForEachLoop_accept(self, visitor)

    def getPassedResults(self, execut):
        r"""getPassedResults(ForEachLoop self, Executor execut) -> PyObject *"""
        return _pilot.ForEachLoop_getPassedResults(self, execut)

    def assignPassedResults(self, passedIds, passedOutputs, nameOfOutputs):
        r"""assignPassedResults(ForEachLoop self, uivec passedIds, PyObject * passedOutputs, strvec nameOfOutputs)"""
        return _pilot.ForEachLoop_assignPassedResults(self, passedIds, passedOutputs, nameOfOutputs)

# Register ForEachLoop in _pilot:
_pilot.ForEachLoop_swigregister(ForEachLoop)

class ForEachLoopDyn(ForEachLoopGen):
    r"""Proxy of C++ YACS::ENGINE::ForEachLoopDyn class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pilot.delete_ForEachLoopDyn

    def accept(self, visitor):
        r"""accept(ForEachLoopDyn self, Visitor visitor)"""
        return _pilot.ForEachLoopDyn_accept(self, visitor)

# Register ForEachLoopDyn in _pilot:
_pilot.ForEachLoopDyn_swigregister(ForEachLoopDyn)

class FakeNodeForOptimizerLoop(ElementaryNode):
    r"""Proxy of C++ YACS::ENGINE::FakeNodeForOptimizerLoop class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pilot.delete_FakeNodeForOptimizerLoop

# Register FakeNodeForOptimizerLoop in _pilot:
_pilot.FakeNodeForOptimizerLoop_swigregister(FakeNodeForOptimizerLoop)

class OptimizerLoop(DynParaLoop):
    r"""Proxy of C++ YACS::ENGINE::OptimizerLoop class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pilot.delete_OptimizerLoop

    def init(self, start=True):
        r"""init(OptimizerLoop self, bool start=True)"""
        return _pilot.OptimizerLoop_init(self, start)

    def exUpdateState(self):
        r"""exUpdateState(OptimizerLoop self)"""
        return _pilot.OptimizerLoop_exUpdateState(self)

    def getNumberOfInputPorts(self):
        r"""getNumberOfInputPorts(OptimizerLoop self) -> int"""
        return _pilot.OptimizerLoop_getNumberOfInputPorts(self)

    def edGetPortForOutPool(self):
        r"""edGetPortForOutPool(OptimizerLoop self) -> InputPort"""
        return _pilot.OptimizerLoop_edGetPortForOutPool(self)

    def edGetAlgoInitPort(self):
        r"""edGetAlgoInitPort(OptimizerLoop self) -> InputPort"""
        return _pilot.OptimizerLoop_edGetAlgoInitPort(self)

    def edGetAlgoResultPort(self):
        r"""edGetAlgoResultPort(OptimizerLoop self) -> OutputPort"""
        return _pilot.OptimizerLoop_edGetAlgoResultPort(self)

    def getInputPort(self, name):
        r"""getInputPort(OptimizerLoop self, std::string const & name) -> InputPort"""
        return _pilot.OptimizerLoop_getInputPort(self, name)

    def getSetOfInputPort(self):
        r"""getSetOfInputPort(OptimizerLoop self) -> std::list< YACS::ENGINE::InputPort *,std::allocator< YACS::ENGINE::InputPort * > >"""
        return _pilot.OptimizerLoop_getSetOfInputPort(self)

    def getLocalInputPorts(self):
        r"""getLocalInputPorts(OptimizerLoop self) -> std::list< YACS::ENGINE::InputPort *,std::allocator< YACS::ENGINE::InputPort * > >"""
        return _pilot.OptimizerLoop_getLocalInputPorts(self)

    def selectRunnableTasks(self, tasks):
        r"""selectRunnableTasks(OptimizerLoop self, std::vector< YACS::ENGINE::Task *,std::allocator< YACS::ENGINE::Task * > > & tasks)"""
        return _pilot.OptimizerLoop_selectRunnableTasks(self, tasks)

    def getReadyTasks(self, tasks):
        r"""getReadyTasks(OptimizerLoop self, std::vector< YACS::ENGINE::Task *,std::allocator< YACS::ENGINE::Task * > > & tasks)"""
        return _pilot.OptimizerLoop_getReadyTasks(self, tasks)

    def updateStateOnFinishedEventFrom(self, node):
        r"""updateStateOnFinishedEventFrom(OptimizerLoop self, Node node) -> YACS::Event"""
        return _pilot.OptimizerLoop_updateStateOnFinishedEventFrom(self, node)

    def checkNoCyclePassingThrough(self, node):
        r"""checkNoCyclePassingThrough(OptimizerLoop self, Node node)"""
        return _pilot.OptimizerLoop_checkNoCyclePassingThrough(self, node)

    def accept(self, visitor):
        r"""accept(OptimizerLoop self, Visitor visitor)"""
        return _pilot.OptimizerLoop_accept(self, visitor)

    def getSymbol(self):
        r"""getSymbol(OptimizerLoop self) -> std::string"""
        return _pilot.OptimizerLoop_getSymbol(self)

    def getAlgLib(self):
        r"""getAlgLib(OptimizerLoop self) -> std::string"""
        return _pilot.OptimizerLoop_getAlgLib(self)

    def setAlgorithm(self, alglib, symbol, checkLinks=True, procForTypes=None):
        r"""setAlgorithm(OptimizerLoop self, std::string const & alglib, std::string const & symbol, bool checkLinks=True, Proc procForTypes=None)"""
        return _pilot.OptimizerLoop_setAlgorithm(self, alglib, symbol, checkLinks, procForTypes)

    def checkBasicConsistency(self):
        r"""checkBasicConsistency(OptimizerLoop self)"""
        return _pilot.OptimizerLoop_checkBasicConsistency(self)

    def typeName(self):
        r"""typeName(OptimizerLoop self) -> std::string"""
        return _pilot.OptimizerLoop_typeName(self)

    def getNumberOfOutputPorts(self):
        r"""getNumberOfOutputPorts(OptimizerLoop self) -> int"""
        return _pilot.OptimizerLoop_getNumberOfOutputPorts(self)

    def getSetOfOutputPort(self):
        r"""getSetOfOutputPort(OptimizerLoop self) -> std::list< YACS::ENGINE::OutputPort *,std::allocator< YACS::ENGINE::OutputPort * > >"""
        return _pilot.OptimizerLoop_getSetOfOutputPort(self)

    def getLocalOutputPorts(self):
        r"""getLocalOutputPorts(OptimizerLoop self) -> std::list< YACS::ENGINE::OutputPort *,std::allocator< YACS::ENGINE::OutputPort * > >"""
        return _pilot.OptimizerLoop_getLocalOutputPorts(self)

    def getOutPort(self, name):
        r"""getOutPort(OptimizerLoop self, std::string const & name) -> OutPort"""
        return _pilot.OptimizerLoop_getOutPort(self, name)

    def getOutputPort(self, name):
        r"""getOutputPort(OptimizerLoop self, std::string const & name) -> OutputPort"""
        return _pilot.OptimizerLoop_getOutputPort(self, name)

    def finalize(self):
        r"""finalize(OptimizerLoop self) -> YACS::Event"""
        return _pilot.OptimizerLoop_finalize(self)

# Register OptimizerLoop in _pilot:
_pilot.OptimizerLoop_swigregister(OptimizerLoop)

class CollectorSwOutPort(OutPort):
    r"""Proxy of C++ YACS::ENGINE::CollectorSwOutPort class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def getHumanReprOfIncompleteCases(self, stream):
        r"""getHumanReprOfIncompleteCases(CollectorSwOutPort self, std::ostream & stream)"""
        return _pilot.CollectorSwOutPort_getHumanReprOfIncompleteCases(self, stream)
    __swig_destroy__ = _pilot.delete_CollectorSwOutPort

# Register CollectorSwOutPort in _pilot:
_pilot.CollectorSwOutPort_swigregister(CollectorSwOutPort)

class FakeNodeForSwitch(ElementaryNode):
    r"""Proxy of C++ YACS::ENGINE::FakeNodeForSwitch class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pilot.delete_FakeNodeForSwitch

# Register FakeNodeForSwitch in _pilot:
_pilot.FakeNodeForSwitch_swigregister(FakeNodeForSwitch)

class Switch(StaticDefinedComposedNode):
    r"""Proxy of C++ YACS::ENGINE::Switch class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pilot.delete_Switch

    def exUpdateState(self):
        r"""exUpdateState(Switch self)"""
        return _pilot.Switch_exUpdateState(self)

    def init(self, start=True):
        r"""init(Switch self, bool start=True)"""
        return _pilot.Switch_init(self, start)

    def edSetDefaultNode(self, DISOWNnode):
        r"""edSetDefaultNode(Switch self, Node DISOWNnode) -> Node"""
        return _pilot.Switch_edSetDefaultNode(self, DISOWNnode)

    def edReleaseDefaultNode(self):
        r"""edReleaseDefaultNode(Switch self) -> Node"""
        return _pilot.Switch_edReleaseDefaultNode(self)

    def edReleaseCase(self, caseId):
        r"""edReleaseCase(Switch self, int caseId) -> Node"""
        return _pilot.Switch_edReleaseCase(self, caseId)

    def edGetNode(self, caseId):
        r"""edGetNode(Switch self, int caseId) -> Node"""
        return _pilot.Switch_edGetNode(self, caseId)

    def edSetNode(self, caseId, DISOWNnode):
        r"""edSetNode(Switch self, int caseId, Node DISOWNnode) -> Node"""
        return _pilot.Switch_edSetNode(self, caseId, DISOWNnode)

    def edChangeCase(self, oldCase, newCase):
        r"""edChangeCase(Switch self, int oldCase, int newCase)"""
        return _pilot.Switch_edChangeCase(self, oldCase, newCase)

    def edAddChild(self, DISOWNnode):
        r"""edAddChild(Switch self, Node DISOWNnode) -> bool"""
        return _pilot.Switch_edAddChild(self, DISOWNnode)

    def getMaxCase(self):
        r"""getMaxCase(Switch self) -> int"""
        return _pilot.Switch_getMaxCase(self)

    def getReadyTasks(self, tasks):
        r"""getReadyTasks(Switch self, std::vector< YACS::ENGINE::Task *,std::allocator< YACS::ENGINE::Task * > > & tasks)"""
        return _pilot.Switch_getReadyTasks(self, tasks)

    def edGetDirectDescendants(self):
        r"""edGetDirectDescendants(Switch self) -> std::list< YACS::ENGINE::Node *,std::allocator< YACS::ENGINE::Node * > >"""
        return _pilot.Switch_edGetDirectDescendants(self)

    def edGetConditionPort(self):
        r"""edGetConditionPort(Switch self) -> InputPort"""
        return _pilot.Switch_edGetConditionPort(self)

    def writeDot(self, os):
        r"""writeDot(Switch self, std::ostream & os)"""
        return _pilot.Switch_writeDot(self, os)

    def getNumberOfInputPorts(self):
        r"""getNumberOfInputPorts(Switch self) -> int"""
        return _pilot.Switch_getNumberOfInputPorts(self)

    def getMaxLevelOfParallelism(self):
        r"""getMaxLevelOfParallelism(Switch self) -> int"""
        return _pilot.Switch_getMaxLevelOfParallelism(self)

    def getWeightRegardingDPL(self, weight):
        r"""getWeightRegardingDPL(Switch self, ComplexWeight weight)"""
        return _pilot.Switch_getWeightRegardingDPL(self, weight)

    def partitionRegardingDPL(self, pd, zeMap):
        r"""partitionRegardingDPL(Switch self, PartDefinition pd, std::map< YACS::ENGINE::ComposedNode *,YACS::BASES::AutoRefCnt< YACS::ENGINE::PartDefinition >,std::less< YACS::ENGINE::ComposedNode * >,std::allocator< std::pair< YACS::ENGINE::ComposedNode *const,YACS::BASES::AutoRefCnt< YACS::ENGINE::PartDefinition > > > > & zeMap)"""
        return _pilot.Switch_partitionRegardingDPL(self, pd, zeMap)

    def edRemoveChild(self, node):
        r"""edRemoveChild(Switch self, Node node)"""
        return _pilot.Switch_edRemoveChild(self, node)

    def getSetOfInputPort(self):
        r"""getSetOfInputPort(Switch self) -> std::list< YACS::ENGINE::InputPort *,std::allocator< YACS::ENGINE::InputPort * > >"""
        return _pilot.Switch_getSetOfInputPort(self)

    def getLocalInputPorts(self):
        r"""getLocalInputPorts(Switch self) -> std::list< YACS::ENGINE::InputPort *,std::allocator< YACS::ENGINE::InputPort * > >"""
        return _pilot.Switch_getLocalInputPorts(self)

    def getEffectiveState(self, *args):
        r"""
        getEffectiveState(Switch self) -> YACS::StatesForNode
        getEffectiveState(Switch self, Node node) -> YACS::StatesForNode
        """
        return _pilot.Switch_getEffectiveState(self, *args)

    def getOutPort(self, name):
        r"""getOutPort(Switch self, std::string const & name) -> OutPort"""
        return _pilot.Switch_getOutPort(self, name)

    def getInputPort(self, name):
        r"""getInputPort(Switch self, std::string const & name) -> InputPort"""
        return _pilot.Switch_getInputPort(self, name)

    def getChildByShortName(self, name):
        r"""getChildByShortName(Switch self, std::string const & name) -> Node"""
        return _pilot.Switch_getChildByShortName(self, name)

    def getMyQualifiedName(self, directSon):
        r"""getMyQualifiedName(Switch self, Node directSon) -> std::string"""
        return _pilot.Switch_getMyQualifiedName(self, directSon)

    def getCaseId(self, node):
        r"""getCaseId(Switch self, Node node) -> std::string"""
        return _pilot.Switch_getCaseId(self, node)

    def accept(self, visitor):
        r"""accept(Switch self, Visitor visitor)"""
        return _pilot.Switch_accept(self, visitor)

    def getRankOfNode(self, node):
        r"""getRankOfNode(Switch self, Node node) -> int"""
        return _pilot.Switch_getRankOfNode(self, node)

    def typeName(self):
        r"""typeName(Switch self) -> std::string"""
        return _pilot.Switch_typeName(self)

    def getProgressWeight(self):
        r"""getProgressWeight(Switch self) -> std::list< YACS::ENGINE::ProgressWeight,std::allocator< YACS::ENGINE::ProgressWeight > >"""
        return _pilot.Switch_getProgressWeight(self)

# Register Switch in _pilot:
_pilot.Switch_swigregister(Switch)
Switch.DEFAULT_NODE_NAME = _pilot.cvar.Switch_DEFAULT_NODE_NAME
Switch.SELECTOR_INPUTPORT_NAME = _pilot.cvar.Switch_SELECTOR_INPUTPORT_NAME
Switch.ID_FOR_DEFAULT_NODE = _pilot.cvar.Switch_ID_FOR_DEFAULT_NODE

class Visitor(object):
    r"""Proxy of C++ YACS::ENGINE::Visitor class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def visitBloc(self, node):
        r"""visitBloc(Visitor self, Bloc node)"""
        return _pilot.Visitor_visitBloc(self, node)

    def visitElementaryNode(self, node):
        r"""visitElementaryNode(Visitor self, ElementaryNode node)"""
        return _pilot.Visitor_visitElementaryNode(self, node)

    def visitForEachLoop(self, node):
        r"""visitForEachLoop(Visitor self, ForEachLoop node)"""
        return _pilot.Visitor_visitForEachLoop(self, node)

    def visitForEachLoopDyn(self, node):
        r"""visitForEachLoopDyn(Visitor self, ForEachLoopDyn node)"""
        return _pilot.Visitor_visitForEachLoopDyn(self, node)

    def visitOptimizerLoop(self, node):
        r"""visitOptimizerLoop(Visitor self, OptimizerLoop node)"""
        return _pilot.Visitor_visitOptimizerLoop(self, node)

    def visitDynParaLoop(self, node):
        r"""visitDynParaLoop(Visitor self, DynParaLoop node)"""
        return _pilot.Visitor_visitDynParaLoop(self, node)

    def visitForLoop(self, node):
        r"""visitForLoop(Visitor self, ForLoop node)"""
        return _pilot.Visitor_visitForLoop(self, node)

    def visitInlineNode(self, node):
        r"""visitInlineNode(Visitor self, InlineNode node)"""
        return _pilot.Visitor_visitInlineNode(self, node)

    def visitInlineFuncNode(self, node):
        r"""visitInlineFuncNode(Visitor self, InlineFuncNode node)"""
        return _pilot.Visitor_visitInlineFuncNode(self, node)

    def visitLoop(self, node):
        r"""visitLoop(Visitor self, Loop node)"""
        return _pilot.Visitor_visitLoop(self, node)

    def visitProc(self, node):
        r"""visitProc(Visitor self, Proc node)"""
        return _pilot.Visitor_visitProc(self, node)

    def visitServiceNode(self, node):
        r"""visitServiceNode(Visitor self, ServiceNode node)"""
        return _pilot.Visitor_visitServiceNode(self, node)

    def visitServerNode(self, node):
        r"""visitServerNode(Visitor self, ServerNode node)"""
        return _pilot.Visitor_visitServerNode(self, node)

    def visitServiceInlineNode(self, node):
        r"""visitServiceInlineNode(Visitor self, ServiceInlineNode node)"""
        return _pilot.Visitor_visitServiceInlineNode(self, node)

    def visitSwitch(self, node):
        r"""visitSwitch(Visitor self, Switch node)"""
        return _pilot.Visitor_visitSwitch(self, node)

    def visitWhileLoop(self, node):
        r"""visitWhileLoop(Visitor self, WhileLoop node)"""
        return _pilot.Visitor_visitWhileLoop(self, node)

    def visitPresetNode(self, node):
        r"""visitPresetNode(Visitor self, DataNode node)"""
        return _pilot.Visitor_visitPresetNode(self, node)

    def visitOutNode(self, node):
        r"""visitOutNode(Visitor self, DataNode node)"""
        return _pilot.Visitor_visitOutNode(self, node)

    def visitStudyInNode(self, node):
        r"""visitStudyInNode(Visitor self, DataNode node)"""
        return _pilot.Visitor_visitStudyInNode(self, node)

    def visitStudyOutNode(self, node):
        r"""visitStudyOutNode(Visitor self, DataNode node)"""
        return _pilot.Visitor_visitStudyOutNode(self, node)
    __swig_destroy__ = _pilot.delete_Visitor

# Register Visitor in _pilot:
_pilot.Visitor_swigregister(Visitor)

class DataLinkInfo(object):
    r"""Proxy of C++ YACS::ENGINE::DataLinkInfo class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _from = property(_pilot.DataLinkInfo__from_get, _pilot.DataLinkInfo__from_set, doc=r"""_from : p.YACS::ENGINE::Node""")
    to = property(_pilot.DataLinkInfo_to_get, _pilot.DataLinkInfo_to_set, doc=r"""to : p.YACS::ENGINE::Node""")
    outp = property(_pilot.DataLinkInfo_outp_get, _pilot.DataLinkInfo_outp_set, doc=r"""outp : p.YACS::ENGINE::OutputPort""")
    inp = property(_pilot.DataLinkInfo_inp_get, _pilot.DataLinkInfo_inp_set, doc=r"""inp : p.YACS::ENGINE::InPort""")
    toDelete = property(_pilot.DataLinkInfo_toDelete_get, _pilot.DataLinkInfo_toDelete_set, doc=r"""toDelete : bool""")

    def __init__(self):
        r"""__init__(DataLinkInfo self) -> DataLinkInfo"""
        _pilot.DataLinkInfo_swiginit(self, _pilot.new_DataLinkInfo())
    __swig_destroy__ = _pilot.delete_DataLinkInfo

# Register DataLinkInfo in _pilot:
_pilot.DataLinkInfo_swigregister(DataLinkInfo)

class StreamLinkInfo(object):
    r"""Proxy of C++ YACS::ENGINE::StreamLinkInfo class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _from = property(_pilot.StreamLinkInfo__from_get, _pilot.StreamLinkInfo__from_set, doc=r"""_from : p.YACS::ENGINE::Node""")
    to = property(_pilot.StreamLinkInfo_to_get, _pilot.StreamLinkInfo_to_set, doc=r"""to : p.YACS::ENGINE::Node""")
    outp = property(_pilot.StreamLinkInfo_outp_get, _pilot.StreamLinkInfo_outp_set, doc=r"""outp : p.YACS::ENGINE::OutputDataStreamPort""")
    inp = property(_pilot.StreamLinkInfo_inp_get, _pilot.StreamLinkInfo_inp_set, doc=r"""inp : p.YACS::ENGINE::InPort""")
    toDelete = property(_pilot.StreamLinkInfo_toDelete_get, _pilot.StreamLinkInfo_toDelete_set, doc=r"""toDelete : bool""")

    def __init__(self):
        r"""__init__(StreamLinkInfo self) -> StreamLinkInfo"""
        _pilot.StreamLinkInfo_swiginit(self, _pilot.new_StreamLinkInfo())
    __swig_destroy__ = _pilot.delete_StreamLinkInfo

# Register StreamLinkInfo in _pilot:
_pilot.StreamLinkInfo_swigregister(StreamLinkInfo)

class VisitorSaveSchema(Visitor):
    r"""Proxy of C++ YACS::ENGINE::VisitorSaveSchema class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, root):
        r"""__init__(VisitorSaveSchema self, ComposedNode root) -> VisitorSaveSchema"""
        _pilot.VisitorSaveSchema_swiginit(self, _pilot.new_VisitorSaveSchema(root))
    __swig_destroy__ = _pilot.delete_VisitorSaveSchema

    def openFileSchema(self, xmlDump):
        r"""openFileSchema(VisitorSaveSchema self, std::string xmlDump)"""
        return _pilot.VisitorSaveSchema_openFileSchema(self, xmlDump)

    def closeFileSchema(self):
        r"""closeFileSchema(VisitorSaveSchema self)"""
        return _pilot.VisitorSaveSchema_closeFileSchema(self)

    def visitBloc(self, node):
        r"""visitBloc(VisitorSaveSchema self, Bloc node)"""
        return _pilot.VisitorSaveSchema_visitBloc(self, node)

    def visitElementaryNode(self, node):
        r"""visitElementaryNode(VisitorSaveSchema self, ElementaryNode node)"""
        return _pilot.VisitorSaveSchema_visitElementaryNode(self, node)

    def visitForEachLoop(self, node):
        r"""visitForEachLoop(VisitorSaveSchema self, ForEachLoop node)"""
        return _pilot.VisitorSaveSchema_visitForEachLoop(self, node)

    def visitForEachLoopDyn(self, node):
        r"""visitForEachLoopDyn(VisitorSaveSchema self, ForEachLoopDyn node)"""
        return _pilot.VisitorSaveSchema_visitForEachLoopDyn(self, node)

    def visitOptimizerLoop(self, node):
        r"""visitOptimizerLoop(VisitorSaveSchema self, OptimizerLoop node)"""
        return _pilot.VisitorSaveSchema_visitOptimizerLoop(self, node)

    def visitDynParaLoop(self, node):
        r"""visitDynParaLoop(VisitorSaveSchema self, DynParaLoop node)"""
        return _pilot.VisitorSaveSchema_visitDynParaLoop(self, node)

    def visitForLoop(self, node):
        r"""visitForLoop(VisitorSaveSchema self, ForLoop node)"""
        return _pilot.VisitorSaveSchema_visitForLoop(self, node)

    def visitInlineNode(self, node):
        r"""visitInlineNode(VisitorSaveSchema self, InlineNode node)"""
        return _pilot.VisitorSaveSchema_visitInlineNode(self, node)

    def visitInlineFuncNode(self, node):
        r"""visitInlineFuncNode(VisitorSaveSchema self, InlineFuncNode node)"""
        return _pilot.VisitorSaveSchema_visitInlineFuncNode(self, node)

    def visitLoop(self, node):
        r"""visitLoop(VisitorSaveSchema self, Loop node)"""
        return _pilot.VisitorSaveSchema_visitLoop(self, node)

    def visitProc(self, node):
        r"""visitProc(VisitorSaveSchema self, Proc node)"""
        return _pilot.VisitorSaveSchema_visitProc(self, node)

    def visitServiceNode(self, node):
        r"""visitServiceNode(VisitorSaveSchema self, ServiceNode node)"""
        return _pilot.VisitorSaveSchema_visitServiceNode(self, node)

    def visitServerNode(self, node):
        r"""visitServerNode(VisitorSaveSchema self, ServerNode node)"""
        return _pilot.VisitorSaveSchema_visitServerNode(self, node)

    def visitServiceInlineNode(self, node):
        r"""visitServiceInlineNode(VisitorSaveSchema self, ServiceInlineNode node)"""
        return _pilot.VisitorSaveSchema_visitServiceInlineNode(self, node)

    def visitSwitch(self, node):
        r"""visitSwitch(VisitorSaveSchema self, Switch node)"""
        return _pilot.VisitorSaveSchema_visitSwitch(self, node)

    def visitWhileLoop(self, node):
        r"""visitWhileLoop(VisitorSaveSchema self, WhileLoop node)"""
        return _pilot.VisitorSaveSchema_visitWhileLoop(self, node)

    def visitPresetNode(self, node):
        r"""visitPresetNode(VisitorSaveSchema self, DataNode node)"""
        return _pilot.VisitorSaveSchema_visitPresetNode(self, node)

    def visitOutNode(self, node):
        r"""visitOutNode(VisitorSaveSchema self, DataNode node)"""
        return _pilot.VisitorSaveSchema_visitOutNode(self, node)

    def visitStudyInNode(self, node):
        r"""visitStudyInNode(VisitorSaveSchema self, DataNode node)"""
        return _pilot.VisitorSaveSchema_visitStudyInNode(self, node)

    def visitStudyOutNode(self, node):
        r"""visitStudyOutNode(VisitorSaveSchema self, DataNode node)"""
        return _pilot.VisitorSaveSchema_visitStudyOutNode(self, node)

# Register VisitorSaveSchema in _pilot:
_pilot.VisitorSaveSchema_swigregister(VisitorSaveSchema)

class SchemaSave(object):
    r"""Proxy of C++ YACS::ENGINE::SchemaSave class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, proc):
        r"""__init__(SchemaSave self, Proc proc) -> SchemaSave"""
        _pilot.SchemaSave_swiginit(self, _pilot.new_SchemaSave(proc))

    def save(self, xmlSchemaFile):
        r"""save(SchemaSave self, std::string xmlSchemaFile)"""
        return _pilot.SchemaSave_save(self, xmlSchemaFile)
    __swig_destroy__ = _pilot.delete_SchemaSave

# Register SchemaSave in _pilot:
_pilot.SchemaSave_swigregister(SchemaSave)

class ComponentDefinition(object):
    r"""Proxy of C++ YACS::ENGINE::ComponentDefinition class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, name):
        r"""__init__(ComponentDefinition self, std::string const & name) -> ComponentDefinition"""
        _pilot.ComponentDefinition_swiginit(self, _pilot.new_ComponentDefinition(name))

    def getName(self):
        r"""getName(ComponentDefinition self) -> std::string const &"""
        return _pilot.ComponentDefinition_getName(self)
    __swig_destroy__ = _pilot.delete_ComponentDefinition
    _serviceMap = property(_pilot.ComponentDefinition__serviceMap_get, _pilot.ComponentDefinition__serviceMap_set, doc=r"""_serviceMap : std::map<(std::string,p.YACS::ENGINE::ServiceNode,std::less<(std::string)>,std::allocator<(std::pair<(q(const).std::string,p.YACS::ENGINE::ServiceNode)>)>)>""")

# Register ComponentDefinition in _pilot:
_pilot.ComponentDefinition_swigregister(ComponentDefinition)

class Catalog(RefCounter):
    r"""Proxy of C++ YACS::ENGINE::Catalog class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, name):
        r"""__init__(Catalog self, std::string const & name) -> Catalog"""
        _pilot.Catalog_swiginit(self, _pilot.new_Catalog(name))
    __swig_destroy__ = _pilot.delete_Catalog

    def getName(self):
        r"""getName(Catalog self) -> std::string const &"""
        return _pilot.Catalog_getName(self)

    def getErrors(self):
        r"""getErrors(Catalog self) -> std::string"""
        return _pilot.Catalog_getErrors(self)

    def setErrors(self, errors):
        r"""setErrors(Catalog self, std::string const & errors)"""
        return _pilot.Catalog_setErrors(self, errors)
    _typeMap = property(_pilot.Catalog__typeMap_get, _pilot.Catalog__typeMap_set, doc=r"""_typeMap : std::map<(std::string,p.YACS::ENGINE::TypeCode,std::less<(std::string)>,std::allocator<(std::pair<(q(const).std::string,p.YACS::ENGINE::TypeCode)>)>)>""")
    _componentMap = property(_pilot.Catalog__componentMap_get, _pilot.Catalog__componentMap_set, doc=r"""_componentMap : std::map<(std::string,p.YACS::ENGINE::ComponentDefinition,std::less<(std::string)>,std::allocator<(std::pair<(q(const).std::string,p.YACS::ENGINE::ComponentDefinition)>)>)>""")
    _nodeMap = property(_pilot.Catalog__nodeMap_get, _pilot.Catalog__nodeMap_set, doc=r"""_nodeMap : std::map<(std::string,p.YACS::ENGINE::Node,std::less<(std::string)>,std::allocator<(std::pair<(q(const).std::string,p.YACS::ENGINE::Node)>)>)>""")
    _composednodeMap = property(_pilot.Catalog__composednodeMap_get, _pilot.Catalog__composednodeMap_set, doc=r"""_composednodeMap : std::map<(std::string,p.YACS::ENGINE::ComposedNode,std::less<(std::string)>,std::allocator<(std::pair<(q(const).std::string,p.YACS::ENGINE::ComposedNode)>)>)>""")

    def getNodeFromNodeMap(self, name):
        r"""getNodeFromNodeMap(Catalog self, std::string name) -> Node"""
        return _pilot.Catalog_getNodeFromNodeMap(self, name)

# Register Catalog in _pilot:
_pilot.Catalog_swigregister(Catalog)

class CatalogLoader(object):
    r"""Proxy of C++ YACS::ENGINE::CatalogLoader class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _pilot.delete_CatalogLoader

    def newLoader(self, path):
        r"""newLoader(CatalogLoader self, std::string const & path) -> CatalogLoader"""
        return _pilot.CatalogLoader_newLoader(self, path)

    def loadCata(self, cata):
        r"""loadCata(CatalogLoader self, Catalog cata)"""
        return _pilot.CatalogLoader_loadCata(self, cata)

    def load(self, cata, path):
        r"""load(CatalogLoader self, Catalog cata, std::string const & path)"""
        return _pilot.CatalogLoader_load(self, cata, path)

# Register CatalogLoader in _pilot:
_pilot.CatalogLoader_swigregister(CatalogLoader)

class Pool(object):
    r"""Proxy of C++ YACS::ENGINE::Pool class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def getCurrentId(self):
        r"""getCurrentId(Pool self) -> int"""
        return _pilot.Pool_getCurrentId(self)

    def getCurrentInSample(self):
        r"""getCurrentInSample(Pool self) -> Any"""
        return _pilot.Pool_getCurrentInSample(self)

    def getCurrentOutSample(self):
        r"""getCurrentOutSample(Pool self) -> Any"""
        return _pilot.Pool_getCurrentOutSample(self)

    def getOutSample(self, id):
        r"""getOutSample(Pool self, int id) -> Any"""
        return _pilot.Pool_getOutSample(self, id)

    def pushInSample(self, id, inSample, priority=0):
        r"""pushInSample(Pool self, int id, Any inSample, unsigned char priority=0)"""
        return _pilot.Pool_pushInSample(self, id, inSample, priority)

    def destroyAll(self):
        r"""destroyAll(Pool self)"""
        return _pilot.Pool_destroyAll(self)

    def __init__(self):
        r"""__init__(Pool self) -> Pool"""
        _pilot.Pool_swiginit(self, _pilot.new_Pool())
    __swig_destroy__ = _pilot.delete_Pool

# Register Pool in _pilot:
_pilot.Pool_swigregister(Pool)

class AlternateThreadPT(object):
    r"""Proxy of C++ YACS::BASES::AlternateThreadPT class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    UNEXISTING = _pilot.AlternateThreadPT_UNEXISTING
    
    NORMAL_CYCLE = _pilot.AlternateThreadPT_NORMAL_CYCLE
    
    TERMINATION_REQUESTED = _pilot.AlternateThreadPT_TERMINATION_REQUESTED
    
    READY_TO_JOIN = _pilot.AlternateThreadPT_READY_TO_JOIN
    
    __swig_destroy__ = _pilot.delete_AlternateThreadPT

    def start(self):
        r"""start(AlternateThreadPT self)"""
        return _pilot.AlternateThreadPT_start(self)

    def signalSlaveAndWait(self):
        r"""signalSlaveAndWait(AlternateThreadPT self)"""
        return _pilot.AlternateThreadPT_signalSlaveAndWait(self)

    def terminateSlaveThread(self):
        r"""terminateSlaveThread(AlternateThreadPT self)"""
        return _pilot.AlternateThreadPT_terminateSlaveThread(self)

    def signalMasterAndWait(self):
        r"""signalMasterAndWait(AlternateThreadPT self)"""
        return _pilot.AlternateThreadPT_signalMasterAndWait(self)

    def isTerminationRequested(self):
        r"""isTerminationRequested(AlternateThreadPT self) -> bool"""
        return _pilot.AlternateThreadPT_isTerminationRequested(self)

    def getThreadStatus(self):
        r"""getThreadStatus(AlternateThreadPT self) -> YACS::BASES::AlternateThreadPT::ThreadStatus"""
        return _pilot.AlternateThreadPT_getThreadStatus(self)

# Register AlternateThreadPT in _pilot:
_pilot.AlternateThreadPT_swigregister(AlternateThreadPT)

class OptimizerAlgBase(RefCounter):
    r"""Proxy of C++ YACS::ENGINE::OptimizerAlgBase class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getTCForInProxy(self):
        r"""getTCForInProxy(OptimizerAlgBase self) -> TypeCode"""
        return _pilot.OptimizerAlgBase_getTCForInProxy(self)

    def getTCForOutProxy(self):
        r"""getTCForOutProxy(OptimizerAlgBase self) -> TypeCode"""
        return _pilot.OptimizerAlgBase_getTCForOutProxy(self)

    def getTCForAlgoInitProxy(self):
        r"""getTCForAlgoInitProxy(OptimizerAlgBase self) -> TypeCode"""
        return _pilot.OptimizerAlgBase_getTCForAlgoInitProxy(self)

    def getTCForAlgoResultProxy(self):
        r"""getTCForAlgoResultProxy(OptimizerAlgBase self) -> TypeCode"""
        return _pilot.OptimizerAlgBase_getTCForAlgoResultProxy(self)

    def initializeProxy(self, input):
        r"""initializeProxy(OptimizerAlgBase self, Any input)"""
        return _pilot.OptimizerAlgBase_initializeProxy(self, input)

    def startProxy(self):
        r"""startProxy(OptimizerAlgBase self)"""
        return _pilot.OptimizerAlgBase_startProxy(self)

    def takeDecisionProxy(self):
        r"""takeDecisionProxy(OptimizerAlgBase self)"""
        return _pilot.OptimizerAlgBase_takeDecisionProxy(self)

    def finishProxy(self):
        r"""finishProxy(OptimizerAlgBase self)"""
        return _pilot.OptimizerAlgBase_finishProxy(self)

    def getAlgoResultProxy(self):
        r"""getAlgoResultProxy(OptimizerAlgBase self) -> Any"""
        return _pilot.OptimizerAlgBase_getAlgoResultProxy(self)

    def setPool(self, pool):
        r"""setPool(OptimizerAlgBase self, Pool pool)"""
        return _pilot.OptimizerAlgBase_setPool(self, pool)

    def setProc(self, proc):
        r"""setProc(OptimizerAlgBase self, Proc proc)"""
        return _pilot.OptimizerAlgBase_setProc(self, proc)

    def getProc(self):
        r"""getProc(OptimizerAlgBase self) -> Proc"""
        return _pilot.OptimizerAlgBase_getProc(self)

    def hasError(self):
        r"""hasError(OptimizerAlgBase self) -> bool"""
        return _pilot.OptimizerAlgBase_hasError(self)

    def getError(self):
        r"""getError(OptimizerAlgBase self) -> std::string const &"""
        return _pilot.OptimizerAlgBase_getError(self)

    def setError(self, message):
        r"""setError(OptimizerAlgBase self, std::string const & message)"""
        return _pilot.OptimizerAlgBase_setError(self, message)

    def setNbOfBranches(self, nbOfBranches):
        r"""setNbOfBranches(OptimizerAlgBase self, int nbOfBranches)"""
        return _pilot.OptimizerAlgBase_setNbOfBranches(self, nbOfBranches)

    def getNbOfBranches(self):
        r"""getNbOfBranches(OptimizerAlgBase self) -> int"""
        return _pilot.OptimizerAlgBase_getNbOfBranches(self)

# Register OptimizerAlgBase in _pilot:
_pilot.OptimizerAlgBase_swigregister(OptimizerAlgBase)

class vecppdd(object):
    r"""Proxy of C++ std::vector< std::pair< YACS::ENGINE::PartDefinition *,YACS::ENGINE::ComplexWeight * > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(vecppdd self) -> pilot_PySwigIterator"""
        return _pilot.vecppdd_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(vecppdd self) -> bool"""
        return _pilot.vecppdd___nonzero__(self)

    def __bool__(self):
        r"""__bool__(vecppdd self) -> bool"""
        return _pilot.vecppdd___bool__(self)

    def __len__(self):
        r"""__len__(vecppdd self) -> std::vector< std::pair< YACS::ENGINE::PartDefinition *,YACS::ENGINE::ComplexWeight * > >::size_type"""
        return _pilot.vecppdd___len__(self)

    def __getslice__(self, i, j):
        r"""__getslice__(vecppdd self, std::vector< std::pair< YACS::ENGINE::PartDefinition *,YACS::ENGINE::ComplexWeight * > >::difference_type i, std::vector< std::pair< YACS::ENGINE::PartDefinition *,YACS::ENGINE::ComplexWeight * > >::difference_type j) -> vecppdd"""
        return _pilot.vecppdd___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(vecppdd self, std::vector< std::pair< YACS::ENGINE::PartDefinition *,YACS::ENGINE::ComplexWeight * > >::difference_type i, std::vector< std::pair< YACS::ENGINE::PartDefinition *,YACS::ENGINE::ComplexWeight * > >::difference_type j)
        __setslice__(vecppdd self, std::vector< std::pair< YACS::ENGINE::PartDefinition *,YACS::ENGINE::ComplexWeight * > >::difference_type i, std::vector< std::pair< YACS::ENGINE::PartDefinition *,YACS::ENGINE::ComplexWeight * > >::difference_type j, vecppdd v)
        """
        return _pilot.vecppdd___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""__delslice__(vecppdd self, std::vector< std::pair< YACS::ENGINE::PartDefinition *,YACS::ENGINE::ComplexWeight * > >::difference_type i, std::vector< std::pair< YACS::ENGINE::PartDefinition *,YACS::ENGINE::ComplexWeight * > >::difference_type j)"""
        return _pilot.vecppdd___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(vecppdd self, std::vector< std::pair< YACS::ENGINE::PartDefinition *,YACS::ENGINE::ComplexWeight * > >::difference_type i)
        __delitem__(vecppdd self, PySliceObject * slice)
        """
        return _pilot.vecppdd___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(vecppdd self, PySliceObject * slice) -> vecppdd
        __getitem__(vecppdd self, std::vector< std::pair< YACS::ENGINE::PartDefinition *,YACS::ENGINE::ComplexWeight * > >::difference_type i) -> std::vector< std::pair< YACS::ENGINE::PartDefinition *,YACS::ENGINE::ComplexWeight * > >::value_type const &
        """
        return _pilot.vecppdd___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(vecppdd self, PySliceObject * slice, vecppdd v)
        __setitem__(vecppdd self, PySliceObject * slice)
        __setitem__(vecppdd self, std::vector< std::pair< YACS::ENGINE::PartDefinition *,YACS::ENGINE::ComplexWeight * > >::difference_type i, std::vector< std::pair< YACS::ENGINE::PartDefinition *,YACS::ENGINE::ComplexWeight * > >::value_type const & x)
        """
        return _pilot.vecppdd___setitem__(self, *args)

    def pop(self):
        r"""pop(vecppdd self) -> std::vector< std::pair< YACS::ENGINE::PartDefinition *,YACS::ENGINE::ComplexWeight * > >::value_type"""
        return _pilot.vecppdd_pop(self)

    def append(self, x):
        r"""append(vecppdd self, std::vector< std::pair< YACS::ENGINE::PartDefinition *,YACS::ENGINE::ComplexWeight * > >::value_type const & x)"""
        return _pilot.vecppdd_append(self, x)

    def empty(self):
        r"""empty(vecppdd self) -> bool"""
        return _pilot.vecppdd_empty(self)

    def size(self):
        r"""size(vecppdd self) -> std::vector< std::pair< YACS::ENGINE::PartDefinition *,YACS::ENGINE::ComplexWeight * > >::size_type"""
        return _pilot.vecppdd_size(self)

    def swap(self, v):
        r"""swap(vecppdd self, vecppdd v)"""
        return _pilot.vecppdd_swap(self, v)

    def begin(self):
        r"""begin(vecppdd self) -> std::vector< std::pair< YACS::ENGINE::PartDefinition *,YACS::ENGINE::ComplexWeight * > >::iterator"""
        return _pilot.vecppdd_begin(self)

    def end(self):
        r"""end(vecppdd self) -> std::vector< std::pair< YACS::ENGINE::PartDefinition *,YACS::ENGINE::ComplexWeight * > >::iterator"""
        return _pilot.vecppdd_end(self)

    def rbegin(self):
        r"""rbegin(vecppdd self) -> std::vector< std::pair< YACS::ENGINE::PartDefinition *,YACS::ENGINE::ComplexWeight * > >::reverse_iterator"""
        return _pilot.vecppdd_rbegin(self)

    def rend(self):
        r"""rend(vecppdd self) -> std::vector< std::pair< YACS::ENGINE::PartDefinition *,YACS::ENGINE::ComplexWeight * > >::reverse_iterator"""
        return _pilot.vecppdd_rend(self)

    def clear(self):
        r"""clear(vecppdd self)"""
        return _pilot.vecppdd_clear(self)

    def get_allocator(self):
        r"""get_allocator(vecppdd self) -> std::vector< std::pair< YACS::ENGINE::PartDefinition *,YACS::ENGINE::ComplexWeight * > >::allocator_type"""
        return _pilot.vecppdd_get_allocator(self)

    def pop_back(self):
        r"""pop_back(vecppdd self)"""
        return _pilot.vecppdd_pop_back(self)

    def erase(self, *args):
        r"""
        erase(vecppdd self, std::vector< std::pair< YACS::ENGINE::PartDefinition *,YACS::ENGINE::ComplexWeight * > >::iterator pos) -> std::vector< std::pair< YACS::ENGINE::PartDefinition *,YACS::ENGINE::ComplexWeight * > >::iterator
        erase(vecppdd self, std::vector< std::pair< YACS::ENGINE::PartDefinition *,YACS::ENGINE::ComplexWeight * > >::iterator first, std::vector< std::pair< YACS::ENGINE::PartDefinition *,YACS::ENGINE::ComplexWeight * > >::iterator last) -> std::vector< std::pair< YACS::ENGINE::PartDefinition *,YACS::ENGINE::ComplexWeight * > >::iterator
        """
        return _pilot.vecppdd_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(vecppdd self) -> vecppdd
        __init__(vecppdd self, vecppdd other) -> vecppdd
        __init__(vecppdd self, std::vector< std::pair< YACS::ENGINE::PartDefinition *,YACS::ENGINE::ComplexWeight * > >::size_type size) -> vecppdd
        __init__(vecppdd self, std::vector< std::pair< YACS::ENGINE::PartDefinition *,YACS::ENGINE::ComplexWeight * > >::size_type size, std::vector< std::pair< YACS::ENGINE::PartDefinition *,YACS::ENGINE::ComplexWeight * > >::value_type const & value) -> vecppdd
        """
        _pilot.vecppdd_swiginit(self, _pilot.new_vecppdd(*args))

    def push_back(self, x):
        r"""push_back(vecppdd self, std::vector< std::pair< YACS::ENGINE::PartDefinition *,YACS::ENGINE::ComplexWeight * > >::value_type const & x)"""
        return _pilot.vecppdd_push_back(self, x)

    def front(self):
        r"""front(vecppdd self) -> std::vector< std::pair< YACS::ENGINE::PartDefinition *,YACS::ENGINE::ComplexWeight * > >::value_type const &"""
        return _pilot.vecppdd_front(self)

    def back(self):
        r"""back(vecppdd self) -> std::vector< std::pair< YACS::ENGINE::PartDefinition *,YACS::ENGINE::ComplexWeight * > >::value_type const &"""
        return _pilot.vecppdd_back(self)

    def assign(self, n, x):
        r"""assign(vecppdd self, std::vector< std::pair< YACS::ENGINE::PartDefinition *,YACS::ENGINE::ComplexWeight * > >::size_type n, std::vector< std::pair< YACS::ENGINE::PartDefinition *,YACS::ENGINE::ComplexWeight * > >::value_type const & x)"""
        return _pilot.vecppdd_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(vecppdd self, std::vector< std::pair< YACS::ENGINE::PartDefinition *,YACS::ENGINE::ComplexWeight * > >::size_type new_size)
        resize(vecppdd self, std::vector< std::pair< YACS::ENGINE::PartDefinition *,YACS::ENGINE::ComplexWeight * > >::size_type new_size, std::vector< std::pair< YACS::ENGINE::PartDefinition *,YACS::ENGINE::ComplexWeight * > >::value_type const & x)
        """
        return _pilot.vecppdd_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(vecppdd self, std::vector< std::pair< YACS::ENGINE::PartDefinition *,YACS::ENGINE::ComplexWeight * > >::iterator pos, std::vector< std::pair< YACS::ENGINE::PartDefinition *,YACS::ENGINE::ComplexWeight * > >::value_type const & x) -> std::vector< std::pair< YACS::ENGINE::PartDefinition *,YACS::ENGINE::ComplexWeight * > >::iterator
        insert(vecppdd self, std::vector< std::pair< YACS::ENGINE::PartDefinition *,YACS::ENGINE::ComplexWeight * > >::iterator pos, std::vector< std::pair< YACS::ENGINE::PartDefinition *,YACS::ENGINE::ComplexWeight * > >::size_type n, std::vector< std::pair< YACS::ENGINE::PartDefinition *,YACS::ENGINE::ComplexWeight * > >::value_type const & x)
        """
        return _pilot.vecppdd_insert(self, *args)

    def reserve(self, n):
        r"""reserve(vecppdd self, std::vector< std::pair< YACS::ENGINE::PartDefinition *,YACS::ENGINE::ComplexWeight * > >::size_type n)"""
        return _pilot.vecppdd_reserve(self, n)

    def capacity(self):
        r"""capacity(vecppdd self) -> std::vector< std::pair< YACS::ENGINE::PartDefinition *,YACS::ENGINE::ComplexWeight * > >::size_type"""
        return _pilot.vecppdd_capacity(self)
    __swig_destroy__ = _pilot.delete_vecppdd

# Register vecppdd in _pilot:
_pilot.vecppdd_swigregister(vecppdd)

class PlayGround(RefCounter):
    r"""Proxy of C++ YACS::ENGINE::PlayGround class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def loadFromKernelCatalog(self):
        r"""loadFromKernelCatalog(PlayGround self)"""
        return _pilot.PlayGround_loadFromKernelCatalog(self)

    def __init__(self, *args):
        r"""
        __init__(PlayGround self) -> PlayGround
        __init__(PlayGround self, vpsi defOfRes) -> PlayGround
        """
        _pilot.PlayGround_swiginit(self, _pilot.new_PlayGround(*args))

    def printSelf(self):
        r"""printSelf(PlayGround self) -> std::string"""
        return _pilot.PlayGround_printSelf(self)

    def getData(self):
        r"""getData(PlayGround self) -> vpsi"""
        return _pilot.PlayGround_getData(self)

    def setData(self, defOfRes):
        r"""setData(PlayGround self, vpsi defOfRes)"""
        return _pilot.PlayGround_setData(self, defOfRes)

    def getNumberOfCoresAvailable(self):
        r"""getNumberOfCoresAvailable(PlayGround self) -> int"""
        return _pilot.PlayGround_getNumberOfCoresAvailable(self)

    def getMaxNumberOfContainersCanBeHostedWithoutOverlap(self, nbCoresPerCont):
        r"""getMaxNumberOfContainersCanBeHostedWithoutOverlap(PlayGround self, int nbCoresPerCont) -> int"""
        return _pilot.PlayGround_getMaxNumberOfContainersCanBeHostedWithoutOverlap(self, nbCoresPerCont)

    def deduceMachineFrom(self, workerId, nbProcPerNode):
        r"""deduceMachineFrom(PlayGround self, int workerId, int nbProcPerNode) -> std::string"""
        return _pilot.PlayGround_deduceMachineFrom(self, workerId, nbProcPerNode)

    def __str__(self):
        r"""__str__(PlayGround self) -> std::string"""
        return _pilot.PlayGround___str__(self)

    def partition(self, parts, nbCoresPerShot):
        r"""partition(PlayGround self, vecppdd parts, ivec nbCoresPerShot) -> std::vector< YACS::BASES::AutoRefCnt< YACS::ENGINE::PartDefinition >,std::allocator< YACS::BASES::AutoRefCnt< YACS::ENGINE::PartDefinition > > >"""
        return _pilot.PlayGround_partition(self, parts, nbCoresPerShot)

# Register PlayGround in _pilot:
_pilot.PlayGround_swigregister(PlayGround)

class PartDefinition(RefCounter):
    r"""Proxy of C++ YACS::ENGINE::PartDefinition class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def copy(self):
        r"""copy(PartDefinition self) -> PartDefinition"""
        return _pilot.PartDefinition_copy(self)

    def printSelf(self):
        r"""printSelf(PartDefinition self) -> std::string"""
        return _pilot.PartDefinition_printSelf(self)

    def getNumberOfCoresConsumed(self):
        r"""getNumberOfCoresConsumed(PartDefinition self) -> int"""
        return _pilot.PartDefinition_getNumberOfCoresConsumed(self)

# Register PartDefinition in _pilot:
_pilot.PartDefinition_swigregister(PartDefinition)

class ContigPartDefinition(PartDefinition):
    r"""Proxy of C++ YACS::ENGINE::ContigPartDefinition class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, pg, zeStart, zeStop):
        r"""__init__(ContigPartDefinition self, PlayGround pg, int zeStart, int zeStop) -> ContigPartDefinition"""
        _pilot.ContigPartDefinition_swiginit(self, _pilot.new_ContigPartDefinition(pg, zeStart, zeStop))

    def getStart(self):
        r"""getStart(ContigPartDefinition self) -> int"""
        return _pilot.ContigPartDefinition_getStart(self)

    def getStop(self):
        r"""getStop(ContigPartDefinition self) -> int"""
        return _pilot.ContigPartDefinition_getStop(self)

    def __str__(self):
        r"""__str__(ContigPartDefinition self) -> std::string"""
        return _pilot.ContigPartDefinition___str__(self)

# Register ContigPartDefinition in _pilot:
_pilot.ContigPartDefinition_swigregister(ContigPartDefinition)

class NonContigPartDefinition(PartDefinition):
    r"""Proxy of C++ YACS::ENGINE::NonContigPartDefinition class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, pg, ids):
        r"""__init__(NonContigPartDefinition self, PlayGround pg, ivec ids) -> NonContigPartDefinition"""
        _pilot.NonContigPartDefinition_swiginit(self, _pilot.new_NonContigPartDefinition(pg, ids))

    def getIDs(self):
        r"""getIDs(NonContigPartDefinition self) -> ivec"""
        return _pilot.NonContigPartDefinition_getIDs(self)

    def __str__(self):
        r"""__str__(NonContigPartDefinition self) -> std::string"""
        return _pilot.NonContigPartDefinition___str__(self)

# Register NonContigPartDefinition in _pilot:
_pilot.NonContigPartDefinition_swigregister(NonContigPartDefinition)

class AllPartDefinition(PartDefinition):
    r"""Proxy of C++ YACS::ENGINE::AllPartDefinition class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, pg):
        r"""__init__(AllPartDefinition self, PlayGround pg) -> AllPartDefinition"""
        _pilot.AllPartDefinition_swiginit(self, _pilot.new_AllPartDefinition(pg))

    def __str__(self):
        r"""__str__(AllPartDefinition self) -> std::string"""
        return _pilot.AllPartDefinition___str__(self)

# Register AllPartDefinition in _pilot:
_pilot.AllPartDefinition_swigregister(AllPartDefinition)

class ForTestOmlyHPContCls(object):
    r"""Proxy of C++ YACS::ENGINE::ForTestOmlyHPContCls class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def getContainerType(self):
        r"""getContainerType(ForTestOmlyHPContCls self) -> std::string"""
        return _pilot.ForTestOmlyHPContCls_getContainerType(self)

    def getIDS(self):
        r"""getIDS(ForTestOmlyHPContCls self) -> ivec"""
        return _pilot.ForTestOmlyHPContCls_getIDS(self)

    def getPD(self):
        r"""getPD(ForTestOmlyHPContCls self) -> PyObject *"""
        return _pilot.ForTestOmlyHPContCls_getPD(self)

    def __init__(self):
        r"""__init__(ForTestOmlyHPContCls self) -> ForTestOmlyHPContCls"""
        _pilot.ForTestOmlyHPContCls_swiginit(self, _pilot.new_ForTestOmlyHPContCls())
    __swig_destroy__ = _pilot.delete_ForTestOmlyHPContCls

# Register ForTestOmlyHPContCls in _pilot:
_pilot.ForTestOmlyHPContCls_swigregister(ForTestOmlyHPContCls)

class AbstractPoint(object):
    r"""Proxy of C++ YACS::ENGINE::AbstractPoint class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

# Register AbstractPoint in _pilot:
_pilot.AbstractPoint_swigregister(AbstractPoint)

class ElementaryPoint(AbstractPoint):
    r"""Proxy of C++ YACS::ENGINE::ElementaryPoint class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def getFirstNode(self):
        r"""getFirstNode(ElementaryPoint self) -> Node"""
        return _pilot.ElementaryPoint_getFirstNode(self)

# Register ElementaryPoint in _pilot:
_pilot.ElementaryPoint_swigregister(ElementaryPoint)

class BlocPoint(AbstractPoint):
    r"""Proxy of C++ YACS::ENGINE::BlocPoint class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

# Register BlocPoint in _pilot:
_pilot.BlocPoint_swigregister(BlocPoint)

class LinkedBlocPoint(BlocPoint):
    r"""Proxy of C++ YACS::ENGINE::LinkedBlocPoint class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

# Register LinkedBlocPoint in _pilot:
_pilot.LinkedBlocPoint_swigregister(LinkedBlocPoint)

class ForkBlocPoint(BlocPoint):
    r"""Proxy of C++ YACS::ENGINE::ForkBlocPoint class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

# Register ForkBlocPoint in _pilot:
_pilot.ForkBlocPoint_swigregister(ForkBlocPoint)

class NotSimpleCasePoint(BlocPoint):
    r"""Proxy of C++ YACS::ENGINE::NotSimpleCasePoint class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

# Register NotSimpleCasePoint in _pilot:
_pilot.NotSimpleCasePoint_swigregister(NotSimpleCasePoint)

class SetOfPoints(object):
    r"""Proxy of C++ YACS::ENGINE::SetOfPoints class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, nodes):
        r"""__init__(SetOfPoints self, std::list< YACS::ENGINE::Node *,std::allocator< YACS::ENGINE::Node * > > const & nodes) -> SetOfPoints"""
        _pilot.SetOfPoints_swiginit(self, _pilot.new_SetOfPoints(nodes))
    __swig_destroy__ = _pilot.delete_SetOfPoints

    def simplify(self):
        r"""simplify(SetOfPoints self)"""
        return _pilot.SetOfPoints_simplify(self)

    def getRepr(self):
        r"""getRepr(SetOfPoints self) -> std::string"""
        return _pilot.SetOfPoints_getRepr(self)

    def accept(self, pv):
        r"""accept(SetOfPoints self, PyObject * pv)"""
        return _pilot.SetOfPoints_accept(self, pv)

# Register SetOfPoints in _pilot:
_pilot.SetOfPoints_swigregister(SetOfPoints)


def LoadObserversPluginIfAny(rootNode, executor):
    r"""LoadObserversPluginIfAny(ComposedNode rootNode, ExecutorSwig executor)"""
    return _pilot.LoadObserversPluginIfAny(rootNode, executor)

def UnLoadObserversPluginIfAny():
    r"""UnLoadObserversPluginIfAny()"""
    return _pilot.UnLoadObserversPluginIfAny()

def ToBase64Swig(bytes):
    r"""ToBase64Swig(PyObject * bytes) -> PyObject *"""
    return _pilot.ToBase64Swig(bytes)

def FromBase64Swig(base64Str):
    r"""FromBase64Swig(PyObject * base64Str) -> PyObject *"""
    return _pilot.FromBase64Swig(base64Str)



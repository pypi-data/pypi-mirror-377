"""

SASTAdev is a module used for developing SASTA. It takes as input a treebank or a  (corrected) annotation file,
a method (or method filename), and various kinds of reference files.
We originally used the terms *gold* for the reference file, and *platinum* for an improved reference file,
but later changed this to *bronze*  and *silver*, resp.
In the modules and file names the terms gold and platinum have not been replaced everywhere, so both terms  still occur.


All input is supposed to be encoded in UTF8, all output is also generated in UTF8.


Here is the help for this module (python sastadev.py -h)::

    Usage: sastadev.py [options]

    Options:
      -h, --help            show this help message and exit
      -f INFILENAME, --file=INFILENAME
                            Treebank File to be analysed
      -m METHODNAME, --method=METHODNAME
                            Name of the method or (for backwards compatibility)
                            file containing definition of assessment method (SAM)
      -a ANNOTATIONFILENAME, --anno=ANNOTATIONFILENAME
                            SASTA Annotation Format File containing annotations to
                            derive a  reference
      -g GOLDFILENAME, --gold=GOLDFILENAME
                            File containing a gold reference in SASTA Reference
                            Format
      -c GOLDCOUNTSFILENAME, --goldcounts=GOLDCOUNTSFILENAME
                            File containing  gold reference counts in  SASTA
                            Counts Reference Format
      -p PLATINUMINFILENAME, --plat=PLATINUMINFILENAME
                            File containing a platinum reference in SASTA
                            Reference Format
      -i, --impl            Use the implies column of the method
      -l LOGFILENAME, --log=LOGFILENAME
                            File for logging
      --corr=CORR           0=No correction; 1=correction with 1 alternative;
                            n=correction with multiple alternatives (default)
      --mf=METHODFILENAME, --mfile=METHODFILENAME
                            File containing definition of assessment method (SAM)



By using the preferred file and folder structure, the number of parameters to be
specified is minimal.

The preferred file and folder structure is as follows:

 * There is a dataroot where all data reside.  This dataroot can be specified in the configuration module
 * Within the dataroot there is a folder for each dataset (e.g., VKLTARSP for TARSP data provided by VKL)
 * Within each dataset folder the folders are fixed, as follows:

   * Analyses: for storing previous analysis results
   * Analysiscomparison: for reports generated by sastadev on the differences with an earlier analysis
   * Bronze: for bronze reference annotation files
   * Forms: for forms generated by sastadev
   * Indata: for the .cha or .docx input files
   * Intreebanks: for the treebankfiles corresponding to the files in indata
   * Logging: for various logging files generated by sastadev
   * Outtreebanks: for corrected treebanks generated by sastadev
   * Results: for analysis results generated by sastadev
   * Silver: for silver files
   * Silverperm: for the silver annotation store

If the input data are in a standard dataset folder configuration, sastadev can be called by specifying the full path
to the input treebank (using -f) and specifying the method (using -m), e.g.::

    python sastadev.py -f "D:/jodijk/Dropbox/jodijk/Utrecht/Projects/SASTADATA/VKLTarsp/intreebanks/Tarsp_01.xml" -m tarsp

(where 'D:/jodijk/Dropbox/jodijk/Utrecht/Projects/SASTADATA' is the dataroot for user Odijk101)

If the data are not in the standard configuration, one needs to specify one additional parameter to specify the
full path to the bronze reference file. It is assumed that all other input files are in the same folder as the
input treebank, and all output files are generated in that folder.

It generates as output a lot of files. If the input treebank file has the name Tarsp_10.xml, the following files
are generated as output:

* Log file: Tarsp_10.log
* Platinum files:

  * Tarsp_10.platinum-edited.tsv.txt
  * Tarsp_10.platinum.tsv.txt

* Platinum Check files:

  * TSV format: Tarsp_10_platinum.check.tsv.txt
  * XSLX format: Tarsp_10_platinum.check.tsv.xlsx

* Analysis files:

  * TSV format: Tarsp_10_analysis.tsv.txt
  * XLSX format: Tarsp_10_analysis.xlsx

* Grammatical Error related files:

  * Corrected treebank: Tarsp_10_corrected.xml
  * Error Logging: Tarsp_10_errorlogging.xlsx
  * Error Report: Tarsp_10_errorreport.xlsx

* Tarsp_10_countcomparison.tsv.txt
* Form: Tarsp_10_TARSP-Form.xlsx



Sastadev supports the following reference files:

 * for bronze/gold reference files

   * an annotated reference file in Sasta Annotation File (SAF) format (option -a), or
   * a reference file in Sasta Reference File (SRF) format (option -g), or
   * a reference count file in SASTA Reference Count File (RCF) format (option -c)

 * for silver/platinum reference files:

   * a reference file in Sasta  Reference File (SRF) format (option -p)

Sastadev yields as output:

 * an analysis file showing the results and comparing them to the gold and platinum reference if supplied  (in SASTA Development Analysis (SDA) format)
 * a new platinumfile (useful for creating or updating the platinum reference file), in SPR format
 * a platinum check file: list the examples of mismatches between the results and the gold reference
 * a gold counts comparison file (for  each measure the # of the results, the # of the gold reference count, and their difference) (tsv format)

Sastadev logs its actions through:

 * a logfile, and
 * the terminal screen (sys.stderr)

"""

# to do
# -Excel output, cleanup output code

import copy
import datetime
import json
import logging
import os
import re
import sys
import time
from collections import Counter, defaultdict
from optparse import OptionParser
from typing import Any, Callable, Dict, List, Optional, Pattern, Tuple

import xlsxwriter
from lxml import etree

from sastadev import compounds
from sastadev.allresults import (AllResults, mkresultskey, scores2counts,
                                 showreskey)
from sastadev.conf import settings
from sastadev.constants import (analysissuffix, bronzefolder, bronzesuffix,
                                byuttscoressuffix, checksuffix,
                                correctedsuffix, formsfolder,
                                intreebanksfolder, loggingfolder,
                                outtreebanksfolder, resultsfolder,
                                silverfolder, silverpermfolder, silversuffix)
from sastadev.context import getcontextdict
from sastadev.correctionparameters import CorrectionParameters
from sastadev.correcttreebank import (corr0, correcttreebank, corrn,
                                      errorwbheader, validcorroptions)
from sastadev.counterfunctions import counter2liststr
from sastadev.datasets import dsname2ds
from sastadev.external_functions import str2functionmap
from sastadev.filefunctions import get_dataset_samplename, make_filelist
from sastadev.goldcountreader import get_goldcounts
from sastadev.history import (adult_samplecorrections,
                              adult_samplecorrectionsfullname,
                              children_samplecorrections,
                              children_samplecorrectionsfullname, donefiles,
                              donefilesfullname, gathercorrections,
                              mergecorrections, putcorrections,
                              putdonefilenames)
from sastadev.macros import expandmacros
from sastadev.methods import Method, supported_methods, treatmethod
from sastadev.mismatches import exactmismatches, informcol, literalmissedmatches, samplecol, uttidcol
from sastadev.permcomments import (getallcomments, pcheaders,
                                   platinumcheck_column_widths)
from sastadev.query import (Query, is_preorcore, post_process, query_exists,
                            query_inform)
from sastadev.readcsv import writecsv
from sastadev.readmethod import itemseppattern, read_method
from sastadev.reduceresults import exact2results, reduceexactgoldscores
from sastadev.resultsbyutterance import (byuttheader, exactbyuttdict2table,
                                         exactresultsbyuttheader,
                                         getexactbyutt, mkscoresbyuttrows,
                                         silverf1col)
from sastadev.rpf1 import getevalscores, getscores, sumfreq
from sastadev.SAFreader import (get_golddata, richexact2global,
                                richscores2scores)
from sastadev.sample_uttid_tuples import get_samplename_uttids_tuples
from sastadev.sas_impact import mksas_impactrows, sas_impact
from sastadev.sastacore import (SastaCoreParameters, doauchann, dopostqueries,
                                isxpathquery, sastacore)
from sastadev.sastatypes import (AltCodeDict, DataSetName, ExactResultsDict,
                                 FileName, GoldTuple, MatchesDict,
                                 MethodVariant, QId, QIdCount, QueryDict,
                                 ResultsCounter, ResultsKey, SynTree, TreeBank,
                                 UttId)
from sastadev.SRFreader import read_referencefile
from sastadev.targets import get_mustbedone, get_targets, target_all
from sastadev.treebank2trees import treebank2trees
from sastadev.treebankfunctions import (find1, getattval,
                                        getxmetatreepositions, getxsid,
                                        getyield, showtree)
from sastadev.xlsx import add_worksheet, mkworkbook

start_time = time.time()

listDir = False
if listDir:
    print(dir())
    exit(0)


tarsp = 'tarsp'
stap = 'stap'
asta = 'asta'
gramat = 'gramat'

codepath = os.path.dirname(os.path.abspath(__file__))
methodspath = os.path.join(codepath, 'data', 'methods')

# moved to methods.py
# methodspath = os.path.join(codepath, 'methods')

# supported_methods = {}
# supported_methods[tarsp] = os.path.join(methodspath, 'TARSP Index Current.xlsx')
# supported_methods[asta] = os.path.join(methodspath, 'ASTA Index Current.xlsx')
# supported_methods[stap] = os.path.join(methodspath, 'STAP_Index_Current.xlsx')


path2permfolder = silverpermfolder

# target_intarget, target_xsid, target_all = 0, 1, 2
# intargetxpath = '//meta[@name="intarget"]'
# xsidxpath = '//meta[@name="xsid"]'
# intargetvalxpath = './/meta[@name="intarget"]/@value'
# xsidvalxpath = './/meta[@name="xsid"]/@value'

proc = tarsp

logfile = sys.stderr

space = " "
comma = ","
semicolon = ';'
commaspace = ', '
tab = '\t'
pagesep = semicolon
txtext = ".txt"
tsvext = '.tsv'
logext = ".log"
xlsxext = '.xlsx'
samzn = 'samzn'
goldheaderrows = 1
# platinumheaderrows = 1
na = 'na'

getwordsxpath = ".//node[@pt or @pos]"

queryinfoheaderrow = ['id', 'cat', 'subcat', 'item']
queryresultsheaderrow = ['count', 'results',
                         'GoldCount', 'Goldresults', 'queryExists']
queryRGscoreheaderrow = ['recall', 'precision', 'f1score',
                         'intersection', 'gold-results', 'results-gold']
queryRPscoreheaderrow = ['platinum', 'plat_recall', 'plat_precision',
                         'plat_f1score', 'plat-results', 'results-plat']
queryGPscoreheaderrow = ['GP recall', 'GP precision',
                         'GP F1-score', 'GP intersection', 'P minus G', 'G minus P']

resultsheaderrow = queryinfoheaderrow + queryresultsheaderrow + \
    queryRGscoreheaderrow + queryRPscoreheaderrow + queryGPscoreheaderrow
resultsheaderstring = tab.join(resultsheaderrow)
platinumheaderrow = ['id', 'cat', 'subcat', 'item',
                     'uttids', 'results-gold', 'status', 'remarks']
platinumheaderstring = tab.join(platinumheaderrow)

allmatches: MatchesDict = {}
altcodes: AltCodeDict = {}

emptycounter: Counter = Counter()
invalidqueries: Dict[QId, Exception] = {}


def checkplatinum(goldscores: Dict[ResultsKey, Counter], platinumscores: Dict[ResultsKey, Counter],
                  queries: QueryDict) -> None:
    for reskey in goldscores:
        if reskey in platinumscores:
            # all values of gold must be in platinum
            qid = reskey[0]
            if query_exists(queries[qid]):
                diff1 = goldscores[reskey] - platinumscores[reskey]
                if diff1 != Counter():
                    settings.LOGGER.warning(
                        '{} has goldscores not in platinum: {}'.format(str(reskey), diff1))


def mkerrorreport(errordict, errorreportfilename: str):
    header = ['name', 'count', 'uttid', 'value',
              'source', 'cat', 'subcat', 'origutt', 'parsed_as']
    allrows = []
    for item in errordict:
        count = len(errordict[item])
        summaryrow = [item, count]
        allrows.append(summaryrow)
        for instance in errordict[item]:
            instancerow = instance[0:1] + instance[2:]
            fullrow = [item, ''] + instancerow
            allrows.append(fullrow)

    wb = mkworkbook(errorreportfilename, [
        header], allrows, freeze_panes=(1, 1))
    wb.close()


def erow(cnt: int) -> List[str]:
    result = []
    for i in range(cnt):
        result.append('')
    return result


def getpostval(qid, thepostresults):
    if qid in thepostresults:
        result = thepostresults[qid]
    else:
        result = ''
    return result


# def scores2counts(scores):
#    counts = {}
#    for el in scores:
#        countval = len(scores[el])
#        counts[el] = countval
#    return counts

def sf(number):
    if isinstance(number, float) or isinstance(number, int):
        result = '{0:.1f}'.format(number)
    else:
        result = number
    return result


def getmarkedutt(m: SynTree, syntree: SynTree) -> str:
    thewordlist = getyield(syntree)
    thepositions = getwordpositions(m, syntree)
    themarkedyield = getmarkedyield(thewordlist, thepositions)
    yieldstr = space.join(themarkedyield)
    return yieldstr


def mark(str: str) -> str:
    result = '*' + str + '*'
    return result


def getwordpositionsold(matchtree: SynTree, syntree: SynTree) -> List[int]:
    positions1 = []
    for node in matchtree.iter():
        if 'pt' in node.attrib:
            if 'end' in node.attrib:
                positions1.append(node.attrib['end'])

    indexednodes = {}
    for node in syntree.iter():
        if 'index' in node.attrib and ('pt' in node.attrib or 'cat' in node.attrib or 'pos' in node.attrib):
            theindex = node.attrib['index']
            indexednodes[theindex] = node

    thequery2 = ".//node[@index and not(@pt) and not(@cat)]"
    try:
        matches2 = matchtree.xpath(thequery2)
    except etree.XPathEvalError:
        matches2 = []
    positions2 = []
    for m in matches2:
        positions2 += getwordpositions(m, syntree)
    positions = positions1 + positions2
    result = [int(p) for p in positions]
    return result


def getwordpositions(matchtree: SynTree, syntree: SynTree) -> List[int]:
    # nothing special needs to be done for index nodes since they also have begin and end
    positions = []
    for node in matchtree.iter():
        if 'end' in node.attrib:
            positions.append(node.attrib['end'])
    result = [int(p) for p in positions]
    return result


def getmarkedyield(wordlist: List[str], positions: List[int]) -> List[str]:
    pos = 1
    resultlist = []
    for w in wordlist:
        if pos in positions:
            resultlist.append(mark(w))
        else:
            resultlist.append(w)
        pos += 1
    return resultlist


def update(thedict: Dict[str, GoldTuple], qid: str, goldtuple: GoldTuple):
    (level, item, thecounter) = goldtuple
    if qid in thedict:
        (oldlevel, olditem, oldcounter) = thedict[qid]
        thedict[qid] = (oldlevel, olditem, oldcounter + thecounter)
    else:
        thedict[qid] = goldtuple


def logprint(str: str):
    print(str, file=logfile)
    if logfile != sys.stderr:
        print(str, file=sys.stderr)


# @@ types to be reconsidered


def getitem2levelmap(mapping):
    resultmap: Dict[Any, List[Any]] = {}
    for (item, level) in mapping:
        if item in resultmap:
            resultmap[item].append(level)
        else:
            resultmap[item] = [level]
    return resultmap


def getcompounds(syntree: SynTree) -> List[SynTree]:
    results: List[SynTree] = []
    tlist = syntree.xpath(getwordsxpath)
    for t in tlist:
        w = t.attrib['word']
        if compounds.iscompound(w):
            results.append(t)
    return results


def doqueries(syntree: SynTree, queries: QueryDict, exactresults: ExactResultsDict, allmatches: MatchesDict,
              criterion: Callable[[Query], bool]):
    global invalidqueries
    uttid = getxsid(syntree)
    # uttid = getuttidorno(syntree)
    omittedwordpositions = getxmetatreepositions(
        syntree, 'Omitted Word', poslistname='annotatedposlist')
    # print(uttid)
    # core queries
    for queryid in queries:
        if queryid not in exactresults:
            exactresults[queryid] = []
        thequeryobj = queries[queryid]
        if criterion(thequeryobj):
            if query_exists(thequeryobj):
                thelistedquery = thequeryobj.query
                if isxpathquery(thelistedquery):
                    expandedquery = expandmacros(thelistedquery)
                    thequery = "." + expandedquery
                    try:
                        matches = syntree.xpath(thequery)
                    except etree.XPathEvalError as e:
                        invalidqueries[queryid] = e
                        matches = []
                else:
                    thef = str2functionmap[thelistedquery]
                    matches = thef(syntree)
            else:
                matches = []
                exactresults[queryid] = []
            # matchingids = [uttid for x in matches]
            for m in matches:
                # showtree(m)
                if m is None:
                    showtree(syntree, text='in doqueries: Nonematch')
                if (queryid, uttid) in allmatches:
                    allmatches[(queryid, uttid)].append((m, syntree))
                else:
                    allmatches[(queryid, uttid)] = [(m, syntree)]
                exactresult = (uttid, int(getattval(m, 'begin')) + 1)
                exactresults[queryid].append(exactresult)
            # if queryid in results:
            #    results[queryid].update(matchingids)
            # else:
            #    results[queryid] = Counter(matchingids)


def codeadapt(c: str) -> str:
    result = c
    result = re.sub(r'\.', r'\\.', result)
    result = re.sub(r'\(', r'\\(', result)
    result = re.sub(r'\)', r'\\)', result)
    result = re.sub(r'\?', r'\\?', result)
    result = re.sub(r'\*', r'\\*', result)
    result = re.sub(r'\+', r'\\+', result)
    result = re.sub(r' ', r'\\s+', result)
    return result


def mkpatterns(allcodes: List[str]) -> Tuple[Pattern, Pattern]:
    basepattern = r''
    sortedallcodes = sorted(allcodes, key=len, reverse=True)
    adaptedcodes = [codeadapt(c) for c in sortedallcodes]
    basepattern = r'' + '|'.join(adaptedcodes) + '|' + itemseppattern
    fullpattern = r'^(' + basepattern + r')*$'
    return (re.compile(basepattern), re.compile(fullpattern))


def get_definedfornonemptygold(goldscores, queries: QueryDict) -> Tuple[int, List[QId]]:
    undefinedqueries = []
    definedfornonemptygoldscore = 0
    for reskey in goldscores:
        if goldscores[reskey] != emptycounter:
            queryid = reskey[0]
            if queryid in queries:
                if queries[queryid].query != '':
                    definedfornonemptygoldscore += 1
                else:
                    undefinedqueries.append(queryid)
    return (definedfornonemptygoldscore, undefinedqueries)


def get_comparison(resultscounts: QIdCount, goldcounts: QIdCount, queries: QueryDict) -> List[Tuple[QId, int, int]]:
    comparison = []
    for qid in queries:
        if qid in goldcounts:
            gold = goldcounts[qid]
            if qid in resultscounts:
                res = resultscounts[qid]
            else:
                res = 0
        else:
            gold = 0
            if qid in resultscounts:
                res = resultscounts[qid]
            else:
                res = 0
        comparison.append((qid, res, gold))
    return comparison


def getmethodfromfile(filename: str) -> str:
    result = ''
    path, base = os.path.split(filename.lower())
    for m in supported_methods:
        if m in base:
            result = m
    if result == '':
        settings.LOGGER.error('No supported method found in filename')
        exit(-1)
    else:
        return result


def getsortedgolduttscore(reskey: ResultsKey, goldscores) -> str:
    if reskey in goldscores:
        # (goldlevel, golditem, goldcounter) = goldscores[queryid]
        goldcounter = goldscores[reskey]
        goldcount = sumfreq(goldcounter)
        sortedgolduttstr = counter2liststr(goldcounter)
    else:
        goldcount = 0
        sortedgolduttstr = ''
    return sortedgolduttstr


def updatequerycounts(queryid, themethod, invalidqcount, undefinedqcount) -> Tuple[str, int, int]:
    thequery = themethod.queries[queryid]
    if query_exists(thequery):
        if queryid not in invalidqueries:
            qex = 'yes'
        else:
            qex = 'invalid'
            invalidqcount += 1
    else:
        qex = 'no'
        undefinedqcount += 1
    return qex, invalidqcount, undefinedqcount


def oldgetfullscoreandplatinumstr(reskey, themethod, theresults, resultstr, goldscores,
                                  platinuminfilefound, platinumresults, sortedgolduttstr, qex) -> Tuple[str, str]:
    queryid = reskey[0]
    thequery = themethod.queries[queryid]
    if reskey in goldscores:
        goldcounter = goldscores[reskey]
        goldcount = sumfreq(goldcounter)
    else:
        goldcount = 0

    if query_exists(thequery) and queryid not in invalidqueries:
        # print(queryid, file=logfile)
        if reskey in goldscores:
            goldcounter = goldscores[reskey]
        else:
            goldcounter = Counter()
        (recall, precision, f1score) = getscores(theresults, goldcounter)
        liststargoldstr = counter2liststr(theresults & goldcounter)
        goldminustheresults = goldcounter - theresults
        goldminusliststr = counter2liststr(goldminustheresults)
        theresultsminusgold = theresults - goldcounter
        listminusgoldstr = counter2liststr(theresultsminusgold)
        if platinuminfilefound and reskey in platinumresults:
            theplatinumresults = platinumresults[reskey]
            sortedplatinumliststr = counter2liststr(theplatinumresults)
            liststarplatinumstr = counter2liststr(
                theresults & theplatinumresults)
            platinumminusliststr = counter2liststr(
                theplatinumresults - theresults)
            listminusplatinumliststr = counter2liststr(
                theresults - theplatinumresults)
            (platinumrecall, platinumprecision, platinumf1score) = getscores(
                theresults, theplatinumresults)

            goldstarplatinumstr = counter2liststr(
                goldcounter & theplatinumresults)
            platinumminusgoldstr = counter2liststr(
                theplatinumresults - goldcounter)
            goldminusplatinumstr = counter2liststr(
                goldcounter - theplatinumresults)
            (gprecall, gpprecision, gpf1score) = getscores(
                goldcounter, theplatinumresults)
        else:
            sortedplatinumliststr, liststarplatinumliststr, platinumminusliststr, \
                listminusplatinumliststr = '', '', '', ''
            (platinumrecall, platinumprecision, platinumf1score) = (na, na, na)

            goldstarplatinumstr, platinumminusgoldstr, goldminusplatinumstr = '', '', ''
            (gprecall, gpprecision, gpf1score) = (na, na, na)

    else:
        goldcounter = Counter()
        (recall, precision, f1score) = (na, na, na)
        liststargoldstr, goldminusliststr, listminusgoldstr = '', '', ''
        sortedplatinumliststr, liststarplatinumliststr, platinumminusliststr, listminusplatinumliststr = '', '', '', ''
        (platinumrecall, platinumprecision, platinumf1score) = (na, na, na)
        theresultsminusgold = {}
        goldminustheresults = {}
        goldstarplatinumstr, platinumminusgoldstr, goldminusplatinumstr = '', '', ''
        (gprecall, gpprecision, gpf1score) = (na, na, na)

    platinumoutresults = theresults | goldcounter
    platinumoutresultsstring = counter2liststr(platinumoutresults)
    reskeystr = showreskey(reskey)

    queryinforow = [reskeystr, themethod.queries[queryid].cat, themethod.queries[queryid].subcat,
                    themethod.queries[queryid].item]
    queryresultsrow = [str(sumfreq(theresults)), resultstr,
                       str(goldcount), sortedgolduttstr, qex]
    queryRGscorerow = [sf(recall), sf(precision), sf(
        f1score), liststargoldstr, goldminusliststr, listminusgoldstr]
    queryRPscorerow = [sortedplatinumliststr, sf(platinumrecall), sf(platinumprecision), sf(platinumf1score),
                       platinumminusliststr, listminusplatinumliststr]
    queryGPscorerow = [sf(gprecall), sf(gpprecision), sf(gpf1score), goldstarplatinumstr, platinumminusgoldstr,
                       goldminusplatinumstr]

    fullresultrow = queryinforow + queryresultsrow + \
        queryRGscorerow + queryRPscorerow + queryGPscorerow

    platinumrow = [reskeystr, themethod.queries[queryid].cat, themethod.queries[queryid].subcat,
                   themethod.queries[queryid].item, platinumoutresultsstring, listminusgoldstr, '', '']

    return fullresultrow, platinumrow


def getfullscoreandplatinumstr(reskey, themethod, theresults, resultstr, goldscores,
                               platinuminfilefound, platinumresults, sortedgolduttstr, qex) -> Tuple[str, str]:
    queryid = reskey[0]
    thequery = themethod.queries[queryid]
    if reskey in goldscores:
        goldcounter = goldscores[reskey]
        goldcount = sumfreq(goldcounter)
    else:
        goldcount = 0

    if query_exists(thequery) and queryid not in invalidqueries:
        # print(queryid, file=logfile)
        if reskey in goldscores:
            goldcounter = goldscores[reskey]
        else:
            goldcounter = Counter()
        (recall, precision, f1score) = getscores(theresults, goldcounter)
        liststargoldstr = counter2liststr(theresults & goldcounter)
        goldminustheresults = goldcounter - theresults
        goldminusliststr = counter2liststr(goldminustheresults)
        theresultsminusgold = theresults - goldcounter
        listminusgoldstr = counter2liststr(theresultsminusgold)
        if platinuminfilefound and reskey in platinumresults:
            theplatinumresults = platinumresults[reskey]
            sortedplatinumliststr = counter2liststr(theplatinumresults)
            liststarplatinumstr = counter2liststr(
                theresults & theplatinumresults)
            platinumminusliststr = counter2liststr(
                theplatinumresults - theresults)
            listminusplatinumliststr = counter2liststr(
                theresults - theplatinumresults)
            (platinumrecall, platinumprecision, platinumf1score) = getscores(
                theresults, theplatinumresults)

            goldstarplatinumstr = counter2liststr(
                goldcounter & theplatinumresults)
            platinumminusgoldstr = counter2liststr(
                theplatinumresults - goldcounter)
            goldminusplatinumstr = counter2liststr(
                goldcounter - theplatinumresults)
            (gprecall, gpprecision, gpf1score) = getscores(
                goldcounter, theplatinumresults)
        else:
            sortedplatinumliststr, liststarplatinumliststr, platinumminusliststr, \
                listminusplatinumliststr = '', '', '', ''
            (platinumrecall, platinumprecision, platinumf1score) = (na, na, na)

            goldstarplatinumstr, platinumminusgoldstr, goldminusplatinumstr = '', '', ''
            (gprecall, gpprecision, gpf1score) = (na, na, na)

    else:
        goldcounter = Counter()
        (recall, precision, f1score) = (na, na, na)
        liststargoldstr, goldminusliststr, listminusgoldstr = '', '', ''
        sortedplatinumliststr, liststarplatinumliststr, platinumminusliststr, listminusplatinumliststr = '', '', '', ''
        (platinumrecall, platinumprecision, platinumf1score) = (na, na, na)
        theresultsminusgold = {}
        goldminustheresults = {}
        goldstarplatinumstr, platinumminusgoldstr, goldminusplatinumstr = '', '', ''
        (gprecall, gpprecision, gpf1score) = (na, na, na)

    platinumoutresults = theresults | goldcounter
    platinumoutresultsstring = counter2liststr(platinumoutresults)
    reskeystr = showreskey(reskey)

    queryinforow = [reskeystr, themethod.queries[queryid].cat, themethod.queries[queryid].subcat,
                    themethod.queries[queryid].item]
    queryresultsrow = [str(sumfreq(theresults)), resultstr,
                       str(goldcount), sortedgolduttstr, qex]
    queryRGscorerow = [sf(recall), sf(precision), sf(
        f1score), liststargoldstr, goldminusliststr, listminusgoldstr]
    queryRPscorerow = [sortedplatinumliststr, sf(platinumrecall), sf(platinumprecision), sf(platinumf1score),
                       platinumminusliststr, listminusplatinumliststr]
    queryGPscorerow = [sf(gprecall), sf(gpprecision), sf(gpf1score), goldstarplatinumstr, platinumminusgoldstr,
                       goldminusplatinumstr]

    fullresultrow = queryinforow + queryresultsrow + \
        queryRGscorerow + queryRPscorerow + queryGPscorerow

    platinumrow = [reskeystr, themethod.queries[queryid].cat, themethod.queries[queryid].subcat,
                   themethod.queries[queryid].item, platinumoutresultsstring, listminusgoldstr, '', '']

    return fullresultrow, platinumrow


topnodequery = './/node[@cat="top"]'


def getexactresults(allmatches: MatchesDict) -> ExactResultsDict:
    result: ExactResultsDict = defaultdict(list)
    for (queryid, uttid) in allmatches:
        matchresults = []
        wholeuttmatch = False
        for (m, _) in allmatches[(queryid, uttid)]:
            # @@hier de topnode opzoeken@@
            if m is None:
                position = 0
                settings.LOGGER.error('None match found')
            else:
                topnodes = m.xpath(topnodequery)
                if topnodes != []:
                    positionstr = getattval(topnodes[0], 'begin')
                    wholeuttmatch = True
                else:
                    positionstr = getattval(m, 'begin')
                    wholeuttmatch = getattval(m, 'cat') == 'top'
                try:
                    position = int(positionstr)
                except ValueError:
                    position = 0
                    settings.LOGGER.error('getexactresults ValueError')
                else:
                    if not wholeuttmatch:
                        position += 1
            matchresults.append((uttid, position))
        result[queryid] += matchresults
    return result


def passfilter(rawexactresults: ExactResultsDict, method: Method) -> ExactResultsDict:
    """
    let only those through that satisfy the filter
    :param rawexactresults: dictionary with queryid as key and a Counter as value, exact results
    :param method: Method object
    :return: a filtered version of rawexactresults: results that pass the filter
    """
    exactresults: ExactResultsDict = defaultdict(list)
    queries = method.queries
    for queryid in rawexactresults:
        query = queries[queryid]
        queryfilter = query.filter
        thefilter = method.defaultfilter if queryfilter is None or queryfilter == '' else str2functionmap[
            queryfilter]
        exactresults[queryid] = [r for r in rawexactresults[queryid]
                                 if thefilter(query, rawexactresults, r)]
    return exactresults


# defaulttarsp = r"TARSP Index Current.xlsx"
defaulttarsp = supported_methods[tarsp]


def addxsid(xsid, stree: SynTree) -> SynTree:
    outstree = copy.deepcopy(stree)
    xsidmeta = etree.Element('meta', {'name': 'xsid', 'type': 'text', 'value': xsid})
    metadata = find1(outstree, './/metadata')
    if metadata is not None:
        metadata.append(xsidmeta)
    return outstree


def getmax_xsid(treebank: TreeBank) -> int:
    xsids = treebank.xpath('.//meta[@name="xsid"]/@value')
    intxsids = [int(xsid) for xsid in xsids]
    max_xsid = max(intxsids) if intxsids != [] else 0
    return max_xsid


def tb_addxsid(treebank: TreeBank, targets) -> TreeBank:
    newtreebank = etree.Element('treebank')
    max_xsid = getmax_xsid(treebank)
    newxsidcounter = max_xsid + 1
    for syntree in treebank:
        mustbedone = get_mustbedone(syntree, targets)
        if mustbedone:
            uttid = getxsid(syntree)
            if uttid == '0':
                newxsidcounter += 1
                uttid = str(newxsidcounter)
                # showtree(syntree, '===========before adding xsid')
                newsyntree = addxsid(uttid, syntree)
                # showtree(syntree, '===========after adding xsid')
            else:
                newsyntree = copy.deepcopy(syntree)
        else:
            newsyntree = copy.deepcopy(syntree)
        newtreebank.append(newsyntree)
    return newtreebank

def getdatasetname(fn: FileName) -> DataSetName:
    r"""
    gets the dataset name that the file belongs to
    :param fn: has the form r"D:\Dropbox\jodijk\Utrecht\Projects\SASTADATA\VKLTarsp\intreebanks\TARSP_08.xml"
    :return: the name of the folder that is the dataset (VKLTarsp for the input example)
    """

    head1, tail1 = os.path.split(fn)
    head2, tail2 = os.path.split(head1)
    head3, tail3 = os.path.split(head2)
    return tail3

def getvariant(infilename:FileName, optionsvariant: Optional[str]) -> Optional[MethodVariant]:
    if optionsvariant is not None:
        return optionsvariant
    ds = getdatasetname(infilename)
    dslc = ds.lower()
    if dslc in dsname2ds:
        result = dsname2ds[dslc].variant
    else:
        result = None
    return result



def main():
    parser = OptionParser()
    parser.add_option("-f", "--file", dest="infilename",
                      help="Treebank File to be analysed")
    parser.add_option("-m", "--method", dest="methodname",
                      help="Name of the method or (for backwards compatibility) "
                           "file containing definition of assessment method (SAM)")
    parser.add_option("-v", "--variant", dest="variant",
                      help="Name of the variant of the method ")
    parser.add_option("-a", "--anno", dest="annotationfilename",
                      help="SASTA Annotation Format File containing annotations to derive a  reference")
    parser.add_option("-g", "--gold", dest="goldfilename",
                      help="File containing a gold reference in SASTA Reference Format")
    parser.add_option("-c", "--goldcounts", dest="goldcountsfilename",
                      help="File containing  gold reference counts in  SASTA Counts Reference Format")
    parser.add_option("-p", "--plat", dest="platinuminfilename",
                      help="File containing a platinum reference in SASTA Reference Format")
    parser.add_option("-i", "--impl", dest="includeimplies", action="store_true",
                      help="Use the implies column of the method (deprecated)", default=True)
    parser.add_option("-l", "--log", dest="logfilename",
                      help="File for logging")
    parser.add_option("--corr", dest="corr", default='n',
                      help="0=No correction; 1=correction with 1 alternative; "
                           "n=correction with multiple alternatives (default) ")
    parser.add_option("--mf", "--mfile", dest="methodfilename",
                      help="File containing definition of assessment method (SAM)")
    parser.add_option("--no_spell",  dest="dospellingcorrection", action="store_false",
                      help="Do no spelling correction")
    parser.add_option("--no_auchann", dest="doauchann", action="store_false",
                      help="Do no Automatic CHAT annotation (AuCHAnn)")
    parser.add_option("--no_history", dest="dohistory", action="store_false",
                      help="Do no History Creation")
    parser.add_option("--no_history_extension", dest="extendhistory", action="store_false",
                      help="Use History but do not extend it")



    (options, args) = parser.parse_args()

    # parameter is deprecated, now always assumed to be true
    options.includeimplies = True

    if options.corr is None:
        options.corr = corrn
    if options.corr not in validcorroptions:
        validcorrstr = comma.join(validcorroptions)
        settings.LOGGER.error(
            'Illegal value for -c/--corr option: only the following are allowed: {}'.format(validcorrstr))
        exit(1)

    # @ hier ook toestaan dat er een annotatiefile als input komt (.xlsx)-done
    if options.infilename is None:  # an XML file or an.xlsx file
        settings.LOGGER.error(
            'Specify an input treebank file name to analyse (.xml) or the name of an annotationfile (.xlsx)')
        exit(1)
    elif not os.path.exists(options.infilename):
        settings.LOGGER.error(
            'File {} not found. Aborting'.format(options.infilename))
        exit(1)

    if options.dospellingcorrection is None:
        options.dospellingcorrection = True

    if options.doauchann is None:
        options.doauchann = True

    if options.dohistory is None:
        options.dohistory = True

    if options.extendhistory is None:
        options.extendhistory = True


    (inbase, inext) = os.path.splitext(options.infilename)
    basepath, basefilename = os.path.split(options.infilename)
    corepath, lastfolder = os.path.split(basepath)
    corefilename, inext = os.path.splitext(basefilename)
    sample = corefilename
    datasetpath, _ = os.path.split(basepath)
    path2dataset, dataset = os.path.split(datasetpath)
    analysespath = os.path.join(corepath, 'analyses')
    bronzepath = os.path.join(corepath, bronzefolder)
    silverpath = os.path.join(corepath, silverfolder)
    resultspath = os.path.join(corepath, resultsfolder)
    silverpermpath = os.path.join(corepath, silverpermfolder)
    loggingpath = os.path.join(corepath, loggingfolder)
    formspath = os.path.join(corepath, formsfolder)

    if lastfolder == intreebanksfolder:
        intreebankinput = True
        outtreebankspath = os.path.join(corepath, outtreebanksfolder)

        outpaths = [analysespath, outtreebankspath, resultspath,
                    silverpermpath, loggingpath, formspath, silverpath]

        for outpath in outpaths:
            try:
                os.makedirs(outpath)
            except FileExistsError:
                pass
    else:
        intreebankinput = False
        analysespath = bronzepath = outtreebankspath = resultspath = loggingpath = formspath = basepath
        silverpermpath = os.path.join(basepath, path2permfolder)

    if inext not in ['.xml', '.xlsx']:
        settings.LOGGER.error(
            'Illegal input file type: must be a treebank (.xml) or an annotationfile (.xlsx)')
        exit(1)
    elif inext in ['.xlsx']:
        annotationinput = True
    else:
        annotationinput = False

    if options.logfilename is None:
        options.logfilename = os.path.join(loggingpath, corefilename + logext)

    options.methodname, options.methodfilename = treatmethod(
        options.methodname, options.methodfilename)

    # Configure logging
    handler = logging.FileHandler(options.logfilename, 'w', encoding='utf8')
    logformat = '%(filename)s:%(funcName)s:%(levelname)s:%(message)s'
    formatter = logging.Formatter(logformat)
    handler.setFormatter(formatter)
    root_logger = settings.LOGGER
    root_logger.addHandler(handler)
    root_logger.setLevel(logging.INFO)
    settings.LOGGER.info('Start of logging')

    if options.annotationfilename is not None and options.goldcountsfilename is not None:
        settings.LOGGER.info(
            'Annotation file and Gold counts file found; gold counts file ignored')
    elif options.goldfilename is not None and options.goldcountsfilename is not None:
        settings.LOGGER.info(
            'Gold Reference file and Gold counts file found; gold counts file ignored')

    # this is not needed anymore because of treatmethod
    # if options.methodfilename is None:  # an xslx file
    #    options.methodfilename = defaulttarsp
    if options.annotationfilename is None:  # an xlsx file
        options.annotationfilename = os.path.join(
            bronzepath, corefilename + bronzesuffix + xlsxext)
    if options.platinuminfilename is None:
        # old: remove in due time
        # if intreebankinput:
        #     options.platinuminfilename = os.path.join(silverpath, corefilename + platinumeditedsuffix + txtext)
        # else:
        #     options.platinuminfilename = inbase + platinumeditedsuffix + txtext
        silverpath = os.path.join(corepath, silverfolder)
        options.platinuminfilename = os.path.join(
            silverpath, corefilename + silversuffix + xlsxext)

    if options.goldfilename is not None and options.annotationfilename is not None:
        settings.LOGGER.info(
            'annotationfile and goldfile specified. Annotationfile will be used.')

    if options.goldfilename is None:
        if intreebankinput:
            options.goldfilename = os.path.join(
                bronzepath, corefilename + ".gold" + ".tsv" + ".txt")
        else:
            options.goldfilename = inbase + ".gold" + ".tsv" + ".txt"
    if options.goldcountsfilename is None:
        if intreebankinput:
            options.goldcountsfilename = os.path.join(
                bronzepath, corefilename + ".goldcounts" + xlsxext)
        else:
            options.goldcountsfilename = inbase + ".goldcounts" + xlsxext

    # determine the method variant to be used
    variant = getvariant(options.infilename, options.variant)

    # adapted this so that the method is read in directly as a Method object
    # (queries, item2idmap, altcodes, postorformquerylist) = read_method(options.methodname, options.methodfilename)
    # defaultfilter = defaultfilters[options.methodname]
    # themethod = Method(options.methodname, queries, item2idmap, altcodes, postorformquerylist,
    #                   options.methodfilename, defaultfilter)
    themethod = read_method(options.methodname, options.methodfilename, variant=variant)

    # print('annotationfilename=', options.annotationfilename, file=sys.stderr )

    # read the annotation reference file if available, otherwise the gold file, otherwise quit
    goldscores = {}
    if options.annotationfilename != '' and os.path.exists(options.annotationfilename):
        allannutts, richexactgoldscores = get_golddata(
            options.annotationfilename, themethod, options.includeimplies)
        annuttcount = len(allannutts)
        exactgoldscores = richscores2scores(richexactgoldscores)
        richgoldscores = richexact2global(richexactgoldscores)
        goldscores = richscores2scores(richgoldscores)
        goldcounts = scores2counts(goldscores)
        goldcountfilename = options.annotationfilename + ".goldcount.tsv.txt"
        goldcountfile = open(goldcountfilename, 'w', encoding='utf8')
        for el in goldcounts:
            print(el, goldcounts[el], sep=tab, file=goldcountfile)
        goldcountfile.close()
        reffilename = options.annotationfilename
        errordict = {}
    elif options.goldfilename != '' and os.path.exists(options.goldfilename):
        goldscores = read_referencefile(options.goldfilename, logfile)
        goldcounts = scores2counts(goldscores)
        reffilename = options.goldfilename
    elif options.goldcountsfilename != '' and os.path.exists(options.goldcountsfilename):
        goldcounts = get_goldcounts(options.goldcountsfilename)
        if goldcounts == {}:
            settings.LOGGER.error('No gold counts found. Aborting')
            exit(-1)
        else:
            reffilename = options.goldcountsfilename
    else:
        settings.LOGGER.error(
            'Neither an annotationfile nor a goldfile, nor a gold count file specified. Aborting')
        exit(1)

    # read in the silver references if available otherwise equalt o the boronze data
    if options.platinuminfilename != '' and os.path.exists(options.platinuminfilename):
        silverallannutts, richexactsilverscores = get_golddata(options.platinuminfilename, themethod,
                                                               options.includeimplies)
        silverannuttcount = len(silverallannutts)
        exactsilverscores = richscores2scores(richexactsilverscores)
        richsilverscores = richexact2global(richexactsilverscores)
        silverscores = richscores2scores(richsilverscores)
        silverreffilename = options.platinuminfilename
    else:
        # no separate silver file so we set it equal to the results of the bronze reference file
        settings.LOGGER.info(
            'No silver reference; set equal to the bronze reference')
        silverallannutts, richexactsilverscores = allannutts, richexactgoldscores
        silverannuttcount = len(silverallannutts)
        exactsilverscores = exactgoldscores
        richsilverscores = richgoldscores
        silverscores = goldscores
        silverreffilename = options.platinuminfilename
    platinuminfilefound = True

    # rawcoreresults = {}
    # exact = True
    rawexactresults: ExactResultsDict = {}

    # @dit aanpassen , vooral de message-done
    if not os.path.exists(options.infilename):
        settings.LOGGER.error(
            'Input treebank or annotationfile {} not found. Aborting'.format(options.infilename))
        exit(1)

    # the next is now deprecated, we read in separfte silver reference files
    # gather remarks on results of earlier runs, write them to a perm_file  and adapt the silverscore file

    # (pathname, barefilename) = os.path.split(options.infilename)
    # (base, ext) = os.path.splitext(barefilename)
    # (fullbase, _) = os.path.splitext(options.infilename)
    # permpath = os.path.join(pathname, path2permfolder)

    # pathname = basepath
    # barefilename = basefilename
    base = corefilename
    ext = inext
    # permpath = silverpermpath
    fullbase = inbase

    # try:
    #    os.makedirs(permpath)
    # except FileExistsError:
    #    pass

    # perm_silverfilename = permprefix + corefilename + '.xlsx'
    # perm_silverfullname = os.path.join(permpath, perm_silverfilename)
    #
    # platinumcheckeditedfullname = os.path.join(resultspath, corefilename + checkeditedsuffix + '.xlsx')

    # platinumoutfilename = os.path.join(resultspath, corefilename + platinumsuffix + txtext)
    platinumcheckfilename = os.path.join(resultspath, corefilename + checksuffix + txtext)
    silvercheckfilename = os.path.join(resultspath, corefilename + checksuffix + '.xlsx')

    (platbase, platext) = os.path.splitext(platinumcheckfilename)
    platinumcheckxlfullname = platbase + '.xlsx'

    # silverannotationsdict = getsilverannotations(perm_silverfullname, platinumcheckeditedfullname,
    #                                             platinumcheckxlfullname, silvercheckfilename,
    #                                             platinumoutfilename, options.platinuminfilename, richgoldscores)

    analysedtrees: List[SynTree] = []
    nodeendmap = {}
    errordict = {}
    allorandalts = {}

    if annotationinput:
        allutts, richexactscores = get_golddata(
            options.infilename, themethod, options.includeimplies)
        uttcount = len(allutts)
        exactresults = richscores2scores(richexactscores)
        annotatedfileresults = AllResults(uttcount=uttcount,
                                          coreresults={},
                                          exactresults=exactresults,
                                          postresults={},
                                          allmatches={},
                                          filename=options.infilename,
                                          analysedtrees=[],
                                          allutts=allutts,
                                          annotationinput=annotationinput)
        origtreebank = None
        treebank = None
        targets = target_all
    else:
        tree = etree.parse(options.infilename)
        origtreebank = tree.getroot()
        annotatedfileresults = None
        targets = get_targets(origtreebank, options.methodname)
        if origtreebank.tag != 'treebank':
            settings.LOGGER.error(
                "Input treebank file does not contain a treebank element")
            exit(-1)

    # breakpoint()
    permdict = getallcomments(dataset, sample)

    scp = SastaCoreParameters(annotationinput, options.corr, themethod,
                              options.includeimplies, options.infilename, targets)

    if not annotationinput:
        if options.doauchann:
            treebank1 = doauchann(origtreebank)
        else:
            treebank1 = origtreebank

        methodname = scp.themethod.name
        corr = scp.corr
        themethod = scp.themethod

        # add xsid to trees that should have one but do not; put off becuase not needed anymore
        # treebank2 = tb_addxsid(treebank1, targets)
        treebank2 = treebank1

        thissamplecorrections = {}
        if options.dohistory:
            if options.methodname.lower() in {'tarsp', 'stap'}:
                samplecorrectionsfullname = children_samplecorrectionsfullname
                samplecorrections = children_samplecorrections
            elif options.methodname.lower() in {'asta'}:
                samplecorrectionsfullname = adult_samplecorrectionsfullname
                samplecorrections = adult_samplecorrections
            else: # should not occur
                settings.LOGGER.error(f'Illegal method name used: {options.method}')
                exit(-1)
            if corr != corr0:
                reducedtreebankfullname = os.path.relpath(options.infilename, start=settings.DATAROOT)
                if reducedtreebankfullname not in donefiles:
                    thissamplecorrections = gathercorrections(treebank2)
                else:
                    thissamplecorrections = {}
                # merge the corrections from this sample with the samplecorrections and update the file
                if options.extendhistory:
                    mergedsamplecorrections = mergecorrections(samplecorrections, thissamplecorrections)
                    putcorrections(mergedsamplecorrections, samplecorrectionsfullname)
                    donefiles.add(reducedtreebankfullname)
                    putdonefilenames(donefiles, donefilesfullname)
                else:
                    mergedsamplecorrections = samplecorrections
            else:
                mergedsamplecorrections = samplecorrections
        else:
            mergedsamplecorrections = {}

        contextdict = getcontextdict(treebank2, lambda x: True)

        correctionparameters = CorrectionParameters(themethod, options, mergedsamplecorrections,
                                                    thissamplecorrections, treebank2, contextdict)

        treebank, errordict, allorandalts = correcttreebank(treebank2, targets,  correctionparameters, corr=corr)

    allresults, samplesizetuple = sastacore(
        origtreebank, treebank, annotatedfileresults, scp)

    treebank = etree.Element('treebank')
    for _, tree in allresults.analysedtrees:
        treebank.append(tree)

    exactresults = allresults.exactresults
    exactresultsoutput = False
    if exactresultsoutput:
        jsonexactresults = {'/'.join(key): value for key, value in exactresults.items()}
        exactresultsfullname = os.path.join(settings.DATAROOT, dataset, 'exactresults', f'{sample}_exactresults.json')
        with open(exactresultsfullname, 'w', encoding='utf8') as exactresultsfile:
            json.dump(jsonexactresults, exactresultsfile)
    allutts = allresults.allutts
    uttcount = allresults.uttcount
    allmatches = allresults.allmatches

    # create the new treebank
    correctedfilename = f'{corefilename}{correctedsuffix}.xml'
    if treebank is not None:
        fulltreebank = etree.ElementTree(treebank)
        newtreebankfullname = os.path.join(
            outtreebankspath, correctedfilename)
        fulltreebank.write(newtreebankfullname, encoding="UTF8", xml_declaration=False,
                           pretty_print=True)

    # create the individual trees and filelists for inspection via Tred
    treebank2trees(treebank, dataset, newtreebankfullname)

    # create error file
    errorreportfilename = os.path.join(
        resultspath, corefilename + '_errorreport' + '.xlsx')
    mkerrorreport(errordict, errorreportfilename)

    # create error logging
    errorloggingfullname = os.path.join(
        loggingpath, corefilename + '_errorlogging' + '.xlsx')

    allerrorrows: List[str] = []
    for orandalts in allorandalts:
        if orandalts is not None:
            allerrorrows += orandalts.OrigandAlts2rows(corefilename)
    errorwb = mkworkbook(errorloggingfullname, [
                         errorwbheader], allerrorrows, freeze_panes=(1, 1))
    errorwb.close()

    # platinuminfilefound = False
    # if os.path.exists(options.platinuminfilename):
    #    platinuminfilefound = True
    #    platinumresults: Dict[ResultsKey, Counter] = read_referencefile(options.platinuminfilename, logfile)
    #    checkplatinum(goldscores, platinumresults, themethod.queries)
    # else:
    #     settings.LOGGER.info('Platinum file {} not found.'.format(options.platinuminfilename))
    #     platinumresults = {}

    # platinumoutfilename = base + platinumsuffix + txtext
    # platinumoutfile = open(platinumoutfilename, 'w', encoding='utf8')
    # platinumcheckfilename = base + checksuffix + txtext
    # platinumcheckfile = open(platinumcheckfilename, 'w', encoding='utf8')

    # bronze reduction
    exactgoldscores = reduceexactgoldscores(
        exactgoldscores, samplesizetuple, options.methodname)  # ongoing
    goldscores = exact2results(exactgoldscores)  # ongoing
    goldcounts = scores2counts(goldscores)

    # silver / platinumreduction
    exactsilverscores = reduceexactgoldscores(
        exactsilverscores, samplesizetuple, options.methodname)  # ongoing
    silverscores = exact2results(exactsilverscores)  # ongoing
    silvercounts = scores2counts(silverscores)

    # scores by utterance
    # bronzescoresbyutt = getscoresbyutt(allresults.coreresults, goldscores)
    # silverscoresbyutt = getscoresbyutt(allresults.coreresults, silverscores)

    byuttrows = mkscoresbyuttrows(allresults, goldscores, silverscores, themethod)
    not100count = len([row for row in byuttrows if row[silverf1col] != 100])
    scoresbyuttoutfullname = os.path.join(resultspath, corefilename + byuttscoressuffix + '.xlsx')
    wb = mkworkbook(scoresbyuttoutfullname, [byuttheader], byuttrows, freeze_panes=(1,0) )

    exactresultsbyutt = getexactbyutt(allresults.exactresults)
    exactresultsbyutttable = exactbyuttdict2table(exactresultsbyutt)
    add_worksheet(wb, [exactresultsbyuttheader], exactresultsbyutttable, sheetname='ExactResults', freeze_panes=(1,0))

    allbyuttscores = sas_impact(allresults.coreresults, silverscores, themethod)
    sasheader, sasimpactrows = mksas_impactrows(allbyuttscores, not100count)
    add_worksheet(wb,[sasheader], sasimpactrows, sheetname='SAS_impact', freeze_panes=(1,0))

    samplesizetupledata = [[comma.join(samplesizetuple[0]), samplesizetuple[1], samplesizetuple[2]]]
    samplesizetupleheader = ['utt ids', '# words', 'cutoff']
    add_worksheet(wb, [samplesizetupleheader], samplesizetupledata, sheetname='SampleSizeTuple', freeze_panes=(1,0))
    wb.close()



    # netx is now obsolete
    # platinumresults: Dict[ResultsKey, Counter] = reduceresults(platinumresults, samplesizetuple, options.methodname)

    (base, ext) = os.path.splitext(options.infilename)
    outputfullname = os.path.join(
        resultspath, corefilename + analysissuffix + tsvext + txtext)
    outfile = open(outputfullname, 'w', encoding='utf8')

    outxlsx = os.path.join(resultspath, corefilename + "_analysis" + xlsxext)
    outworkbook = xlsxwriter.Workbook(outxlsx, {"strings_to_numbers": True})
    outworksheet = outworkbook.add_worksheet()
    outstartrow = 0
    outstartcol = 0
    outrowctr = outstartrow
    outworksheet.freeze_panes('E2')

    countcomparisonfilename = os.path.join(
        resultspath, corefilename + '_countcomparison' + '.tsv' + '.txt')


    # print the invalid queries
    for q in invalidqueries:
        settings.LOGGER.error("{}: {}: <{}>".format(
            q, invalidqueries[q], themethod.queries[q].query))

    # print the header
    print(resultsheaderstring, file=outfile)
    outworksheet.write_row(outrowctr, outstartcol, resultsheaderrow)
    outrowctr += 1

    # print the platinumheader  (now obsolete)
    # print(platinumheaderstring, file=platinumoutfile)

    # print the results
    qcount = 0
    invalidqcount = 0
    undefinedqcount = 0
    results: Dict[ResultsKey, ResultsCounter] = allresults.coreresults
    # exactresults = getexactresults(allmatches)
    exact = True

    allrows = []

    reskeyindex = defaultdict(list)
    for reskey in results:
        reskeyindex[reskey[0]].append(reskey)

    analysedtreesdict = {uttid: stree for uttid, stree in allresults.analysedtrees}

    for queryid in themethod.queries:
        qcount += 1
        thequery = themethod.queries[queryid]
        if queryid not in reskeyindex:
            reskeys = [mkresultskey(queryid)]
        else:
            reskeys = reskeyindex[queryid]
        for reskey in reskeys:
            theresults = results[reskey] if reskey in results else Counter()
            resultstr = counter2liststr(theresults)

            sortedgolduttstr = getsortedgolduttscore(reskey, goldscores)

            qex, invalidqcount, undefinedqcount = updatequerycounts(queryid, themethod, invalidqcount,
                                                                    undefinedqcount)

            fullresultrow, platinumrow = getfullscoreandplatinumstr(reskey, themethod, theresults, resultstr,
                                                                    goldscores, platinuminfilefound,
                                                                    silverscores, sortedgolduttstr, qex)

            print(tab.join(fullresultrow), file=outfile)
            outworksheet.write_row(outrowctr, outstartcol, fullresultrow)
            outrowctr += 1

            # print(tab.join(platinumrow), file=platinumoutfile)  # now obsolete

            # @with an annotationfile allmatches is empty so we need to redefine newrows (exactmismatches) markedutt (getmarkedutt)-done
            if exact:
                # breakpoint()
                newrows = exactmismatches(reskey, themethod.queries, exactresults, exactsilverscores, allmatches,
                                          allutts, analysedtreesdict, sample, permdict, annotationinput)
                allrows += newrows
                # breakpoint()

    # platinumcheckfullname = platinumcheckfile.name
    # (base, ext) = os.path.splitext(platinumcheckfilename)
    # platinumcheckxlfullname = base + '.xlsx'

    # add missed literal hits
    literalmissedrows = literalmissedmatches(themethod.queries, exactresults, exactgoldscores, allmatches, allutts,
                                             analysedtreesdict, sample, permdict, annotationinput)
    allrows += literalmissedrows

    # breakpoint()

# filters=[(informcol, "inform == yes")] added again
    wb = mkworkbook(platinumcheckxlfullname, pcheaders, allrows, freeze_panes=(1, 9),
                    column_widths=platinumcheck_column_widths, filters=[(informcol, "inform == yes")])
    wb.close()

    writecsv(allrows, platinumcheckfilename, header=pcheaders[0])

    # add filelist
    # first remove not in form messages
    # first create tuples
    filteredrows = [row for row in allrows if row[informcol] == 'yes']
    datasetname, samplename = get_dataset_samplename(options.infilename)
    sample_uttids_tuples = get_samplename_uttids_tuples(filteredrows, samplecol, uttidcol)
    make_filelist(f'{samplename}_platinum_check', datasetname, sample_uttids_tuples, resultspath)



    # compute the gold postresults
    goldpostresults: Dict[UttId, int] = {}
    goldcounters: Dict[QId, ResultsCounter] = {}
    allgoldmatches: MatchesDict = {}
    for reskey in goldscores:
        goldcounters[reskey] = goldscores[reskey]
    allgoldresults = AllResults(uttcount, goldcounters, exactgoldscores, goldpostresults, allgoldmatches, reffilename,
                                [],
                                allannutts, annotationinput)
    postquerylist: List[QId] = [
        q for q in themethod.postquerylist if themethod.queries[q].process == post_process]
    dopostqueries(allgoldresults, postquerylist, themethod.queries)

    # compute the platinum postresults

    platinumpostresults: Dict[ResultsKey, Any] = {}

    # print the postresults
    thepostresults = allresults.postresults
    for queryid in postquerylist:
        resultposval = str(getpostval(queryid, thepostresults))
        goldpostval = str(getpostval(queryid, goldpostresults))
        platinumpostval = str(getpostval(queryid, platinumpostresults))
        if themethod.queries[queryid].query != '':
            qex = 'yes'
        else:
            qex = 'no'

        queryreskey = mkresultskey(queryid)
        queryreskeystr = showreskey(queryreskey)
        queryinforow = [queryreskeystr, themethod.queries[queryid].cat, themethod.queries[queryid].subcat,
                        themethod.queries[queryid].item]
        queryresultsrow = ['', resultposval, '', goldpostval,
                           qex] + erow(6) + [platinumpostval] + erow(11)

        postrow = queryinforow + queryresultsrow
        postrowstring = tab.join(queryinforow + queryresultsrow)
        print(postrowstring, sep=tab, file=outfile)
        outworksheet.write_row(outrowctr, outstartcol, postrow)
        outrowctr += 1

    # gather overall results, 2 cases: (1)for defined original measure queries only; (2) for all original measure queries

    overallmethods = [(1, 'Overall (defined pre and core queries in the profile)',
                       lambda x: is_preorcore(x) and query_exists(x) and query_inform(x)),
                      (2, 'Overall (all pre and core queries in the profile)',
                       lambda x: is_preorcore(x) and query_inform(x)),
                      (3, 'Overall (original pre and core measures with defined queries only)',
                       lambda x: is_preorcore(x) and query_exists(x)),
                      (4, 'Overall (all original pre and core measures)', lambda x: is_preorcore(x))]

    logheader = ['datetime', 'treebank', 'scorenr,' 'R', 'P', 'F1', 'P-R', 'P-P', 'P-F1', 'GP-R', 'GP-P', 'GP-F1',
                 'ref',
                 'method']
    logname = 'sastalog.txt'
    logpath = os.path.join(codepath, '../../sastalog')
    os.makedirs(logpath, exist_ok=True)
    logfullname = os.path.join(logpath, logname)
    biglogfile = open(logfullname, 'a', encoding='utf8')

    exactlynow = datetime.datetime.now()
    now = exactlynow.replace(microsecond=0).isoformat()

    for (ctr, message, queryfunction) in overallmethods:
        # gather resultscount
        resultscount = 0
        for reskey in results:
            queryid = reskey[0]
            thequery = themethod.queries[queryid]
            if thequery.original and queryfunction(thequery):
                resultscount += sum(results[reskey].values())

        # gather goldcount
        goldcount = 0
        for reskey in goldscores:
            queryid = reskey[0]
            thequery = themethod.queries[queryid]
            goldcounter = goldscores[reskey]
            if thequery.original and queryfunction(thequery):
                goldcount += sum(goldcounter.values())

        # gather platinumcount
        platinumcount = 0
        for reskey in silverscores:
            queryid = reskey[0]
            if queryid in themethod.queries:
                thequery = themethod.queries[queryid]
                if thequery.original and queryfunction(thequery):
                    platinumcount += sum(silverscores[reskey].values())
            else:
                settings.LOGGER.warning(
                    f'Query {reskey} found in silver scores but {queryid} not in queries')

        # resultsgoldintersectiocount
        resultsgoldintersectioncount = 0
        for reskey in results:
            queryid = reskey[0]
            thequery = themethod.queries[queryid]
            if thequery.original and queryfunction(thequery):
                if reskey in goldscores:
                    goldcounter = goldscores[reskey]
                    intersection = results[reskey] & goldcounter
                    resultsgoldintersectioncount += sum(intersection.values())
                else:
                    pass
                    # settings.LOGGER.warning(f'Query {reskey} found in results but not in goldscores')

        # resultsplatinumintersectioncount
        resultsplatinumintersectioncount = 0
        for reskey in results:
            queryid = reskey[0]
            thequery = themethod.queries[queryid]
            if thequery.original and queryfunction(thequery):
                if reskey in silverscores:
                    intersection = results[reskey] & silverscores[reskey]
                    resultsplatinumintersectioncount += sum(
                        intersection.values())
                else:
                    pass
                    # settings.LOGGER.warning('queryid {} not in silverscores'.format(queryid))

        # goldplatinumintersectioncount
        goldplatinumintersectioncount = 0
        for reskey in silverscores:
            queryid = reskey[0]
            if queryid in themethod.queries:
                thequery = themethod.queries[queryid]
                if thequery.original and queryfunction(thequery):
                    if reskey in goldscores:
                        goldcounter = goldscores[reskey]
                        intersection = goldcounter & silverscores[reskey]
                        goldplatinumintersectioncount += sum(
                            intersection.values())
                    else:
                        pass
                        # settings.LOGGER.warning('Query {} in silverscores but not in goldscores'.format(queryid))
            else:
                settings.LOGGER.warning(
                    f'Query {reskey} in silverscores but {queryid} not in queries')

        (recall, precision, f1score) = getevalscores(
            resultscount, goldcount, resultsgoldintersectioncount)
        (platinumrecall, platinumprecision, platinumf1score) = getevalscores(resultscount, platinumcount,
                                                                             resultsplatinumintersectioncount)
        (gprecall, gpprecision, gpf1score) = getevalscores(
            goldcount, platinumcount, goldplatinumintersectioncount)

        overallrow = ['', '', '', message, '', '', '', '', '', sf(recall), sf(precision), sf(f1score),
                      '', '', '', '', sf(platinumrecall), sf(
            platinumprecision), sf(platinumf1score), '', '',
            sf(gprecall), sf(gpprecision), sf(gpf1score), '', '', '']

        print(tab.join(overallrow), file=outfile)
        outworksheet.write_row(outrowctr, outstartcol, overallrow)
        outrowctr += 1

        logrow = [now, options.infilename, str(ctr), sf(recall), sf(precision), sf(f1score),
                  sf(platinumrecall), sf(platinumprecision), sf(platinumf1score),
                  sf(gprecall), sf(gpprecision), sf(gpf1score),
                  reffilename, options.methodfilename]

        print(tab.join(logrow), file=biglogfile)

    biglogfile.close()
    outfile.close()
    outworkbook.close()
    # platinumoutfile.close()

    resultscounts = scores2counts(results)

    countcomparison = get_comparison(
        resultscounts, goldcounts, themethod.queries)
    if countcomparison != []:
        countcomparisonfile = open(
            countcomparisonfilename, 'w', encoding='utf8')
        ccheader = ['Measure', 'result', 'gold', 'diff']
        ccheaderstr = tab.join(ccheader)
        print(ccheaderstr, file=countcomparisonfile)
        for (q, r, g) in countcomparison:
            if not (r == 0 and g == 0):
                print(q, r, g, r - g, sep=tab, file=countcomparisonfile)

    definedqcount = qcount - undefinedqcount

    (definedfornonemptygoldscore, undefinedqueries) = get_definedfornonemptygold(
        goldscores, themethod.queries)
    (definedfornonemptygoldcounts, undefinedqueries) = get_definedfornonemptygold(
        goldcounts, themethod.queries)

    lgoldscores = len(goldscores)

    if lgoldscores != 0:
        percentagecompletion1 = definedfornonemptygoldscore / lgoldscores * 100
        percentagecompletion1str = '{0:.1f}%'.format(percentagecompletion1)
    else:
        percentagecompletion1str = 'N/A'

    lgoldcounts = len(goldcounts)
    if lgoldcounts != 0:
        percentagecompletion2 = definedfornonemptygoldcounts / lgoldcounts * 100
        percentagecompletion2str = '{0:.1f}%'.format(percentagecompletion2)
    else:
        percentagecompletion2str = 'N/A'

    finalmessagetemplate1 = '{} measures, {} undefined, {} defined,  of which {} invalid.'
    finalmessagetemplate2 = '{} measures defined for a non empty gold score out of {} ({}).'
    finalmessagetemplate3 = '{} measures defined for a non empty gold count out of {} ({}).'
    print(finalmessagetemplate1.format(
        qcount, undefinedqcount, definedqcount, invalidqcount))
    print(finalmessagetemplate2.format(
        definedfornonemptygoldscore, lgoldscores, percentagecompletion1str))
    print(finalmessagetemplate3.format(
        definedfornonemptygoldcounts, lgoldcounts, percentagecompletion2str))
    print('Undefined queries:', undefinedqueries)
    settings.LOGGER.info("Done!")
    end_time = time.time()
    duration = end_time - start_time
    timing_message = f'Duration: {duration:.2f} seconds'
    print(timing_message)
    settings.LOGGER.info(timing_message)


if __name__ == '__main__':
    main()

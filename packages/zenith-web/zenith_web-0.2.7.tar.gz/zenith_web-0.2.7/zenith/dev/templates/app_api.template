"""
Production-ready API built with Zenith.
Demonstrates: SQLModel, Router grouping, Service pattern, performance optimization, and modern best practices.
"""
from zenith import Zenith, Router, Service, Inject, not_found
from zenith.db import SQLModel, Field, ZenithSQLModel, create_repository, AsyncSession
from zenith.performance_optimizations import create_api_app

# Create optimized API app with performance-first middleware configuration
# - Minimal security headers (essential only)
# - High rate limits (10K/hour per IP)  
# - Minimal logging (WARNING level only)
# - Optimized compression (2KB+ responses only)
# - 69-121% better performance than default middleware
app = create_api_app(title="$project_name API", version="1.0.0")

# ============================================================================
# DATABASE MODELS (SQLModel - unified Pydantic + SQLAlchemy)
# ============================================================================

class ItemBase(SQLModel):
    """Base model for shared item fields."""
    title: str = Field(min_length=1, max_length=200)
    description: str = Field(default="", max_length=1000)

class Item(ItemBase, ZenithSQLModel, table=True):
    """Database model for items."""
    __tablename__ = "items"
    
    completed: bool = Field(default=False)

class ItemCreate(ItemBase):
    """Model for creating new items."""
    pass

class ItemUpdate(SQLModel):
    """Model for updating items."""
    title: str | None = Field(default=None, min_length=1, max_length=200)
    description: str | None = Field(default=None, max_length=1000)
    completed: bool | None = None

class ItemPublic(ItemBase):
    """Public model for API responses."""
    id: int
    completed: bool

# ============================================================================
# BUSINESS LOGIC (Service Pattern)
# ============================================================================

class ItemService(Service):
    """Service for item operations with clean business logic."""
    
    def __init__(self, container):
        super().__init__(container)
        # In real apps, get AsyncSession from container
        # self.db = container.get(AsyncSession)
        # self.items = create_repository(self.db, Item)
        
        # For demo purposes, using in-memory storage
        self.items = {}
        
    async def create_item(self, item_data: ItemCreate) -> Item:
        """Create a new item."""
        # In real apps: return await self.items.create(Item(**item_data.model_dump()))
        item_id = len(self.items) + 1
        item = Item(id=item_id, **item_data.model_dump())
        self.items[item_id] = item
        return item
    
    async def get_item(self, item_id: int) -> Item | None:
        """Get item by ID."""
        # In real apps: return await self.items.get(item_id)
        return self.items.get(item_id)
    
    async def list_items(self, offset: int = 0, limit: int = 100) -> list[Item]:
        """List items with pagination."""
        # In real apps: return await self.items.list(offset=offset, limit=limit)
        items = list(self.items.values())
        return items[offset:offset + limit]
    
    async def update_item(self, item_id: int, updates: ItemUpdate) -> Item | None:
        """Update an item."""
        # In real apps: return await self.items.update(item_id, **updates.model_dump(exclude_unset=True))
        item = self.items.get(item_id)
        if not item:
            return None
        
        update_data = updates.model_dump(exclude_unset=True)
        for field, value in update_data.items():
            setattr(item, field, value)
        return item
    
    async def delete_item(self, item_id: int) -> bool:
        """Delete an item."""
        # In real apps: return await self.items.delete(item_id)
        return self.items.pop(item_id, None) is not None

# Register service for dependency injection
app.register_context("items", ItemService)

# ============================================================================
# API ROUTES (Router Grouping)
# ============================================================================

# Create API router with common configuration
api_router = Router(
    prefix="/api/v1",
    tags=["api"]
)

# Items router with specific configuration
items_router = Router(
    prefix="/items",
    tags=["items"]
)

@items_router.get("/", response_model=list[ItemPublic])
async def list_items(
    offset: int = 0,
    limit: int = 100,
    items: ItemService = Inject()
) -> list[ItemPublic]:
    """List all items with pagination."""
    all_items = await items.list_items(offset=offset, limit=limit)
    return [ItemPublic.model_validate(item) for item in all_items]

@items_router.post("/", response_model=ItemPublic)
async def create_item(
    item: ItemCreate,
    items: ItemService = Inject()
) -> ItemPublic:
    """Create a new item."""
    created = await items.create_item(item)
    return ItemPublic.model_validate(created)

@items_router.get("/{item_id}", response_model=ItemPublic)
async def get_item(
    item_id: int,
    items: ItemService = Inject()
) -> ItemPublic:
    """Get item by ID."""
    item = await items.get_item(item_id)
    if not item:
        not_found(f"Item {item_id} not found")
    return ItemPublic.model_validate(item)

@items_router.patch("/{item_id}", response_model=ItemPublic)
async def update_item(
    item_id: int,
    updates: ItemUpdate,
    items: ItemService = Inject()
) -> ItemPublic:
    """Update an item."""
    updated = await items.update_item(item_id, updates)
    if not updated:
        not_found(f"Item {item_id} not found")
    return ItemPublic.model_validate(updated)

@items_router.delete("/{item_id}")
async def delete_item(
    item_id: int,
    items: ItemService = Inject()
) -> dict:
    """Delete an item."""
    deleted = await items.delete_item(item_id)
    if not deleted:
        not_found(f"Item {item_id} not found")
    return {"message": "Item deleted successfully"}

# Include routers in API
api_router.include_router(items_router)

# Root routes
@app.get("/")
async def root():
    """API information and available endpoints."""
    return {
        "message": "Zenith API ðŸš€",
        "version": "1.0.0",
        "docs": "/docs",
        "health": "/health",
        "endpoints": {
            "items": "/api/v1/items"
        }
    }

@app.get("/health")
async def health():
    """Health check endpoint."""
    return {"status": "healthy", "timestamp": "2024-01-01T00:00:00Z"}

# Include API router
app.include_router(api_router)

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="127.0.0.1", port=8000, reload=True)